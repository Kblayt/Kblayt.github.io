

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Kblayt">
  <meta name="keywords" content="">
  
    <meta name="description" content="计算机网络体系结构OSI 七层模型​	开放系统互连参考模型 (Open System Interconnect 简称 OSI）是国际标准化组织(ISO) 和国际电报电话咨询委员会(CCITT)联合制定的开放系统互连参考模型，为开放式互连信息系 统提供了一种功能结构的框架。其目的是为异种计算机互连提供一个共同的基础和标准框架， 并为保持相关标准的一致性和兼容性提供共同的参考。这里所说的开放系统，实质">
<meta property="og:type" content="article">
<meta property="og:title" content="1、深入理解网络通信和TCP、IP协议">
<meta property="og:url" content="https://kblayt.github.io/2024/01/04/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6/Netty/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="计算机网络体系结构OSI 七层模型​	开放系统互连参考模型 (Open System Interconnect 简称 OSI）是国际标准化组织(ISO) 和国际电报电话咨询委员会(CCITT)联合制定的开放系统互连参考模型，为开放式互连信息系 统提供了一种功能结构的框架。其目的是为异种计算机互连提供一个共同的基础和标准框架， 并为保持相关标准的一致性和兼容性提供共同的参考。这里所说的开放系统，实质">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110161244205.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110161303508.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110194136299.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110163900224.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110194501267.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110163951491.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110165636585.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110170401383.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110170943755.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110171249366.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110173813992.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110172834294.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110173844332.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110173904399.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240111145449661.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240111145855141.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240111150051869.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240111150234660.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240111150350996.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240111150543223.png">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240111151120188.png">
<meta property="article:published_time" content="2024-01-04T12:16:34.000Z">
<meta property="article:modified_time" content="2024-01-11T07:24:15.025Z">
<meta property="article:author" content="Kblayt">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://kblayt.github.io/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110161244205.png">
  
  
  
  <title>1、深入理解网络通信和TCP、IP协议 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"kblayt.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="1、深入理解网络通信和TCP、IP协议"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-01-04 20:16" pubdate>
          2024年1月4日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          109 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">1、深入理解网络通信和TCP、IP协议</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h2><p>​	开放系统互连参考模型 (Open System Interconnect 简称 OSI）是国际标准化组织(ISO) 和国际电报电话咨询委员会(CCITT)联合制定的开放系统互连参考模型，为开放式互连信息系 统提供了一种功能结构的框架。其目的是为异种计算机互连提供一个共同的基础和标准框架， 并为保持相关标准的一致性和兼容性提供共同的参考。这里所说的开放系统，实质上指的是 遵循 OSI 参考模型和相关协议能够实现互连的具有各种应用目的的计算机系统。 </p>
<p>​	OSI 采用了分层的结构化技术，共分七层，物理层、数据链路层、网络层、传输层、会 话层、表示层、应用层</p>
<p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110161244205.png" srcset="/img/loading.gif" lazyload alt="image-20240110161244205"></p>
<p><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/%E6%9F%A5%E7%9C%8B%E5%90%84%E7%B1%BB%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%9D%80">https://www.rfc-editor.org/查看各类协议网址</a></p>
<h2 id="TCP-x2F-IP-模型"><a href="#TCP-x2F-IP-模型" class="headerlink" title="TCP&#x2F;IP 模型"></a>TCP&#x2F;IP 模型</h2><p>​	OSI 模型比较复杂且学术化，所以我们实际使用的 TCP&#x2F;IP 模型，分 5 层，物理层、数据 链路层（也有 TCP&#x2F;IP 模型将物理层、数据链路层合称为网络接口层，与之对应的，协议就 被称为 TCP&#x2F;IP 四层协议模型）、网络层、传输层、应用层。两个模型之间的对应关系如图 所示：</p>
<p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110161303508.png" srcset="/img/loading.gif" lazyload alt="image-20240110161303508"></p>
<h2 id="TCP-x2F-IP-协议族"><a href="#TCP-x2F-IP-协议族" class="headerlink" title="TCP&#x2F;IP 协议族"></a>TCP&#x2F;IP 协议族</h2><p>​	Transmission Control Protocol&#x2F;Internet Protocol 的简写，中译名为传输控制协议&#x2F;因特网 互联协议，是 Internet 最基本的协议、Internet 国际互联网络的基础，由网络层的 IP 协议和 传输层的 TCP 协议组成。协议采用了 5 层的层级结构。然而在很多情况下，它是利用 IP 进 行通信时所必须用到的协议群的统称。也就是说，它其实是个协议家族，由很多个协议组成， 并且是在不同的层， 是互联网的基础通信架构。</p>
<p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110194136299.png" srcset="/img/loading.gif" lazyload alt="image-20240110194136299"></p>
<h3 id="IP、TCP-和-UDP"><a href="#IP、TCP-和-UDP" class="headerlink" title="IP、TCP 和 UDP"></a>IP、TCP 和 UDP</h3><p>​	在上述图形中，网际协议 IP 是 TCP&#x2F;IP 中非常重要的协议，往往用来确定网络中唯一的 一台计算设备，它的作用就好比我们现实生活中的电话号码或者或者通讯地址。所以这层负 责对数据加上 IP 地址（有发送它的主机的地址（源地址）和接收它的主机的地址（目的地 址））和其他的数据以确定传输的目标。</p>
<p>​	 而 TCP 和 UDP 都是传输层的协议，传输层主要为两台主机上的应用程序提供端到端的 通信。</p>
<p>​	 TCP 有点类似于我们日常生活中的打电话，电话接通后通过“喂”确认对方身份，听不 清会要求对方重说，对方说的太快了会要求对方说慢点，讲完了各说一句“再见”结束通话。 TCP 提供了一种可靠的数据传输服务，TCP 是面向连接的，也就是说，利用 TCP 通信的两台 主机首先要经历一个建立连接的过程，等到连接建立后才开始传输数据，而且传输过程中采 用“带重传的肯定确认”技术来实现传输的可靠性。TCP 还采用一种称为“滑动窗口”的方式进 行流量控制，发送完成后还会关闭连接。 </p>
<p>​	UDP（User Datagram Protocol 的简称， 中文名是用户数据报协议）有点类似于我们日 常生活中通过不靠谱的物流系统寄东西。UDP 是把数据直接发出去，而不管对方是不是在接 收，也不管对方是否能接收的了，也不需要接收方确认，属于不可靠的传输，可能会出现丢 包现象，实际应用中要求程序员编程验证。</p>
<p>​	 所以 TCP 要比 UDP 可靠的多。 </p>
<p>注意： 我们一些常见的网络应用基本上都是基于 TCP 和 UDP 的，这两个协议又会使用网络层 的 IP 协议。但是我们完全可以绕过传输层的 TCP 和 UDP，直接使用 IP，比如 Linux 内核中的 LVS 就可以直接基于 IP 层进行负载平衡调度；甚至还可以直接访问链路层，比如 tcpdump 程序就是直接和链路层进行通信的。</p>
<h2 id="TCP-x2F-IP-网络传输中的数据"><a href="#TCP-x2F-IP-网络传输中的数据" class="headerlink" title="TCP&#x2F;IP 网络传输中的数据"></a>TCP&#x2F;IP 网络传输中的数据</h2><p>​	 每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息， 如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容 为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。 </p>
<p>​	网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层 传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的 数据。我们用用户 A 发送，用户 B 接受来说说明： 	① 用户 A 应用程序处理 首先应用程序会进行编码处理产生报文&#x2F;消息（message）交给下面的 TCP 层。 </p>
<p>​	② 用户 A TCP 模块的处理 TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的 数据顺利发送至对端的可靠传输。为了实现这一功能，需要将应用层数据封装为报文段 （segment）并附加一个 TCP 首部然后交给下面的 IP 层。</p>
<p>​	 ③ 用户 A IP 模块的处理 IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端 加上自己的 IP 首部生成 IP 数据报（datagram）然后交给下面的数据链路层。 </p>
<p>​	④ 用户 A 数据链路层的处理 从 IP 传过来的 IP 包对于数据链路层来说就是数据。给这些数据附加上链路层首部封装为 链路层帧（frame），生成的链路层帧（frame）将通过物理层传输给接收端。 </p>
<p>​	⑤ 用户 B 数据链路层的处理 用户 B 主机收到链路层帧（frame）后，首先从链路层帧（frame）首部找到 MAC 地址判断 是否为发送给自己的包，若不是则丢弃数据。 如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。</p>
<p>​	 ⑥ 用户 B IP 模块的处理 IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址 匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例 子则是 TCP。 </p>
<p>​	⑦ 用户 B TCP 模块的处理 在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号 接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口 号识别的应用程序。</p>
<p>​	⑧ 用户 B 应用程序的处理 接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</p>
<p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110163900224.png" srcset="/img/loading.gif" lazyload alt="image-20240110163900224"></p>
<p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110194501267.png" srcset="/img/loading.gif" lazyload alt="image-20240110194501267"></p>
<h2 id="地址和端口号"><a href="#地址和端口号" class="headerlink" title="地址和端口号"></a>地址和端口号</h2><h3 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h3><p>​	我们常听说 MAC 地址和 IP 地址。 MAC 地址全称叫做媒体访问控制地址，也称为局域网地址（LAN Address），MAC 位址， 以太网地址（Ethernet Address）或物理地址（Physical Address），由网络设备制造商生产时 写在硬件内部。MAC 地址与网络无关，也即无论将带有这个地址的硬件（如网卡、集线器、 路由器等）接入到网络的何处，都有相同的 MAC 地址，它由厂商写在网卡的 BIOS 里，从理 论上讲，除非盗来硬件（网卡），否则是没有办法冒名顶替的。 </p>
<p>​	MAC 地址共 48 位（6 个字节）。前 24 位由 IEEE（电气和电子工程师协会）决定如何分 配，后 24 位由实际生产该网络设备的厂商自行制定。例如：FF:FF:FF:FF:FF:FF 或 FF-FF-FF-FF-FF-FF</p>
<p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110163951491.png" srcset="/img/loading.gif" lazyload alt="image-20240110163951491"></p>
<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>​	IP 地址（Internet Protocol Address）的全称叫作互联网协议地址，它的本义是为互联网 上的每一个网络和每一台主机配置一个唯一的逻辑地址，用来与物理地址作区分。 </p>
<p>​	所以 IP 地址用来识别 TCP&#x2F;IP 网络中互连的主机和路由器。IP 地址基于逻辑，比较灵 活，不受硬件限制，也容易记忆。 </p>
<p>​	IP 地址分为：IPv4 和 IPv6。我们这里着重讲的是 IPv4 地址，IP 地址是由 32 位的二进制 数组成，它们通常被分为 4 个“8 位二进制数”，我们可以把它理解为 4 个字节，格式表示 为：（A.B.C.D）。其中，A，B，C，D 这四个英文字母表示为 0-255 的十进制的整数。例： 192.168.1.1 </p>
<p>​	Tips：IP 地址和 MAC 地址之间的区别 </p>
<p>​	1、对于网络中的一些设备，路由器或者是 PC 及而言，IP 地址的设计是出于拓扑设计 出来的，只要在不重复 IP 地址的情况下，它是可以随意更改的；而 MAC 地址是根据生产厂 商烧录好的，它一般不能改动的，一般来说，当一台 PC 机的网卡坏了之后，更换了网卡之 后 MAC 地址就会变了。</p>
<p>​	2、在前面的介绍里面，它们最明显的区别就是长度不同，IP 地址的长度为 32 位，而 MAC 地址为 48 位。 </p>
<p>​	3、它们的寻址协议层不同。IP 地址应用于 OSI 模型的网络层，而 MAC 地址应用在 OSI 模型的数据链路层。 数据链路层协议可以使数据从一个节点传递到相同链路的另一个节点 上（通过 MAC 地址），而网络层协议使数据可以从一个网络传递到另一个网络上（ARP 根 据目的 IP 地址，找到中间节点的 MAC 地址，通过中间节点传送，从而最终到达目的网络）。</p>
<p>​	 4、分配依据不同。IP 地址的分配是基于我们自身定义的网络拓扑，MAC 地址的分配是 基于制造商</p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>​	在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中 进行通信的不同应用程序。因此，它也被称为程序地址。</p>
<p>​	 一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在 进行通信的应用程序，并准确地将数据传输。 </p>
<p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110165636585.png" srcset="/img/loading.gif" lazyload alt="image-20240110165636585"></p>
<p><strong>面试题：为什么端口号有 65535 个？</strong> </p>
<p>因为在 TCP、UDP 协议报文的开头，会分别有 16 位二进制来存储源端口号和目标端口 号，所以端口个数是 2^16&#x3D;65536 个，但是 0 号端口用来表示所有端口，所以实际可用的端 口号是 65535 个。</p>
<p><strong>端口号的确定</strong></p>
<ul>
<li>标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端 口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的 应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 0~1023 之 间，我们在编写自己的网络应用服务时，尽量不要使用这些端口号。 </li>
<li>时序分配法：服务器有必要确定监听端口号，以让客户端程序访问服务器上的服务。 但是客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口 号，而全权交给操作系统进行分配，客户端使用的临时端口号，操作系统分配的一般都是大 于 10000 的。</li>
</ul>
<p><strong>观察端口号</strong></p>
<p>​	Windows 下使用 netstat -ano 查看所有端口号，netstat -ano|findstr “&lt;端口号&gt;”查看 指定端口号。 </p>
<p>​	Linux 下可以用 root 用户执行 lsof -i:端口号查看指定端口占用。</p>
<p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110170401383.png" srcset="/img/loading.gif" lazyload alt="image-20240110170401383"></p>
<p>​	lsof -i -U：显示所有打开的 UNIX domain 和端口文件</p>
<p>​	我们用的更多的是 netstat </p>
<p>​	netstat -tunlp 用于显示 tcp，udp 的端口和进程等相关情况。 </p>
<p>​	netstat 查看端口占用语法格式： </p>
<p>​	netstat -tunlp | grep 端口号 </p>
<p>​	-t (tcp) 仅显示 tcp 相关选项 </p>
<p>​	-u (udp)仅显示 udp 相关选项 </p>
<p>​	-n 拒绝显示别名，能显示数字的全部转化为数字</p>
<p>​	 -l 仅列出在 Listen(监听)的服务状态 </p>
<p>​	-p 显示建立相关链接的程序名</p>
<h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110170943755.png" srcset="/img/loading.gif" lazyload alt="image-20240110170943755"></p>
<p>​	所以一般来说，不管计算机中有多少网卡，每个网卡都会有自己的 MAC 地址，这个 MAC 地址是不会变化的。而每个网卡在正常工作的情况下，都会有一个 IP 地址，这个 IP 地址完全是可以变化的。而这台计算机中承载的各种应用程序可以拥有自己的端口号，然后 通过服务器的网卡，正确地进行网络通信。 一台服务器上的不同网络应用程序必须有不同的端口号，A 程序启动了使用了端口 x， B 程序启动就不能使用端口 x，否则会报错“Address already in use”。 总的来说，操作系统是通过源 IP 地址、目标 IP 地址、协议号（协议类型）、源端口号 以及目标端口号这五个元素唯一性的识别一个网络上的通信。</p>
<p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110171249366.png" srcset="/img/loading.gif" lazyload alt="image-20240110171249366"></p>
<p><strong>面试题：一台主机上只能保持最多 65535 个 TCP 连接，对吗？</strong> </p>
<p>​	这个说法不对，我们分服务器和客户端分开讨论，以下的讨论都基于服务器和客户端都 只有 1 个 IP 地址。</p>
<pre><code class="hljs"> **服务端** 
</code></pre>
<p>​	我们已经知道网络通信五元组是由过源 IP 地址、目标 IP 地址、协议号（协议类型）、 源端口号以及目标端口号构成。现在考察的是 TCP 连接，自然五元组中的协议号已经定下 来了，于是网络通信五元组就变化为 TCP 四元组。 </p>
<p>​	那就是说 TCP 连接四元组是由源 IP 地址、源端口、目的 IP 地址和目的端口构成。 </p>
<p>​	很明显当四元组中任意一个元素发生了改变，那么就代表的是一条完全不同的新连接。 拿我们常用的 MySQL 举例，假设它的 IP 是 X，端口 3306。用户 A 基于 IP 地址 A1，端口 PA 连接 MySQL ，于是构成了一个 TCP 连接四元组(A1,PA,X,3306)。用户 B 基于 IP 地址 B1， 端口 PB 连接同一个 MySQL，这个时候 MySQL 需要开启一个新端口来和用户 B 通信吗？从 我们日常的开发就可以知道，MySQL 并不需要这么做，所以用户 B 就和 MySQL 构成了一个 新的 TCP 连接四元组(B1,PB,X,3306)。 </p>
<p>​	服务端理论上能达成的最高并发数量是多少？从我们上面的用户 A 和用户 B 构成的 TCP 连接四元组： </p>
<p>​	(A1,PA,X,3306)</p>
<p>​	 (B1,PB,X,3306) </p>
<p>​	可以看到目的 IP 地址和目的端口（X,3306）是不变的，这样就只剩下源 IP 地址、源端 口是可变的。IP 地址是一个 32 位的整数，所以源 IP 最大有 2 的 32 次方这么多个。 端 口是一个 16 位的整数，所以端口的数量就是 2 的 16 次方。2 的 32 次方（ip 数）× 2 的 16 次方（port 数）大约等于两百多万亿。所以理论上，我们每个 server 可以接收的连 接上限就是两百多万亿。 </p>
<p>​	当然实际上做不到，目前工程实践中可以达到的连接数在千万级别。基于 Java 的应用 程序大概能支持百万级别，具体怎么做会在本课程第五章中详细说明。</p>
<p>​	<strong>客户端</strong></p>
<p>​	前面我们已经说过，“客户端应用程序完全可以不用自己设置端口号，而全权交给操作 系统进行分配”，可用的端口号只有 6 万多，从这个角度考虑，客户端最多只能发起 6 万多 条 TCP 连接。但其实也不是。</p>
<p>​	从 TCP 连接四元组来考虑：源 IP 地址、源端口、目的 IP 地址和目的端口，目的 IP 地址 和目的端口指的是服务器的 IP 和端口，源 IP 地址、源端口自然就是客户端的。</p>
<p>​	只要服务器的 IP 或者端口不一样，即使客户端的 IP 和端口是一样的。这个四元组也 是属于一条完全不同的新连接。比如： </p>
<p>​	连接 1：客户端 IP 10000 服务器 IP 10000 </p>
<p>​	连接 2：客户端 IP 10000 服务器 IP 20000 </p>
<p>​	虽然客户端的 IP 和端口完全一样，但由于服务器侧的端口不同，所以仍然是两条不同的连 接。问题来了，客户端同一个端口可以连接不同的服务器吗？答案是可以的。 </p>
<p>​	客户端只要启动时不显示绑定到某个端口上，内核是可以使用一个端口连不同的服务端， 内核会自己进行选择并恰当地复用的，而且完全不会产生数据混乱，因为“源 IP 地址、目 标 IP 地址、源端口号以及目标端口号就能唯一性确定一个 TCP 连接”。 </p>
<p>​	那么对客户端来说，四元组里有 3 个可变，自然客户端能同时支持的连接数比服务器还 要大得多。</p>
<h2 id="TCP-特性"><a href="#TCP-特性" class="headerlink" title="TCP 特性"></a>TCP 特性</h2><p>​	在我们上面的讲述中，存在着客户端和服务端两者角色，在网络通信里是怎么区分的？ 这个就牵涉到了 TCP 的相关特性。 </p>
<p>​	TCP（Transmission Control Protocol）是面向连接的通信协议，通过三次握手建立连接， 然后才能开始数据的读写，通讯完成时要拆除连接，由于 TCP 是面向连接的所以只能用于端 到端的通讯。 </p>
<p>​	TCP 提供的是一种可靠的数据流服务，数据有可能被拆分后发送，那么采用超时重传机 制是和应答确认机制是组成 TCP 可靠传输的关键设计。 </p>
<p>​	而超时重传机制中最最重要的就是重传超时（RTO，Retransmission TimeOut）的时间选 择，很明显，在工程上和现实中网络环境是十分复杂多变的，有时候可能突然的抽风，有时 候可能突然的又很顺畅。在数据发送的过程中，如果用一个固定的值一直作为超时计时器的 时长是非常不经济也非常不准确的方法，这样的话，超时的时长就需要根据网络情况动态调 整，就需要采样统计一个数据包从发送端发送出去到接收到这个包的回复这段时长来动态设 置重传超时值，这个时长就是为 RTT，学名 round-trip time，然后再根据这个 RTT 通过各种 算法和公式平滑 RTT 值后，最终确定重传超时值。 </p>
<p>​	而 IP 层进行数据传输时，是不能保证数据包按照发送的顺序达到目的机器。当 IP 将把 它们向‘上’传送到 TCP 层后，TCP 将包排序并进行错误检查。TCP 数据包中包括序号和确认， 所以未按照顺序收到的包可以被排序，而损坏的包可以被重传。 </p>
<p>​	TCP 还采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用 以限制发送方的发送速度。 </p>
<p>​	同时 TCP 还允许在一个 TCP 连接上，通信的双方可以同时传输数据，也就是所谓的全 双工。</p>
<p>​	面向连接的服务（例如 Telnet、FTP、rlogin、X Windows 和 SMTP）需要高度的可靠性， 所以它们使用了 TCP。DNS 在某些情况下使用 TCP（发送和接收域名数据库），但使用 UDP 传送有关单个主机的信息。</p>
<h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><p>​	TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间 的准备工作。</p>
<p>​	 所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认 连接的建立。在 socket 编程中，这一过程由客户端执行 connect 来触发，所以网络通信中， 发起连接的一方我们称为客户端，接收连接的一方我们称之为服务端。</p>
<p>简易版：</p>
<p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110173813992.png" srcset="/img/loading.gif" lazyload alt="image-20240110173813992"></p>
<p>详细版：</p>
<p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110172834294.png" srcset="/img/loading.gif" lazyload alt="image-20240110172834294"></p>
<p>​	第一次握手：客户端将请求报文标志位 SYN 置为 1，请求报文的 Sequence Number 字段 （简称 seq）中填入一个随机值 J，并将该数据包发送给服务器端，客户端进入 SYN_SENT 状 态，等待服务器端确认。 </p>
<p>​	第二次握手：服务器端收到数据包后由请求报文标志位 SYN&#x3D;1 知道客户端请求建立连 接，服务器端将应答报文标志位 SYN 和 ACK 都置为 1，应答报文的 Acknowledgment Number 字段（简称 ack）中填入 ack&#x3D;J+1，应答报文的 seq 中填入一个随机值 K，并将该数据包发送 给客户端以确认连接请求，服务器端进入 SYN_RCVD 状态。 </p>
<p>​	第三次握手：客户端收到应答报文后，检查 ack 是否为 J+1，ACK 是否为 1，如果正确 则将第三个报文标志位 ACK 置为 1，ack&#x3D;K+1，并将该数据包发送给服务器端，服务器端检 查 ack 是否为 K+1，ACK 是否为 1，如果正确则连接建立成功，客户端和服务器端进入 ESTABLISHED 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p>
<h3 id="为什么-TCP-握手需要三次"><a href="#为什么-TCP-握手需要三次" class="headerlink" title="为什么 TCP 握手需要三次?"></a>为什么 TCP 握手需要三次?</h3><p>​	TCP 是可靠的传输控制协议，而三次握手是保证数据可靠传输又能提高传输效率的最小 次数。为什么？RFC793，也就是 TCP 的协议 RFC 中就谈到了原因，这是因为： </p>
<p>​	为了实现可靠数据传输， TCP 协议的通信双方，都必须维护一个序列号， 以标识发送 出去的数据包中，哪些是已经被对方收到的。</p>
<p>​	 举例说明：发送方在发送数据包（假设大小为 10 byte）时， 同时送上一个序号( 假设 为 500)，那么接收方收到这个数据包以后， 就可以回复一个确认号（510 &#x3D; 500 + 10） 告 诉发送方 “我已经收到了你的数据包， 你可以发送下一个数据包， 序号从 511 开始” 。 </p>
<p>​	三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号 起始值的必经步骤。 </p>
<p>​	如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列 号则得不到确认。 </p>
<p>​	至于为什么不是四次，很明显，三次握手后，通信的双方都已经知道了对方序列号起始 值，也确认了对方知道自己序列号起始值，第四次握手已经毫无必要了。</p>
<h3 id="TCP-的三次握手的漏洞-SYN-洪泛攻击"><a href="#TCP-的三次握手的漏洞-SYN-洪泛攻击" class="headerlink" title="TCP 的三次握手的漏洞-SYN 洪泛攻击"></a>TCP 的三次握手的漏洞-SYN 洪泛攻击</h3><p>​	但是在 TCP 三次握手中是有一个缺陷，被称为 SYN 洪泛攻击。三次握手中有一个第二 次握手，服务端向客户端应答请求，应答请求是需要客户端 IP 的，而且因为握手过程没有 完成，操作系统使用队列维持这个状态（Linux 2.2 以后，这个队列大小参数可以通过 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog 设置）。于是攻击者就伪造这个 IP，往服务器端狂 发送第一次握手的内容，当然第一次握手中的客户端 IP 地址是伪造的，从而服务端忙于进 行第二次握手，但是第二次握手是不会有应答的，所以导致服务器队列满，而拒绝连接。 </p>
<p>​	面对这种攻击，有以下的解决方案，最好的方案是防火墙。 </p>
<p>​	<strong>无效连接监视释放</strong> </p>
<p>​	这种方法不停监视所有的连接，包括三次握手的，还有握手一次的，反正是所有的，当 达到一定(与)阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁， 不管是正常的还是攻击的，所以这种方式不推荐。 </p>
<p>​	<strong>延缓 TCB 分配方法</strong></p>
<p>​	一般的做完第一次握手之后，服务器就需要为该请求分配一个 TCB（连接控制资源）， 通常这个资源需要 200 多个字节。延迟 TCB 的分配，当正常连接建立起来后再分配 TCB 则 可以有效地减轻服务器资源的消耗。 </p>
<p>​	<strong>使用防火墙</strong> </p>
<p>防火墙在确认了连接的有效性后，才向内部的服务器（Listener）发起 SYN 请求，</p>
<h3 id="TCP-四次挥手（分手）"><a href="#TCP-四次挥手（分手）" class="headerlink" title="TCP 四次挥手（分手）"></a>TCP 四次挥手（分手）</h3><p>四次挥手即终止 TCP 连接，就是指断开一个 TCP 连接时，需要客户端和服务端总共发 送 4 个包以确认连接的断开。在 socket 编程中，这一过程由客户端或服务端任一方执行 close 来触发。</p>
<p>简易版：</p>
<p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110173844332.png" srcset="/img/loading.gif" lazyload alt="image-20240110173844332"></p>
<p>​	由于 TCP 连接是全双工的，因此，每个方向都必须要单独进行关闭。首先进行关闭的一 方将执行主动关闭，而另一方则执行被动关闭。</p>
<p>详细版：</p>
<p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240110173904399.png" srcset="/img/loading.gif" lazyload alt="image-20240110173904399"></p>
<p>由上图可见，TCP 建立一个连接需 3 个分节，终止一个连接则需 4 个分节。</p>
<p>​	(1)某个应用进程首先调用 close，我们称该端执行主动关闭（active close)。该端的 TCP 于是发送一个 FIN 分节，表示数据发送完毕，应用进程进入 FIN-WAIT-1（终止等待 1）状态。</p>
<p>​	(2）接收到这个 FIN 的对端执行被动关闭(passive close)，发出确认报文。因为 FIN 的接 收意味着接收端应用进程在相应连接上再无额外数据可接收，接收端进入了 CLOSE-WAIT（关 闭等待）状态，这时候处于半关闭状态，即主动关闭端已经没有数据要发送了，但是被动关 闭端若发送数据，主动关闭端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。主动关闭端收到确认报文后进入 FIN-WAIT-2（终止等待 2）状 态。 </p>
<p>​	(3)一段时间后，被动关闭的应用进程将调用 close 关闭它的套接字。这导致它的 TCP 也 发送一个 FIN，表示它也没数据需要发送了。 </p>
<p>​	(4)接收这个最终 FIN 的原发送端 TCP（即执行主动关闭的那一端）确认这个 FIN 发出一 个确认 ACK 报文，并进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放， 必须经过 2∗MSL（最长报文段寿命&#x2F;最长分节生命期 max segement lifetime，MSL 是任何 IP 数据报能够在因特网中存活的最长时间，任何 TCP 实现都必须为 MSL 选择一个值。RFC  1122[Braden 1989]的建议值是 2 分钟，不过源自 Berkelcy 的实现传统上改用 30 秒这个值。 这意味着 TIME_WAIT 状态的持续时间在 1 分钟到 4 分钟之间）的时间后，当主动关闭端撤 销相应的 TCB 后，才进入 CLOSED 状态。 </p>
<p>​	(5) 被动关闭端只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，被动关闭端结束 TCP 连接的时间要比主动关闭 端早一些。 既然每个方向都需要一个 FIN 和一个 ACK，因此通常需要 4 个分节。我们使用限定词“通 常”是因为：某些情形下步骤 1 的 FIN 随数据一起发送;另外，步骤 2 和步骤 3 发送的分节 都出自执行被动关闭那-一端，有可能被合并成一个分节。</p>
<h3 id="为什么-TCP-的挥手需要四次？"><a href="#为什么-TCP-的挥手需要四次？" class="headerlink" title="为什么 TCP 的挥手需要四次？"></a>为什么 TCP 的挥手需要四次？</h3><p>​	TCP 是全双工的连接，必须两端同时关闭连接，连接才算真正关闭。 </p>
<p>​	如果一方已经准备关闭写，但是它还可以读另一方发送的数据。发送给 FIN 结束报文给 对方，对方收到后，回复 ACK 报文。当这方也已经写完了准备关闭，发送 FIN 报文，对方回 复 ACK。两端都关闭，TCP 连接正常关闭。</p>
<h3 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME-WAIT 状态？"></a>为什么需要 TIME-WAIT 状态？</h3><p>​	IME_WAIT 状态存在的原因有两点 </p>
<p>​	1、可靠的终止 TCP 连接。 </p>
<p>​	2、保证让迟来的 TCP 报文有足够的时间被识别并丢弃。 </p>
<p>​	根据前面的四次握手的描述，我们知道，客户端收到服务器的连接释放的 FIN 报文后， 必须发出确认。如最后这个 ACK 确认报文丢失，那么服务器没有收到这个 ACK 确认报文， 就要重发 FIN 连接释放报文，客户端要在某个状态等待这个 FIN 连接释放报文段然后回复确 认报文段，这样才能可靠的终止 TCP 连接。 </p>
<p>​	在 Linux 系统上，一个 TCP 端口不能被同时打开多次，当一个 TCP 连接处于 TIME_WAIT 状态时，我们无法使用该链接的端口来建立一个新连接。反过来思考，如果不存在 TIME_WAIT状态，则应用程序能过立即建立一个和刚关闭的连接相似的连接（这里的相似，是指他们具 有相同的 IP 地址和端口号）。这个新的、和原来相似的连接被称为原来连接的化身。新的 化身可能受到属于原来连接携带应用程序数据的 TCP 报文段（迟到的报文段），这显然是不 该发生的。这是 TIME_WAIT 状态存在的第二个原因。</p>
<h2 id="实战观察-TCP-报文"><a href="#实战观察-TCP-报文" class="headerlink" title="实战观察 TCP 报文"></a>实战观察 TCP 报文</h2><p>WireShark下载与安装：<a target="_blank" rel="noopener" href="https://www.wireshark.org/">Wireshark · Go Deep</a></p>
<p>现在我们用平时比较常见的连接 mysql 服务器来看看，打开一个 mysql 的客户端，准备 连接 IP 地址为 43.138.194.183 的云端 mysql。</p>
<p>接口的捕获过滤器设置：host 43.138.194.183。在显示过滤器中写上 tcp and !mysql</p>
<p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240111145449661.png" srcset="/img/loading.gif" lazyload alt="image-20240111145449661"></p>
<p>我们以TCP三次握手逐条分析，首先是第一条：</p>
<h3 id="第一次握手："><a href="#第一次握手：" class="headerlink" title="第一次握手："></a>第一次握手：</h3><p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240111145855141.png" srcset="/img/loading.gif" lazyload alt="image-20240111145855141"></p>
<p>从这里我们可以看出，这是数据链路层相关的信息，source 部分的地址和我们机器上的 mac 地址一模一样：</p>
<p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240111150051869.png" srcset="/img/loading.gif" lazyload alt="image-20240111150051869"></p>
<p>接下来，就是 IP 层的相关信息，其中表明了它的上一层协议是 TCP，同时本地和远程 服务器的 IP 地址：</p>
<p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240111150234660.png" srcset="/img/loading.gif" lazyload alt="image-20240111150234660"></p>
<p>接下来，就是 TCP 层的相关信息，其中包括了本地端口和远程服务端口，既然是 syn 包， 里面当然会带上 seq 值，本次通信是 1979849485，tcp 报文格式中的 syn 字段被设置为 1， 用来表明这是一个 syn 包：</p>
<p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240111150350996.png" srcset="/img/loading.gif" lazyload alt="image-20240111150350996"></p>
<h3 id="第二次握手："><a href="#第二次握手：" class="headerlink" title="第二次握手："></a>第二次握手：</h3><p>​	数据链路层和 IP 层的报文我们不再查阅，直接看 TCP 层的报文，很明显，这是服务器 给客户端的 ACK 报文，其中依然包括了远程服务端口和本地端口，同时服务器要把自己端 的 seq 值告诉客户端，我们看到实际值是2121917334。同时服务器要把客户端传给自己的 seq 值做个应答确认，所以我们看见 Acknowledgment number 字段值是 2272565314，刚好 是第一次握手中，客户端传递给服务端的 seq 值 2272565313加 1。同时 tcp 报文格式中的 syn 字段被设置为 1，Acknowledgment 字段被设置为 1，用来表明这是一个 syn&#x2F;ack 包。</p>
<p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240111150543223.png" srcset="/img/loading.gif" lazyload alt="image-20240111150543223"></p>
<h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><p><img src="/1%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%92%8CTCP%E3%80%81IP%E5%8D%8F%E8%AE%AE/image-20240111151120188.png" srcset="/img/loading.gif" lazyload alt="image-20240111151120188"></p>
<h2 id="UDP-和-UDT、QUIC"><a href="#UDP-和-UDT、QUIC" class="headerlink" title="UDP 和 UDT、QUIC"></a>UDP 和 UDT、QUIC</h2><h3 id="UDP-概述"><a href="#UDP-概述" class="headerlink" title="UDP 概述"></a>UDP 概述</h3><p>​	我们已经知道 UDP（User Datagram Protocol 的简称， 中文名是用户数据报 协议）是把数据直接发出去，而不管对方是不是在接收，也不管对方是否能接收的了，也不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应 用中要求程序员编程验证。</p>
<h3 id="UDP-单播和广播"><a href="#UDP-单播和广播" class="headerlink" title="UDP 单播和广播"></a>UDP 单播和广播</h3><p>​	单播的传输模式，定义为发送消息给一个由唯一的地址所标识的单一的网络目的地。面向连接的协议和无连接协议都支持这种模式。 </p>
<p>​	由于通讯不需要连接，所以可以实现广播发送，所谓广播——传输到网络（或者子网）上的所有主机。 </p>
<p>​	UDP 因为没有 TCP 等一系列复杂机制，所以使用也非常广泛，使用 UDP 的 服务包括 NTP（网络时间协议）和 DNS（DNS 也使用 TCP），包总量较少的通信 （DNS、SNMP 等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等 特定网络中的应用通信；4.DHCP 等协议就利用了 UDP 的广播功能。 </p>
<p>​	常用的 QQ，就是一个以 UDP 为主，TCP 为辅的通讯协议。</p>
<h3 id="UDT"><a href="#UDT" class="headerlink" title="UDT"></a>UDT</h3><p>​	基于 UDP 的数据传输协议（UDP-based Data Transfer Protocol，简称 UDT） 是一种互联网数据传输协议。UDT 的主要目的是支持高速广域网上的海量数据传 输，最典型的例子就是建立在光纤广域网上的网格计算，一些研究所在这样的网 络上运行他们的分布式的数据密集程式，例如，远程访问仪器、分布式数据挖掘 和高分辨率的多媒体流。</p>
<p>​	 而互联网上的标准数据传输协议 TCP 在高带宽长距离网络上性能很差。 顾 名思义，UDT 建于 UDP 之上，并引入新的拥塞控制和数据可靠性控制机制。UDT 是面向连接的双向的应用层协议。 </p>
<p>​	UDT 的特性主要包括在以下几个方面： </p>
<p>​	基于 UDP 的应用层协议：有基本网络知识的朋友都知道 TCP 和 UDP 的区别 和使用场景，但是有没有一种协议能同时兼顾 TCP 协议的安全可靠和 UDP 协议 的高效，那么 UDT 就是一种。</p>
<p>​	 面向连接的协议：面向连接意味着两个使用协议的应用在彼此交换数据之前 必须先建立一个连接，当然 UDT 是逻辑上存在的连接通道。这种连接的维护是 基于握手、Keep-alive（保活）以及关闭连接。 </p>
<p>​	可靠的协议：依靠包序号机制、接收者的 ACK 响应和丢包报告、ACK 序号机 制、重传机制(基于丢包报告和超时处理)来实现数据传输的可靠性。 </p>
<p>​	双工的协议：每个 UDT 实例包含发送端和接收端的信息。 </p>
<p>​	新的拥塞算法，并且具有可扩展的拥塞控制框架：新的拥塞控制算法不同于 基于窗口的 TCP 拥塞控制算法(慢启动和拥塞避免)，是混合的基于窗口的、基于 速率的拥塞控制算法。可扩展的拥塞控制框架开源的代码和拥塞控制的 C++类架 构，可支持开发者派生专用的拥塞控制算法。 </p>
<p>​	带宽估计：UDT 使用对包(PP – Packet pair)的机制来估计带宽值。即每 16 个 包为一组,最后一个是对包,即发送方不用等到下一个发送周期内再发送。接收方接收到对包后对其到达时间进行记录,可结合上次记录的值计算出链路的带宽(计 算的方法称为中值过滤法), 并在下次 ACK 中进行反馈。</p>
<h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><p>​	QUIC 代表”快速 UDP Internet 连接”，基于 UDP 的传输层协议，它本身就 是 Google 尝试将 TCP 协议重写为一种结合了 HTTP&#x2F;2、TCP、UDP 和 TLS（用于加 密）等多种技术的改进技术。 </p>
<p>​	谷歌希望 QUIC 通信技术逐渐取代 TCP 和 UDP，作为在 Internet 上移动二进 制数据的新选择协议，QUIC 协议的主要目的，是为了整合 TCP 协议的可靠性 和 UDP 协议的速度和效率。 </p>
<p>​	由于 TCP 是在操作系统内核和中间件固件中实现的，因此对 TCP 进行重大 更改几乎是不可能的（TCP 协议栈通常由操作系统实现，如 Linux、Windows 内 核或者其他移动设备操作系统。修改 TCP 协议是一项浩大的工程，因为每种设 备、系统的实现都需要更新）。但是，由于 QUIC 建立在 UDP 之上，因此没有这种限制。 </p>
<p>​	QUIC 的优势在于： </p>
<p>​	1、采用多路复用 思想，一个连接可以同时承载多个 流 ( stream )，同时发 起多个请求。 请求间完全 独立 ，某个请求阻塞甚至报文出错均不影响其他请 求。 </p>
<p>​	2、QUIC 只需要 1RTT（Round-Trip Time）的延迟就可以建立可靠安全的连接, 相对于 TCP+TLS 的 3 次 RTT 要更加快捷。之后客户端可以在本地缓存加密的认证 信息，再次与服务器建立连接时可以实现 0-RTT 的连接建立延迟。 </p>
<p>​	3、TCP 采用 重传 机制，而 QUIC 采用 纠错 机制。 TCP 发生丢包时，需要一个等待延时判断发生了丢包，然后再启动重传机制， 这个过程会造成一定的阻塞，影响传输时间。 而 QUIC 则采用一种更主动的方案，有点类似 RAID5 ，每 n 个包额外发 一个 校验和包 。 如果这 n 个包中丢了一个包，可以通过其他包和校验和恢复 出来，完全不需要重传。 </p>
<p>​	4、QUIC 直接基于客户端(应用进程)实现，而非基于内核，可以快速迭代更 新，不需要操作系统层面的改造，部署灵活。 </p>
<p>​	5、连接保持 QUIC 在客户端保存连接标识，当客户端 IP 或者端口发生变化时，可以快 速恢复连接 —— 客户端以标识请求服务端，服务端验证标识后感知客户端新地 址端口并重新关联，继续通讯。 这对于改善移动端应用连接体验意义重大(从 WiFi 切换到流量)。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>1、深入理解网络通信和TCP、IP协议</div>
      <div>https://kblayt.github.io/2024/01/04/系统架构/架构之分布式框架/Netty/1、深入理解网络通信和TCP、IP协议/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Kblayt</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年1月4日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/01/04/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6/Netty/2%E3%80%81BIO%E3%80%81NIO%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E3%80%81%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%B7%B1%E5%85%A5%E8%BE%A8%E6%9E%90/" title="2、BIO、NIO编程与直接内存、零拷贝深入辨析">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">2、BIO、NIO编程与直接内存、零拷贝深入辨析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/12/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%84%E7%AE%97%E6%B3%95-%E9%AB%98%E7%BA%A7/" title="数据结构预算法-高级">
                        <span class="hidden-mobile">数据结构预算法-高级</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
