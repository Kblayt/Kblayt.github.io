

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Kblayt">
  <meta name="keywords" content="">
  
    <meta name="description" content="什么是 CASCAS（Compare And Swap，比较并交换），通常指的是这样一种原子操作：针对一个变量，首先比较它的内存值与某个期望值是否相同，如果相同，就给它赋一个新值。 CAS 的逻辑用伪代码描述如下： 12if (value &#x3D;&#x3D; expectedValue) &amp;#123;    value &#x3D; newValue;  以上伪代码描述了一个由比较和赋值两阶段组成的复合操作，CAS 可以">
<meta property="og:type" content="article">
<meta property="og:title" content="6、并发编程之CAS&amp;Atomic原子操作详情">
<meta property="og:url" content="https://kblayt.github.io/2023/06/16/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="什么是 CASCAS（Compare And Swap，比较并交换），通常指的是这样一种原子操作：针对一个变量，首先比较它的内存值与某个期望值是否相同，如果相同，就给它赋一个新值。 CAS 的逻辑用伪代码描述如下： 12if (value &#x3D;&#x3D; expectedValue) &amp;#123;    value &#x3D; newValue;  以上伪代码描述了一个由比较和赋值两阶段组成的复合操作，CAS 可以">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kblayt.github.io/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1642">
<meta property="og:image" content="https://kblayt.github.io/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1643">
<meta property="og:image" content="https://kblayt.github.io/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1641">
<meta property="og:image" content="https://kblayt.github.io/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1640">
<meta property="og:image" content="https://kblayt.github.io/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1639">
<meta property="og:image" content="https://kblayt.github.io/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1645">
<meta property="og:image" content="https://kblayt.github.io/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1644">
<meta property="og:image" content="https://kblayt.github.io/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1657">
<meta property="og:image" content="https://kblayt.github.io/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1656">
<meta property="og:image" content="https://kblayt.github.io/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1659">
<meta property="og:image" content="https://kblayt.github.io/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1652">
<meta property="og:image" content="https://kblayt.github.io/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1661">
<meta property="og:image" content="https://kblayt.github.io/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1660">
<meta property="og:image" content="https://kblayt.github.io/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1654">
<meta property="og:image" content="https://kblayt.github.io/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1658">
<meta property="og:image" content="https://kblayt.github.io/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1655">
<meta property="og:image" content="https://kblayt.github.io/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1653">
<meta property="article:published_time" content="2023-06-16T15:35:52.000Z">
<meta property="article:modified_time" content="2023-06-26T07:48:10.803Z">
<meta property="article:author" content="Kblayt">
<meta property="article:tag" content="并发编程">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://kblayt.github.io/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1642">
  
  
  
  <title>6、并发编程之CAS&amp;Atomic原子操作详情 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"kblayt.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="6、并发编程之CAS&amp;Atomic原子操作详情"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-06-16 23:35" pubdate>
          2023年6月16日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          146 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">6、并发编程之CAS&amp;Atomic原子操作详情</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="什么是-CAS"><a href="#什么是-CAS" class="headerlink" title="什么是 CAS"></a><strong>什么是 CAS</strong></h1><p>CAS（Compare And Swap，比较并交换），通常指的是这样一种原子操作：针对一个变量，首先比较它的内存值与某个期望值是否相同，如果相同，就给它赋一个新值。</p>
<p>CAS 的逻辑用伪代码描述如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (value == expectedValue) &#123;<br>    value = newValue;<br></code></pre></td></tr></table></figure>

<p>以上伪代码描述了一个由比较和赋值两阶段组成的复合操作，CAS 可以看作是它们合并后的整体——一个不可分割的原子操作，并且其原子性是直接在硬件层面得到保障的。</p>
<p>CAS可以看做是乐观锁（对比数据库的悲观、乐观锁）的一种实现方式，Java原子类中的递增操作就通过CAS自旋实现的。</p>
<p>CAS是一种无锁算法，在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。</p>
<p><strong>CAS应用</strong></p>
<p>在 Java 中，CAS 操作是由 Unsafe 类提供支持的，该类定义了三种针对不同类型变量的 CAS 操作，如图</p>
<p>​    <img src="/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1642" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>它们都是 native 方法，由 Java 虚拟机提供具体实现，这意味着不同的 Java 虚拟机对它们的实现可能会略有不同。</p>
<p>以 compareAndSwapInt 为例，Unsafe 的 compareAndSwapInt 方法接收 4 个参数，分别是：对象实例、内存偏移量、字段期望值、字段新值。该方法会针对指定对象实例中的相应偏移量的字段执行 CAS 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CASTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Entity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entity</span>();<br><br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> UnsafeFactory.getUnsafe();<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> UnsafeFactory.getFieldOffset(unsafe, Entity.class, <span class="hljs-string">&quot;x&quot;</span>);<br><br>        <span class="hljs-type">boolean</span> successful;<br><br>        <span class="hljs-comment">// 4个参数分别是：对象实例、字段的内存偏移量、字段期望值、字段新值</span><br>        successful = unsafe.compareAndSwapInt(entity, offset, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>        System.out.println(successful + <span class="hljs-string">&quot;\t&quot;</span> + entity.x);<br><br>        successful = unsafe.compareAndSwapInt(entity, offset, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>        System.out.println(successful + <span class="hljs-string">&quot;\t&quot;</span> + entity.x);<br><br>        successful = unsafe.compareAndSwapInt(entity, offset, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>);<br>        System.out.println(successful + <span class="hljs-string">&quot;\t&quot;</span> + entity.x);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsafeFactory</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取 Unsafe 对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title function_">getUnsafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> (Unsafe) field.get(<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取字段的内存偏移量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> unsafe</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fieldName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getFieldOffset</span><span class="hljs-params">(Unsafe unsafe, Class clazz, String fieldName)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> unsafe.objectFieldOffset(clazz.getDeclaredField(fieldName));<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>测试</p>
<p>针对 entity.x 的 3 次 CAS 操作，分别试图将它从 0 改成 3、从 3 改成 5、从 3 改成 8。执行结果如下：</p>
<p>​    <img src="/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1643" srcset="/img/loading.gif" lazyload alt="0"></p>
<p><strong>CAS源码分析</strong></p>
<p>Hotspot 虚拟机对compareAndSwapInt 方法的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#unsafe.cpp</span><br><span class="hljs-built_in">UNSAFE_ENTRY</span>(jboolean, <span class="hljs-built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))<br>  <span class="hljs-built_in">UnsafeWrapper</span>(<span class="hljs-string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);<br>  oop p = JNIHandles::<span class="hljs-built_in">resolve</span>(obj);<br>  <span class="hljs-comment">// 根据偏移量，计算value的地址</span><br>  jint* addr = (jint *) <span class="hljs-built_in">index_oop_from_field_offset_long</span>(p, offset);<br>  <span class="hljs-comment">// Atomic::cmpxchg(x, addr, e) cas逻辑 x:要交换的值   e:要比较的值</span><br>  <span class="hljs-comment">//cas成功，返回期望值e，等于e,此方法返回true </span><br>  <span class="hljs-comment">//cas失败，返回内存中的value值，不等于e，此方法返回false</span><br>  <span class="hljs-keyword">return</span> (jint)(Atomic::<span class="hljs-built_in">cmpxchg</span>(x, addr, e)) == e;<br></code></pre></td></tr></table></figure>

<p>核心逻辑在Atomic::cmpxchg方法中，这个根据不同操作系统和不同CPU会有不同的实现。这里我们以linux_64x的为例，查看Atomic::cmpxchg的实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">#atomic_linux_x86.<span class="hljs-keyword">inline</span>.<span class="hljs-function">hpp</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> jint     <span class="hljs-title">Atomic::cmpxchg</span>    <span class="hljs-params">(jint     exchange_value, <span class="hljs-keyword">volatile</span> jint*     dest, jint     compare_value)</span> </span>&#123;<br>  <span class="hljs-comment">//判断当前执行环境是否为多处理器环境</span><br>  <span class="hljs-type">int</span> mp = os::<span class="hljs-built_in">is_MP</span>();<br>  <span class="hljs-comment">//LOCK_IF_MP(%4) 在多处理器环境下，为 cmpxchgl 指令添加 lock 前缀，以达到内存屏障的效果</span><br>  <span class="hljs-comment">//cmpxchgl 指令是包含在 x86 架构及 IA-64 架构中的一个原子条件指令，</span><br>  <span class="hljs-comment">//它会首先比较 dest 指针指向的内存值是否和 compare_value 的值相等，</span><br>  <span class="hljs-comment">//如果相等，则双向交换 dest 与 exchange_value，否则就单方面地将 dest 指向的内存值交给exchange_value。</span><br>  <span class="hljs-comment">//这条指令完成了整个 CAS 操作，因此它也被称为 CAS 指令。</span><br>  <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span> <span class="hljs-params">(LOCK_IF_MP(%<span class="hljs-number">4</span>) <span class="hljs-string">&quot;cmpxchgl %1,(%3)&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">                    : <span class="hljs-string">&quot;=a&quot;</span> (exchange_value)</span></span><br><span class="hljs-params"><span class="hljs-function">                    : <span class="hljs-string">&quot;r&quot;</span> (exchange_value), <span class="hljs-string">&quot;a&quot;</span> (compare_value), <span class="hljs-string">&quot;r&quot;</span> (dest), <span class="hljs-string">&quot;r&quot;</span> (mp)</span></span><br><span class="hljs-params"><span class="hljs-function">                    : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>)</span></span>;<br>  <span class="hljs-keyword">return</span> exchange_value;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>cmpxchgl的详细执行过程：</p>
<p>首先，输入是”r” (exchange_value), “a” (compare_value), “r” (dest), “r” (mp)，表示compare_value存入eax寄存器，而exchange_value、dest、mp的值存入任意的通用寄存器。嵌入式汇编规定把输出和输入寄存器按统一顺序编号，顺序是从输出寄存器序列从左到右从上到下以“%0”开始，分别记为%0、%1···%9。也就是说，输出的eax是%0，输入的exchange_value、compare_value、dest、mp分别是%1、%2、%3、%4。</p>
<p>因此，cmpxchg %1,(%3)实际上表示cmpxchg exchange_value,(dest)</p>
<p>需要注意的是cmpxchg有个隐含操作数eax，其实际过程是先比较eax的值(也就是compare_value)和dest地址所存的值是否相等，</p>
<p>输出是”&#x3D;a” (exchange_value)，表示把eax中存的值写入exchange_value变量中。</p>
<p>Atomic::cmpxchg这个函数最终返回值是exchange_value，也就是说，如果cmpxchgl执行时compare_value和dest指针指向内存值相等则会使得dest指针指向内存值变成exchange_value，最终eax存的compare_value赋值给了exchange_value变量，即函数最终返回的值是原先的compare_value。此时Unsafe_CompareAndSwapInt的返回值(jint)(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e就是true，表明CAS成功。如果cmpxchgl执行时compare_value和(dest)不等则会把当前dest指针指向内存的值写入eax，最终输出时赋值给exchange_value变量作为返回值，导致(jint)(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e得到false，表明CAS失败。</p>
</blockquote>
<p>现代处理器指令集架构基本上都会提供 CAS 指令，例如 x86 和 IA-64 架构中的 cmpxchgl 指令和 comxchgq 指令，sparc 架构中的 cas 指令和 casx 指令。</p>
<p>不管是 Hotspot 中的 Atomic::cmpxchg 方法，还是 Java 中的 compareAndSwapInt 方法，它们本质上都是对相应平台的 CAS 指令的一层简单封装。CAS 指令作为一种硬件原语，有着天然的原子性，这也正是 CAS 的价值所在。</p>
<p><strong>CAS缺陷</strong></p>
<p>CAS 虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方面：</p>
<ul>
<li>自旋 CAS 长时间地不成功，则会给 CPU 带来非常大的开销</li>
<li>只能保证一个共享变量原子操作</li>
<li>ABA 问题</li>
</ul>
<p><strong>ABA问题及其解决方案</strong></p>
<p>CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p>
<p><strong>什么是ABA问题</strong></p>
<p>当有多个线程对一个原子类进行操作的时候，某个线程在短时间内将原子类的值A修改为B，又马上将其修改为A，此时其他线程不感知，还是会修改成功。</p>
<p>​    <img src="/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1641" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABATest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> atomicInteger.get();<br>            log.debug(<span class="hljs-string">&quot;Thread1 read value: &quot;</span> + value);<br><br>            <span class="hljs-comment">// 阻塞1s</span><br>            LockSupport.parkNanos(<span class="hljs-number">1000000000L</span>);<br><br>            <span class="hljs-comment">// Thread1通过CAS修改value值为3</span><br>            <span class="hljs-keyword">if</span> (atomicInteger.compareAndSet(value, <span class="hljs-number">3</span>)) &#123;<br>                log.debug(<span class="hljs-string">&quot;Thread1 update from &quot;</span> + value + <span class="hljs-string">&quot; to 3&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;Thread1 update fail!&quot;</span>);<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;Thread1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> atomicInteger.get();<br>            log.debug(<span class="hljs-string">&quot;Thread2 read value: &quot;</span> + value);<br>            <span class="hljs-comment">// Thread2通过CAS修改value值为2</span><br>            <span class="hljs-keyword">if</span> (atomicInteger.compareAndSet(value, <span class="hljs-number">2</span>)) &#123;<br>                log.debug(<span class="hljs-string">&quot;Thread2 update from &quot;</span> + value + <span class="hljs-string">&quot; to 2&quot;</span>);<br><br>                <span class="hljs-comment">// do something</span><br>                value = atomicInteger.get();<br>                log.debug(<span class="hljs-string">&quot;Thread2 read value: &quot;</span> + value);<br>                <span class="hljs-comment">// Thread2通过CAS修改value值为1</span><br>                <span class="hljs-keyword">if</span> (atomicInteger.compareAndSet(value, <span class="hljs-number">1</span>)) &#123;<br>                    log.debug(<span class="hljs-string">&quot;Thread2 update from &quot;</span> + value + <span class="hljs-string">&quot; to 1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;Thread2&quot;</span>).start();<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>Thread1不清楚Thread2对value的操作，误以为value&#x3D;1没有修改过</p>
<p>​    <img src="/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1640" srcset="/img/loading.gif" lazyload alt="0"></p>
<p><strong>ABA问题的解决方案</strong></p>
<p>数据库有个锁称为乐观锁，是一种基于数据版本实现数据同步的机制，每次修改一次数据，版本就会进行累加。</p>
<p>同样，Java也提供了相应的原子引用类AtomicStampedReference</p>
<p>​    <img src="/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1639" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>reference即我们实际存储的变量，stamp是版本，每次修改可以通过+1保证版本唯一性。这样就可以保证每次修改后的版本也会往上递增。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicStampedReferenceTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 定义AtomicStampedReference    Pair.reference值为1, Pair.stamp为1</span><br>        <span class="hljs-type">AtomicStampedReference</span> <span class="hljs-variable">atomicStampedReference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-type">int</span>[] stampHolder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) atomicStampedReference.get(stampHolder);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampHolder[<span class="hljs-number">0</span>];<br>            log.debug(<span class="hljs-string">&quot;Thread1 read value: &quot;</span> + value + <span class="hljs-string">&quot;, stamp: &quot;</span> + stamp);<br><br>            <span class="hljs-comment">// 阻塞1s</span><br>            LockSupport.parkNanos(<span class="hljs-number">1000000000L</span>);<br>            <span class="hljs-comment">// Thread1通过CAS修改value值为3</span><br>            <span class="hljs-keyword">if</span> (atomicStampedReference.compareAndSet(value, <span class="hljs-number">3</span>,stamp,stamp+<span class="hljs-number">1</span>)) &#123;<br>                log.debug(<span class="hljs-string">&quot;Thread1 update from &quot;</span> + value + <span class="hljs-string">&quot; to 3&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;Thread1 update fail!&quot;</span>);<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;Thread1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-type">int</span>[] stampHolder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)atomicStampedReference.get(stampHolder);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampHolder[<span class="hljs-number">0</span>];<br>            log.debug(<span class="hljs-string">&quot;Thread2 read value: &quot;</span> + value+ <span class="hljs-string">&quot;, stamp: &quot;</span> + stamp);<br>            <span class="hljs-comment">// Thread2通过CAS修改value值为2</span><br>            <span class="hljs-keyword">if</span> (atomicStampedReference.compareAndSet(value, <span class="hljs-number">2</span>,stamp,stamp+<span class="hljs-number">1</span>)) &#123;<br>                log.debug(<span class="hljs-string">&quot;Thread2 update from &quot;</span> + value + <span class="hljs-string">&quot; to 2&quot;</span>);<br><br>                <span class="hljs-comment">// do something</span><br><br>                value = (<span class="hljs-type">int</span>) atomicStampedReference.get(stampHolder);<br>                stamp = stampHolder[<span class="hljs-number">0</span>];<br>                log.debug(<span class="hljs-string">&quot;Thread2 read value: &quot;</span> + value+ <span class="hljs-string">&quot;, stamp: &quot;</span> + stamp);<br>                <span class="hljs-comment">// Thread2通过CAS修改value值为1</span><br>                <span class="hljs-keyword">if</span> (atomicStampedReference.compareAndSet(value, <span class="hljs-number">1</span>,stamp,stamp+<span class="hljs-number">1</span>)) &#123;<br>                    log.debug(<span class="hljs-string">&quot;Thread2 update from &quot;</span> + value + <span class="hljs-string">&quot; to 1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;Thread2&quot;</span>).start();<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>Thread1并没有成功修改value</p>
<p>​    <img src="/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1645" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>补充：AtomicMarkableReference可以理解为上面AtomicStampedReference的简化版，就是不关心修改过几次，仅仅关心是否修改过。因此变量mark是boolean类型，仅记录值是否有过修改。</p>
<p>​    <img src="/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1644" srcset="/img/loading.gif" lazyload alt="0"></p>
<h1 id="Atomic原子操作类介绍"><a href="#Atomic原子操作类介绍" class="headerlink" title="Atomic原子操作类介绍"></a><strong>Atomic原子操作类介绍</strong></h1><p>在并发编程中很容易出现并发安全的问题，有一个很简单的例子就是多线程更新变量i&#x3D;1,比如多个线程执行i++操作，就有可能获取不到正确的值，而这个问题，最常用的方法是通过Synchronized进行控制来达到线程安全的目的。但是由于synchronized是采用的是悲观锁策略，并不是特别高效的一种解决方案。实际上，在J.U.C下的atomic包提供了一系列的操作简单，性能高效，并能保证线程安全的类去更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。atomic包下的这些类都是采用的是乐观锁策略去原子更新数据，在java中则是使用CAS操作具体实现。</p>
<p>在java.util.concurrent.atomic包里提供了一组原子操作类：</p>
<p><strong>基本类型：</strong>AtomicInteger、AtomicLong、AtomicBoolean；</p>
<p><strong>引用类型：</strong>AtomicReference、AtomicStampedRerence、AtomicMarkableReference；</p>
<p><strong>数组类型：</strong>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p>
<p><strong>对象属性原子修改器</strong>：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater</p>
<p><strong>原子类型累加器（jdk1.8增加的类）</strong>：DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder、Striped64</p>
<p><strong>原子更新基本类型</strong></p>
<p>以AtomicInteger为例总结常用的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//以原子的方式将实例中的原值加1，返回的是自增前的旧值；</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, <span class="hljs-number">1</span>);<br>&#125;<br> <br><span class="hljs-comment">//getAndSet(int newValue)：将实例中的值更新为新值，并返回旧值；</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">getAndSet</span><span class="hljs-params">(<span class="hljs-type">boolean</span> newValue)</span> &#123;<br>    <span class="hljs-type">boolean</span> prev;<br>    <span class="hljs-keyword">do</span> &#123;<br>        prev = get();<br>    &#125; <span class="hljs-keyword">while</span> (!compareAndSet(prev, newValue));<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br> <br><span class="hljs-comment">//incrementAndGet() ：以原子的方式将实例中的原值进行加1操作，并返回最终相加后的结果；</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">incrementAndGet</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>&#125;<br> <br><span class="hljs-comment">//addAndGet(int delta) ：以原子方式将输入的数值与实例中原本的值相加，并返回最后的结果；</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addAndGet</span><span class="hljs-params">(<span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, delta) + delta;<br></code></pre></td></tr></table></figure>

<p>​         </p>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerTest</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                    <span class="hljs-comment">// 原子自增  CAS</span><br>                    sum.incrementAndGet();<br>                    <span class="hljs-comment">//TODO</span><br>                &#125;<br>            &#125;);<br>            thread.start();<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(sum.get());<br><br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>​    <img src="/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1657" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>incrementAndGet()方法通过CAS自增实现，如果CAS失败，自旋直到成功+1。</p>
<p>​    <img src="/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1656" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>思考：这种CAS失败自旋的操作存在什么问题?</p>
<p><strong>原子更新数组类型</strong></p>
<p>AtomicIntegerArray为例总结常用的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//addAndGet(int i, int delta)：以原子更新的方式将数组中索引为i的元素与输入值相加；</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addAndGet</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-keyword">return</span> getAndAdd(i, delta) + delta;<br>&#125;<br> <br><span class="hljs-comment">//getAndIncrement(int i)：以原子更新的方式将数组中索引为i的元素自增加1；</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">return</span> getAndAdd(i, <span class="hljs-number">1</span>);<br>&#125;<br> <br><span class="hljs-comment">//compareAndSet(int i, int expect, int update)：将数组中索引为i的位置的元素进行更新</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;<br>    <span class="hljs-keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);<br></code></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerArrayTest</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicIntegerArray</span> <span class="hljs-variable">atomicIntegerArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(value);<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-comment">//设置索引0的元素为100</span><br>        atomicIntegerArray.set(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br>        System.out.println(atomicIntegerArray.get(<span class="hljs-number">0</span>));<br>        <span class="hljs-comment">//以原子更新的方式将数组中索引为1的元素与输入值相加</span><br>        atomicIntegerArray.getAndAdd(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);<br><br>        System.out.println(atomicIntegerArray);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>​             </p>
<p><strong>原子更新引用类型</strong></p>
<p>AtomicReference作用是对普通对象的封装，它可以保证你在修改对象引用时的线程安全性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">( String[] args )</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">23</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">25</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">20</span>);<br><br>        <span class="hljs-comment">//初始化为 user1</span><br>        AtomicReference&lt;User&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br>        atomicReference.set(user1);<br><br>        <span class="hljs-comment">//把 user2 赋给 atomicReference</span><br>        atomicReference.compareAndSet(user1, user2);<br>        System.out.println(atomicReference.get());<br><br>        <span class="hljs-comment">//把 user3 赋给 atomicReference</span><br>        atomicReference.compareAndSet(user1, user3);<br>        System.out.println(atomicReference.get());<br>        <br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br></code></pre></td></tr></table></figure>

<p>​    </p>
<p><strong>对象属性原子修改器</strong></p>
<p>AtomicIntegerFieldUpdater可以线程安全地更新对象中的整型变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerFieldUpdaterTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candidate</span> &#123;<br><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">score2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicIntegerFieldUpdater&lt;Candidate&gt; scoreUpdater =<br>            AtomicIntegerFieldUpdater.newUpdater(Candidate.class, <span class="hljs-string">&quot;score&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">realScore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Candidate</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Candidate</span>();<br><br>        Thread[] t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[<span class="hljs-number">10000</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            t[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">if</span> (Math.random() &gt; <span class="hljs-number">0.4</span>) &#123;<br>                        candidate.score2.incrementAndGet();<br>                        scoreUpdater.incrementAndGet(candidate);<br>                        realScore.incrementAndGet();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>            t[i].start();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            t[i].join();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;AtomicIntegerFieldUpdater Score=&quot;</span> + candidate.score);<br>        System.out.println(<span class="hljs-string">&quot;AtomicInteger Score=&quot;</span> + candidate.score2.get());<br>        System.out.println(<span class="hljs-string">&quot;realScore=&quot;</span> + realScore.get());<br><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>对于AtomicIntegerFieldUpdater 的使用稍微有一些限制和约束，约束如下：</p>
<p>（1）字段必须是volatile类型的，在线程之间共享变量时保证立即可见.eg:volatile int value &#x3D; 3</p>
<p>（2）字段的描述类型（修饰符public&#x2F;protected&#x2F;default&#x2F;private）与调用者与操作对象字段的关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。但是对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。</p>
<p>（3）只能是实例变量，不能是类变量，也就是说不能加static关键字。</p>
<p>（4）只能是可修改变量，不能使final变量，因为final的语义就是不可修改。实际上final的语义和volatile是有冲突的，这两个关键字不能同时存在。</p>
<p>（5）对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int&#x2F;long类型的字段，不能修改其包装类型（Integer&#x2F;Long）。如果要修改包装类型就需要使用AtomicReferenceFieldUpdater。</p>
<p><strong>LongAdder&#x2F;DoubleAdder详解</strong></p>
<p>AtomicLong是利用了底层的CAS操作来提供并发性的，比如addAndGet方法：</p>
<p>​    <img src="/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1659" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>​    <img src="/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1652" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>上述方法调用了Unsafe类的getAndAddLong方法，该方法内部是个native方法，它的逻辑是采用自旋的方式不断更新目标值，直到更新成功。</p>
<p>在并发量较低的环境下，线程冲突的概率比较小，自旋的次数不会很多。但是，高并发环境下，N个线程同时进行自旋操作，会出现大量失败并不断自旋的情况，此时AtomicLong的自旋会成为瓶颈。</p>
<p>这就是<strong>LongAdder</strong>引入的初衷——解决高并发环境下<strong>AtomicInteger，AtomicLong</strong>的自旋瓶颈问题。</p>
<p><strong>性能测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongAdderTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        testAtomicLongVSLongAdder(<span class="hljs-number">10</span>, <span class="hljs-number">10000</span>);<br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>);<br>        testAtomicLongVSLongAdder(<span class="hljs-number">10</span>, <span class="hljs-number">200000</span>);<br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>);<br>        testAtomicLongVSLongAdder(<span class="hljs-number">100</span>, <span class="hljs-number">200000</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAtomicLongVSLongAdder</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> threadCount, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> times)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            testLongAdder(threadCount, times);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - start;<br>            System.out.println(<span class="hljs-string">&quot;条件&gt;&gt;&gt;&gt;&gt;&gt;线程数:&quot;</span> + threadCount + <span class="hljs-string">&quot;, 单线程操作计数&quot;</span> + times);<br>            System.out.println(<span class="hljs-string">&quot;结果&gt;&gt;&gt;&gt;&gt;&gt;LongAdder方式增加计数&quot;</span> + (threadCount * times) + <span class="hljs-string">&quot;次,共计耗时:&quot;</span> + end);<br><br>            <span class="hljs-type">long</span> <span class="hljs-variable">start2</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            testAtomicLong(threadCount, times);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">end2</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - start2;<br>            System.out.println(<span class="hljs-string">&quot;条件&gt;&gt;&gt;&gt;&gt;&gt;线程数:&quot;</span> + threadCount + <span class="hljs-string">&quot;, 单线程操作计数&quot;</span> + times);<br>            System.out.println(<span class="hljs-string">&quot;结果&gt;&gt;&gt;&gt;&gt;&gt;AtomicLong方式增加计数&quot;</span> + (threadCount * times) + <span class="hljs-string">&quot;次,共计耗时:&quot;</span> + end2);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAtomicLong</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> threadCount, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> times)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(threadCount);<br>        <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">atomicLong</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threadCount; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; times; j++) &#123;<br>                        atomicLong.incrementAndGet();<br>                    &#125;<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;, <span class="hljs-string">&quot;my-thread&quot;</span> + i).start();<br>        &#125;<br>        countDownLatch.await();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLongAdder</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> threadCount, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> times)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(threadCount);<br>        <span class="hljs-type">LongAdder</span> <span class="hljs-variable">longAdder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threadCount; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; times; j++) &#123;<br>                        longAdder.add(<span class="hljs-number">1</span>);<br>                    &#125;<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;, <span class="hljs-string">&quot;my-thread&quot;</span> + i).start();<br>        &#125;<br><br>        countDownLatch.await();<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>​      </p>
<p><strong>测试结果：线程数越多，并发操作数越大，LongAdder的优势越明显</strong></p>
<p>​    <img src="/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1661" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>低并发、一般的业务场景下AtomicLong是足够了。如果并发量很多，存在大量写多读少的情况，那LongAdder可能更合适。</p>
<p><strong>LongAdder原理</strong></p>
<p><strong>设计思路</strong></p>
<p>AtomicLong中有个内部变量value保存着实际的long值，所有的操作都是针对该变量进行。也就是说，高并发环境下，value变量其实是一个热点，也就是N个线程竞争一个热点。LongAdder的基本思路就是分散热点，将value值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。 </p>
<p>​    <img src="/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1660" srcset="/img/loading.gif" lazyload alt="0"></p>
<p><strong>LongAdder的内部结构</strong></p>
<p>LongAdder内部有一个base变量，一个Cell[]数组：</p>
<p>base变量：非竞态条件下，直接累加到该变量上</p>
<p>Cell[]数组：竞态条件下，累加个各个线程自己的槽Cell[i]中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Number of CPUS, to place bound on table size */</span><br><span class="hljs-comment">// CPU核数，用来决定槽数组的大小</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NCPU</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Table of cells. When non-null, size is a power of 2.</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 数组槽，大小为2的次幂</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Base value, used mainly when there is no contention, but also as</span><br><span class="hljs-comment"> * a fallback during table initialization races. Updated via CAS.</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  基数，在两种情况下会使用：</span><br><span class="hljs-comment"> *  1. 没有遇到并发竞争时，直接使用base累加数值</span><br><span class="hljs-comment"> *  2. 初始化cells数组时，必须要保证cells数组只能被初始化一次（即只有一个线程能对cells初始化），</span><br><span class="hljs-comment"> *  其他竞争失败的线程会讲数值累加到base上</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> base;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Spinlock (locked via CAS) used when resizing and/or creating Cells.</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<p>定义了一个内部Cell类，这就是我们之前所说的槽，每个Cell对象存有一个value值，可以通过Unsafe来CAS操作它的值：</p>
<p>​    <img src="/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1654" srcset="/img/loading.gif" lazyload alt="0"></p>
<p><strong>LongAdder#add方法</strong></p>
<p>LongAdder#add方法的逻辑如下图：</p>
<p>​    <img src="/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1658" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>只有从未出现过并发冲突的时候，base基数才会使用到，一旦出现了并发冲突，之后所有的操作都只针对Cell[]数组中的单元Cell。</p>
<p>如果Cell[]数组未初始化，会调用父类的longAccumelate去初始化Cell[]，如果Cell[]已经初始化但是冲突发生在Cell单元内，则也调用父类的longAccumelate，此时可能就需要对Cell[]扩容了。</p>
<p>这也是LongAdder设计的精妙之处：尽量减少热点冲突，不到最后万不得已，尽量将CAS操作延迟。</p>
<p><strong>Striped64#longAccumulate方法</strong></p>
<p>整个Striped64#longAccumulate的流程图如下：</p>
<p>​    <img src="/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1655" srcset="/img/loading.gif" lazyload alt="0"></p>
<p><strong>LongAdder#sum方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 返回累加的和，也就是&quot;当前时刻&quot;的计数值</span><br><span class="hljs-comment">* 注意： 高并发时，除非全局加锁，否则得不到程序运行中某个时刻绝对准确的值</span><br><span class="hljs-comment">*  此返回值可能不是绝对准确的，因为调用这个方法时还有其他线程可能正在进行计数累加,</span><br><span class="hljs-comment">*  方法的返回时刻和调用时刻不是同一个点，在有并发的情况下，这个值只是近似准确的计数值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;<br>    Cell[] as = cells; Cell a;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> base;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-literal">null</span>)<br>                sum += a.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br></code></pre></td></tr></table></figure>

<p>由于计算总和时没有对Cell数组进行加锁，所以在累加过程中可能有其他线程对Cell中的值进行了修改，也有可能对数组进行了扩容，所以sum返回的值并不是非常精确的，其返回值并不是一个调用sum方法时的原子快照值。</p>
<p><strong>LongAccumulator</strong></p>
<p>LongAccumulator是LongAdder的增强版。LongAdder只能针对数值的进行加减运算，而LongAccumulator提供了自定义的函数操作。其构造函数如下：</p>
<p>​    <img src="/6%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS-Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/1653" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>通过LongBinaryOperator，可以自定义对入参的任意操作，并返回结果（LongBinaryOperator接收2个long作为参数，并返回1个long）。LongAccumulator内部原理和LongAdder几乎完全一样，都是利用了父类Striped64的longAccumulate方法。</p>
<p>public class LongAccumulatorTest {</p>
<p>​    public static void main(String[] args) throws InterruptedException {</p>
<p>​        &#x2F;&#x2F; 累加 x+y</p>
<p>​        LongAccumulator accumulator &#x3D; new LongAccumulator((x, y) -&gt; x + y, 0);</p>
<p>​        ExecutorService executor &#x3D; Executors.newFixedThreadPool(8);</p>
<p>​        &#x2F;&#x2F; 1到9累加</p>
<p>​        IntStream.range(1, 10).forEach(i -&gt; executor.submit(() -&gt; accumulator.accumulate(i)));</p>
<p>​        Thread.sleep(2000);</p>
<p>​        System.out.println(accumulator.getThenReset());</p>
<p>​    }</p>
<p>}</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/" class="category-chain-item">系统架构</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="category-chain-item">架构之并发编程</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">#并发编程</a>
      
        <a href="/tags/JUC/">#JUC</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>6、并发编程之CAS&amp;Atomic原子操作详情</div>
      <div>https://kblayt.github.io/2023/06/16/系统架构/架构之并发编程/6、并发编程之CAS-Atomic原子操作详情/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Kblayt</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年6月16日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/06/16/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/7%E3%80%81%E5%B9%B6%E5%8F%91%E9%94%81%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/" title="7、并发锁机制之深入理解synchronized">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">7、并发锁机制之深入理解synchronized</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/06/16/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/5%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B/" title="5、并发编程之深入理解Java线程">
                        <span class="hidden-mobile">5、并发编程之深入理解Java线程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
