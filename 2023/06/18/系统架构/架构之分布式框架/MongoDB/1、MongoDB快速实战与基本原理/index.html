

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Kblayt">
  <meta name="keywords" content="">
  
    <meta name="description" content="1.MongoDB介绍1.1 什么是MongoDBMongoDB是一个文档数据库（以 JSON 为数据模型），由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。 文档来自于“JSON Document”，并非我们一般理解的 PDF，WORD 文档。 MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松">
<meta property="og:type" content="article">
<meta property="og:title" content="1、MongoDB快速实战与基本原理">
<meta property="og:url" content="https://kblayt.github.io/2023/06/18/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6/MongoDB/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.MongoDB介绍1.1 什么是MongoDBMongoDB是一个文档数据库（以 JSON 为数据模型），由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。 文档来自于“JSON Document”，并非我们一般理解的 PDF，WORD 文档。 MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35860">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35870">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36232">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/39384">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36243">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35864">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35863">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35861">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35866">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35869">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35865">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35862">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35872">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35868">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36565">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36564">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35871">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36268">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35935">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35937">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36375">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35911">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35929">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36389">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36388">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36464">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36494">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36619">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36608">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36613">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36643">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36708">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36722">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36737">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36751">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36773">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36852">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36966">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36980">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36989">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37180">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37190">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37202">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37213">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37215">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37235">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37009">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37034">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37054">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37056">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37141">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37143">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37146">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/43548">
<meta property="og:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/43547">
<meta property="article:published_time" content="2023-06-18T13:32:34.000Z">
<meta property="article:modified_time" content="2024-01-04T06:09:49.072Z">
<meta property="article:author" content="Kblayt">
<meta property="article:tag" content="MongoDB">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://kblayt.github.io/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35860">
  
  
  
  <title>1、MongoDB快速实战与基本原理 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"kblayt.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="1、MongoDB快速实战与基本原理"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-06-18 21:32" pubdate>
          2023年6月18日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          22k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          182 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">1、MongoDB快速实战与基本原理</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="1-MongoDB介绍"><a href="#1-MongoDB介绍" class="headerlink" title="1.MongoDB介绍"></a><strong>1.MongoDB介绍</strong></h1><h2 id="1-1-什么是MongoDB"><a href="#1-1-什么是MongoDB" class="headerlink" title="1.1 什么是MongoDB"></a><strong>1.1 什么是MongoDB</strong></h2><p>MongoDB是一个文档数据库（以 JSON 为数据模型），由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p>
<p>文档来自于“JSON Document”，并非我们一般理解的 PDF，WORD 文档。</p>
<p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，数据格式是BSON，一种类似JSON的二进制形式的存储格式，简称Binary JSON ，和JSON一样支持内嵌的文档对象和数组对象，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。原则上 Oracle 和 MySQL 能做的事情，MongoDB 都能做（包括 ACID 事务）。</p>
<p>MongoDB是一个开源OLTP数据库，它灵活的文档模型（JSON）非常适合敏捷式开发、高可用和水平扩展的大数据应用。 </p>
<p>OLTP：on-line Transaction Processing，联机(在线)事务处理</p>
<p>OLAP：on-line Analytical Processing，联机(在线)分析处理</p>
<p>MongoDB在数据库总排名第5，仅次于Oracle、MySQL等RDBMS，在NoSQL数据库排名首位。从诞生以来，其项目应用广度、社区活跃指数持续上升。</p>
<p>数据库排名网站：<a target="_blank" rel="noopener" href="https://db-engines.com/en/ranking">https://db-engines.com/en/ranking</a></p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35860" srcset="/img/loading.gif" lazyload alt="0"></p>
<h3 id="MongoDB-版本变迁"><a href="#MongoDB-版本变迁" class="headerlink" title="MongoDB 版本变迁"></a><strong>MongoDB 版本变迁</strong></h3><p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35870" srcset="/img/loading.gif" lazyload alt="0"></p>
<h3 id="MongoDB-vs-关系型数据库"><a href="#MongoDB-vs-关系型数据库" class="headerlink" title="MongoDB vs 关系型数据库"></a><strong>MongoDB vs 关系型数据库</strong></h3><p><strong>概念</strong></p>
<p>MongoDB概念与关系型数据库（RDBMS）非常类似：</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36232" srcset="/img/loading.gif" lazyload alt="0"></p>
<ul>
<li>数据库（database）：最外层的概念，可以理解为逻辑上的名称空间，一个数据库包含多个不同名称的集合。</li>
<li>集合（collection）：相当于SQL中的表，一个集合可以存放多个不同的文档。</li>
<li>文档（document）：一个文档相当于数据表中的一行，由多个不同的字段组成。</li>
<li>字段（field）：文档中的一个属性，等同于列（column）。</li>
<li>索引（index）：独立的检索式数据结构，与SQL概念一致。</li>
<li>_id：每个文档中都拥有一个唯一的_id字段，相当于SQL中的主键（primary key）。</li>
<li>视图（view）：可以看作一种虚拟的（非真实存在的）集合，与SQL中的视图类似。从MongoDB 3.4版本开始提供了视图功能，其通过聚合管道技术实现。</li>
<li>聚合操作（$lookup）：MongoDB用于实现“类似”表连接（tablejoin）的聚合操作符。</li>
</ul>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/39384" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>尽管这些概念大多与SQL标准定义类似，但MongoDB与传统RDBMS仍然存在不少差异，包括：</p>
<ul>
<li>半结构化，在一个集合中，文档所拥有的字段并不需要是相同的，而且也不需要对所用的字段进行声明。因此，MongoDB具有很明显的半结构化特点。除了松散的表结构，文档还可以支持多级的嵌套、数组等灵活的数据类型，非常契合面向对象的编程模型。</li>
<li>弱关系，MongoDB没有外键的约束，也没有非常强大的表连接能力。类似的功能需要使用聚合管道技术来弥补。</li>
</ul>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36243" srcset="/img/loading.gif" lazyload alt="0"></p>
<h2 id="1-2-MongoDB技术优势"><a href="#1-2-MongoDB技术优势" class="headerlink" title="1.2 MongoDB技术优势"></a><strong>1.2 MongoDB技术优势</strong></h2><p>MongoDB基于灵活的JSON文档模型，非常适合敏捷式的快速开发。与此同时，其与生俱来的高可用、高水平扩展能力使得它在处理海量、高并发的数据应用时颇具优势。</p>
<ul>
<li>JSON 结构和对象模型接近，开发代码量低</li>
<li>JSON的动态模型意味着更容易响应新的业务需求</li>
<li>复制集提供99.999%高可用</li>
<li>分片架构支持海量数据和无缝扩容</li>
</ul>
<p><strong>简单直观：从错综复杂的关系模型到一目了然的对象模型</strong></p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35864" srcset="/img/loading.gif" lazyload alt="0"></p>
<p><strong>快速：最简单快速的开发方式</strong></p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35863" srcset="/img/loading.gif" lazyload alt="0"></p>
<p><strong>灵活：快速响应业务变化</strong></p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35861" srcset="/img/loading.gif" lazyload alt="0"></p>
<p><strong>MongoDB优势：原生的高可用</strong></p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35866" srcset="/img/loading.gif" lazyload alt="0"></p>
<p><strong>MongoDB优势：横向扩展能力</strong></p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35869" srcset="/img/loading.gif" lazyload alt="0"></p>
<h2 id="1-3-MongoDB应用场景"><a href="#1-3-MongoDB应用场景" class="headerlink" title="1.3 MongoDB应用场景"></a><strong>1.3 MongoDB应用场景</strong></h2><p>从目前阿里云 MongoDB 云数据库上的用户看，MongoDB 的应用已经渗透到各个领域：</p>
<ul>
<li>游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新；</li>
<li>物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来；</li>
<li>社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能；</li>
<li>物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析；</li>
<li>视频直播，使用 MongoDB 存储用户信息、礼物信息等；</li>
<li>大数据应用，使用云数据库MongoDB作为大数据的云存储系统，随时进行数据提取分析，掌握行业动态。|</li>
</ul>
<p>国内外知名互联网公司都在使用MongoDB：</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35865" srcset="/img/loading.gif" lazyload alt="0"></p>
<h3 id="如何考虑是否选择MongoDB"><a href="#如何考虑是否选择MongoDB" class="headerlink" title="如何考虑是否选择MongoDB?"></a><strong>如何考虑是否选择MongoDB?</strong></h3><p>没有某个业务场景必须要使用MongoDB才能解决，但使用MongoDB通常能让你以更低的成本解决问题。如果你不清楚当前业务是否适合使用MongoDB,可以通过做几道选择题来辅助决策。</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35862" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>只要有一项需求满足就可以考虑使用MongoDB，匹配越多，选择MongoDB越合适。</p>
<h1 id="2-MongoDB快速开始"><a href="#2-MongoDB快速开始" class="headerlink" title="2.MongoDB快速开始"></a><strong>2.MongoDB快速开始</strong></h1><h2 id="2-1-linux安装MongoDB"><a href="#2-1-linux安装MongoDB" class="headerlink" title="2.1 linux安装MongoDB"></a><strong>2.1 linux安装MongoDB</strong></h2><p>环境准备：  </p>
<ul>
<li>linux系统： centos7</li>
<li>安装MongoDB社区版</li>
</ul>
<h3 id="下载MongoDB-Community-Server"><a href="#下载MongoDB-Community-Server" class="headerlink" title="下载MongoDB Community Server"></a><strong>下载MongoDB Community Server</strong></h3><p>下载地址：<a target="_blank" rel="noopener" href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a></p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35872" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>​                #下载MongoDB wget <a target="_blank" rel="noopener" href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.4.9.tgz">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.4.9.tgz</a> tar -zxvf mongodb-linux-x86_64-rhel70-4.4.9.tgz              </p>
<h3 id="启动MongoDB-Server"><a href="#启动MongoDB-Server" class="headerlink" title="启动MongoDB Server"></a><strong>启动MongoDB Server</strong></h3><p>​                #创建dbpath和logpath mkdir -p &#x2F;mongodb&#x2F;data &#x2F;mongodb&#x2F;log   #进入mongodb目录，启动mongodb服务 bin&#x2F;mongod –port&#x3D;27017 –dbpath&#x3D;&#x2F;mongodb&#x2F;data –logpath&#x3D;&#x2F;mongodb&#x2F;log&#x2F;mongodb.log \ –bind_ip&#x3D;0.0.0.0 –fork              </p>
<p>–dbpath :指定数据文件存放目录</p>
<p>–logpath :指定日志文件，注意是指定文件不是目录</p>
<p>–logappend :使用追加的方式记录日志</p>
<p>–port:指定端口，默认为27017</p>
<p>–bind_ip:默认只监听localhost网卡</p>
<p>–fork: 后台启动</p>
<p>–auth: 开启认证模式</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35868" srcset="/img/loading.gif" lazyload alt="0"></p>
<p><strong>添加环境变量</strong></p>
<p>修改&#x2F;etc&#x2F;profile，添加环境变量,方便执行MongoDB命令</p>
<p>​                export MONGODB_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;soft&#x2F;mongodb PATH&#x3D;$PATH:$MONGODB_HOME&#x2F;bin                 </p>
<p>然后执行source &#x2F;etc&#x2F;profile 重新加载环境变量</p>
<p><strong>利用配置文件启动服务</strong></p>
<p>编辑&#x2F;mongodb&#x2F;conf&#x2F;mongo.conf文件，内容如下：</p>
<p>​                systemLog:  destination: file  path: &#x2F;mongodb&#x2F;log&#x2F;mongod.log # log path  logAppend: true storage:  dbPath: &#x2F;mongodb&#x2F;data # data directory  engine: wiredTiger  #存储引擎  journal:            #是否启用journal日志    enabled: true net:  bindIp: 0.0.0.0  port: 27017 # port processManagement:  fork: true              </p>
<p>注意：一定要yaml格式</p>
<p>启动mongod</p>
<p>​                mongod -f &#x2F;mongodb&#x2F;conf&#x2F;mongo.conf              </p>
<p>-f 选项表示将使用配置文件启动mongodb</p>
<h3 id="关闭MongoDB服务"><a href="#关闭MongoDB服务" class="headerlink" title="关闭MongoDB服务"></a><strong>关闭MongoDB服务</strong></h3><p>方式1：</p>
<p>​                mongod –port&#x3D;27017 –dbpath&#x3D;&#x2F;mongodb&#x2F;data –shutdown               </p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36565" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>方式2：</p>
<p>进入mongo shell</p>
<p>​                use admin db.shutdownServer()              </p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36564" srcset="/img/loading.gif" lazyload alt="0"></p>
<h2 id="2-2-Mongo-shell使用"><a href="#2-2-Mongo-shell使用" class="headerlink" title="2.2 Mongo shell使用"></a><strong>2.2 Mongo shell使用</strong></h2><p>mongo是MongoDB的交互式JavaScript Shell界面，它为系统管理员提供了强大的界面，并为开发人员提供了直接测试数据库查询和操作的方法。</p>
<p>​                bin&#x2F;mongo –port&#x3D;27017  bin&#x2F;mongo localhost:27017              </p>
<p>–port:指定端口，默认为27017</p>
<p>–host:连接的主机地址，默认127.0.0.1</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35871" srcset="/img/loading.gif" lazyload alt="0"></p>
<h3 id="JavaScript支持"><a href="#JavaScript支持" class="headerlink" title="JavaScript支持"></a><strong>JavaScript支持</strong></h3><p>mongo shell是基于JavaScript语法的，MongoDB使用了SpiderMonkey作为其内部的JavaScript解释器引擎，这是由Mozilla官方提供的JavaScript内核解释器，该解释器也被同样用于大名鼎鼎的Firefox浏览器产品之中。SpiderMonkey对ECMA Script标准兼容性非常好，可以支持ECMA Script 6。可以通过下面的命令检查JavaScript解释器的版本：</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36268" srcset="/img/loading.gif" lazyload alt="0"></p>
<h3 id="mongo-shell常用命令"><a href="#mongo-shell常用命令" class="headerlink" title="mongo shell常用命令"></a><strong>mongo shell常用命令</strong></h3><table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>show dbs | show databases</td>
<td>显示数据库列表</td>
</tr>
<tr>
<td>use  数据库名</td>
<td>切换数据库，如果不存在创建数据库</td>
</tr>
<tr>
<td>db.dropDatabase()</td>
<td>删除数据库</td>
</tr>
<tr>
<td>show collections | show tables</td>
<td>显示当前数据库的集合列表</td>
</tr>
<tr>
<td>db.集合名.stats()</td>
<td>查看集合详情</td>
</tr>
<tr>
<td>db.集合名.drop()</td>
<td>删除集合</td>
</tr>
<tr>
<td>show users</td>
<td>显示当前数据库的用户列表</td>
</tr>
<tr>
<td>show roles</td>
<td>显示当前数据库的角色列表</td>
</tr>
<tr>
<td>show profile</td>
<td>显示最近发生的操作</td>
</tr>
<tr>
<td>load(“xxx.js”)</td>
<td>执行一个JavaScript脚本文件</td>
</tr>
<tr>
<td>exit  |  quit()</td>
<td>退出当前shell</td>
</tr>
<tr>
<td>help</td>
<td>查看mongodb支持哪些命令</td>
</tr>
<tr>
<td>db.help()</td>
<td>查询当前数据库支持的方法</td>
</tr>
<tr>
<td>db.集合名.help()</td>
<td>显示集合的帮助信息</td>
</tr>
<tr>
<td>db.version()</td>
<td>查看数据库版本</td>
</tr>
</tbody></table>
<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a><strong>数据库操作</strong></h3><p>​                #查看所有库 show dbs # 切换到指定数据库，不存在则创建 use test # 删除当前数据库   db.dropDatabase()              </p>
<h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a><strong>集合操作</strong></h3><p>​                #查看集合 show collections #创建集合 db.createCollection(“emp”) #删除集合 db.emp.drop()              </p>
<p>创建集合语法</p>
<p>​                db.createCollection(name, options)              </p>
<p>options参数</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>capped</td>
<td>布尔</td>
<td>（可选）如果为true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。</td>
</tr>
<tr>
<td>size</td>
<td>数值</td>
<td>（可选）为固定集合指定一个最大值（以字节计）。如果 capped 为 true，也需要指定该字段。</td>
</tr>
<tr>
<td>max</td>
<td>数值</td>
<td>（可选）指定固定集合中包含文档的最大数量。</td>
</tr>
</tbody></table>
<p>注意： 当集合不存在时，向集合中插入文档也会创建集合</p>
<h2 id="2-3-安全认证"><a href="#2-3-安全认证" class="headerlink" title="2.3 安全认证"></a><strong>2.3 安全认证</strong></h2><h3 id="创建管理员账号"><a href="#创建管理员账号" class="headerlink" title="创建管理员账号"></a><strong>创建管理员账号</strong></h3><p>​                # 设置管理员用户名密码需要切换到admin库 use admin   #创建管理员 db.createUser({user:”fox”,pwd:”fox”,roles:[“root”]}) # 查看当前数据库所有用户信息  show users  #显示可设置权限 show roles  #显示所有用户 db.system.users.find()               </p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35935" srcset="/img/loading.gif" lazyload alt="0"></p>
<h3 id="常用权限"><a href="#常用权限" class="headerlink" title="常用权限"></a><strong>常用权限</strong></h3><table>
<thead>
<tr>
<th>权限名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>read</td>
<td>允许用户读取指定数据库</td>
</tr>
<tr>
<td>readWrite</td>
<td>允许用户读写指定数据库</td>
</tr>
<tr>
<td>dbAdmin</td>
<td>允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile</td>
</tr>
<tr>
<td>dbOwner</td>
<td>允许用户在指定数据库中执行任意操作，增、删、改、查等</td>
</tr>
<tr>
<td>userAdmin</td>
<td>允许用户向system.users集合写入，可以在指定数据库里创建、删除和管理用户</td>
</tr>
<tr>
<td>clusterAdmin</td>
<td>只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限</td>
</tr>
<tr>
<td>readAnyDatabase</td>
<td>只在admin数据库中可用，赋予用户所有数据库的读权限</td>
</tr>
<tr>
<td>readWriteAnyDatabase</td>
<td>只在admin数据库中可用，赋予用户所有数据库的读写权限</td>
</tr>
<tr>
<td>userAdminAnyDatabase</td>
<td>只在admin数据库中可用，赋予用户所有数据库的userAdmin权限</td>
</tr>
<tr>
<td>dbAdminAnyDatabase</td>
<td>只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限</td>
</tr>
<tr>
<td>root</td>
<td>只在admin数据库中可用。超级账号，超级权限</td>
</tr>
</tbody></table>
<p>重新赋予用户操作权限</p>
<p>​                db.grantRolesToUser( “fox” , [     { role: “clusterAdmin”, db: “admin” } ,     { role: “userAdminAnyDatabase”, db: “admin”},     { role: “userAdminAnyDatabase”, db: “admin”},     { role: “readWriteAnyDatabase”, db: “admin”}  ])              </p>
<p>删除用户</p>
<p>​                db.dropUser(“fox”) #删除当前数据库所有用户 db.dropAllUser()              </p>
<p>用户认证，返回1表示认证成功</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35937" srcset="/img/loading.gif" lazyload alt="0"></p>
<h3 id="创建应用数据库用户"><a href="#创建应用数据库用户" class="headerlink" title="创建应用数据库用户"></a><strong>创建应用数据库用户</strong></h3><p>​                use appdb db.createUser({user:”appdb”,pwd:”fox”,roles:[“dbOwner”]})              </p>
<p>默认情况下，MongoDB不会启用鉴权，以鉴权模式启动MongoDB</p>
<p>​                mongod -f &#x2F;mongodb&#x2F;conf&#x2F;mongo.conf –auth              </p>
<p>启用鉴权之后，连接MongoDB的相关操作都需要提供身份认证。</p>
<p>​                mongo 192.168.65.174:27017 -u fox -p fox –authenticationDatabase&#x3D;admin              </p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36375" srcset="/img/loading.gif" lazyload alt="0"></p>
<h2 id="2-4-Docker安装"><a href="#2-4-Docker安装" class="headerlink" title="2.4 Docker安装"></a><strong>2.4 Docker安装</strong></h2><p><a target="_blank" rel="noopener" href="https://hub.docker.com/_/mongo?tab=description&amp;page=3">https://hub.docker.com/_/mongo?tab=description&amp;page=3</a></p>
<p>​                #拉取mongo镜像 docker pull mongo:4.4.10 #运行mongo镜像 docker run –name mongo-server -p 29017:27017 \ -e MONGO_INITDB_ROOT_USERNAME&#x3D;fox \ -e MONGO_INITDB_ROOT_PASSWORD&#x3D;fox \ -d mongo:4.4.10 –wiredTigerCacheSizeGB 1              </p>
<p>默认情况下，Mongo会将wiredTigerCacheSizeGB设置为与主机总内存成比例的值，而不考虑你可能对容器施加的内存限制。</p>
<p>MONGO_INITDB_ROOT_USERNAME和MONGO_INITDB_ROOT_PASSWORD都存在就会启用身份认证（mongod –auth）</p>
<p>​                #进入容器 docker exec -it mongo-server  bash #进入Mongo shell mongo -u fox -p fox #创建用户，赋予test库的操作权限 &gt;use test &gt;db.createUser({user:”dcl”,pwd:”123456”,roles:[“readWrite”]})              </p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35911" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>进入mongo shell</p>
<p>​                #远程连接 mongo 192.168.65.97:29017 -u dcl -p 123456              </p>
<p>dcl用户只具备test库的readWrite权限</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/35929" srcset="/img/loading.gif" lazyload alt="0"></p>
<h2 id="2-5-MongoDB工具"><a href="#2-5-MongoDB工具" class="headerlink" title="2.5 MongoDB工具"></a><strong>2.5 MongoDB工具</strong></h2><h3 id="官方GUI工具——COMPASS"><a href="#官方GUI工具——COMPASS" class="headerlink" title="官方GUI工具——COMPASS"></a><strong>官方GUI工具——COMPASS</strong></h3><p>MongoDB图形化管理工具(GUI)，能够帮助您在不需要知道MongoDB查询语法的前提下，便利地分析和理解您的数据库模式,并且帮助您可视化地构建查询。</p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://www.mongodb.com/zh-cn/products/compass">https://www.mongodb.com/zh-cn/products/compass</a></p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36389" srcset="/img/loading.gif" lazyload alt="0"></p>
<h3 id="GUI工具——-Robo-3T（免费）"><a href="#GUI工具——-Robo-3T（免费）" class="headerlink" title="GUI工具—— Robo 3T（免费）"></a><strong>GUI工具—— Robo 3T（免费）</strong></h3><p>下载地址：<a target="_blank" rel="noopener" href="https://robomongo.org/">https://robomongo.org/</a></p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36388" srcset="/img/loading.gif" lazyload alt="0"></p>
<h3 id="GUI工具——Studio-3T（收费，试用30天）"><a href="#GUI工具——Studio-3T（收费，试用30天）" class="headerlink" title="GUI工具——Studio 3T（收费，试用30天）"></a><strong>GUI工具——Studio 3T（收费，试用30天）</strong></h3><p>下载地址：<a target="_blank" rel="noopener" href="https://studio3t.com/download/">https://studio3t.com/download/</a></p>
<h3 id="MongoDB-Database-Tools"><a href="#MongoDB-Database-Tools" class="headerlink" title="MongoDB Database Tools"></a><strong>MongoDB Database Tools</strong></h3><p>下载地址：<a target="_blank" rel="noopener" href="https://www.mongodb.com/try/download/database-tools">https://www.mongodb.com/try/download/database-tools</a></p>
<table>
<thead>
<tr>
<th>文件名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>mongostat</td>
<td>数据库性能监控工具</td>
</tr>
<tr>
<td>mongotop</td>
<td>热点表监控工具</td>
</tr>
<tr>
<td>mongodump</td>
<td>数据库逻辑备份工具</td>
</tr>
<tr>
<td>mongorestore</td>
<td>数据库逻辑恢复工具</td>
</tr>
<tr>
<td>mongoexport</td>
<td>数据导出工具</td>
</tr>
<tr>
<td>mongoimport</td>
<td>数据导入工具</td>
</tr>
<tr>
<td>bsondump</td>
<td>BSON格式转换工具</td>
</tr>
<tr>
<td>mongofiles</td>
<td>GridFS文件工具</td>
</tr>
</tbody></table>
<h1 id="3-MongoDB文档操作"><a href="#3-MongoDB文档操作" class="headerlink" title="3. MongoDB文档操作"></a><strong>3. MongoDB文档操作</strong></h1><h2 id="3-1-插入文档"><a href="#3-1-插入文档" class="headerlink" title="3.1 插入文档"></a><strong>3.1 插入文档</strong></h2><p>3.2 版本之后新增了 db.collection.insertOne() 和 db.collection.insertMany()。</p>
<h3 id="新增单个文档"><a href="#新增单个文档" class="headerlink" title="新增单个文档"></a><strong>新增单个文档</strong></h3><ul>
<li>insertOne: 支持writeConcern</li>
</ul>
<p>​                db.collection.insertOne(   <document>,   {      writeConcern: <document>   } )              </p>
<p>writeConcern 决定一个写操作落到多少个节点上才算成功。writeConcern 的取值包括： </p>
<p>0：发起写操作，不关心是否成功； </p>
<p>1~集群最大数据节点数：写操作需要被复制到指定节点数才算成功； </p>
<p>majority：写操作需要被复制到大多数节点上才算成功。</p>
<ul>
<li>insert: 若插入的数据主键已经存在，则会抛 DuplicateKeyException 异常，提示主键重复，不保存当前数据。</li>
<li>save: 如果 _id 主键存在则更新数据，如果不存在就插入数据。</li>
</ul>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36464" srcset="/img/loading.gif" lazyload alt="0"></p>
<h3 id="批量新增文档"><a href="#批量新增文档" class="headerlink" title="批量新增文档"></a><strong>批量新增文档</strong></h3><ul>
<li>insertMany:向指定集合中插入多条文档数据</li>
</ul>
<p>​                db.collection.insertMany(   [ &lt;document 1&gt; , &lt;document 2&gt;, … ],   {      writeConcern: <document>,      ordered: <boolean>         } )              </p>
<p>writeConcern：写入策略，默认为 1，即要求确认写操作，0 是不要求。</p>
<p>ordered：指定是否按顺序写入，默认 true，按顺序写入。</p>
<ul>
<li>insert和save也可以实现批量插入</li>
</ul>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36494" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>测试：批量插入50条随机数据</p>
<p>编辑脚本book.js</p>
<p>​                var tags &#x3D; [“nosql”,”mongodb”,”document”,”developer”,”popular”]; var types &#x3D; [“technology”,”sociality”,”travel”,”novel”,”literature”]; var books&#x3D;[]; for(var i&#x3D;0;i&lt;50;i++){    var typeIdx &#x3D; Math.floor(Math.random()*types.length);    var tagIdx &#x3D; Math.floor(Math.random()*tags.length);    var favCount &#x3D; Math.floor(Math.random()*100);    var book &#x3D; {        title: “book-“+i,        type: types[typeIdx],        tag: tags[tagIdx],        favCount: favCount,        author: “xxx”+i    };    books.push(book) } db.books.insertMany(books);               </p>
<p>进入mongo shell，执行</p>
<p>​                load(“books.js”)              </p>
<h2 id="3-2-查询文档"><a href="#3-2-查询文档" class="headerlink" title="3.2 查询文档"></a><strong>3.2 查询文档</strong></h2><p>find 查询集合中的若干文档。语法格式如下：</p>
<p>​                db.collection.find(query, projection)              </p>
<ul>
<li><strong>query</strong> ：可选，使用查询操作符指定查询条件</li>
<li><strong>projection</strong> ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。投影时，_id为1的时候，其他字段必须是1；_id是0的时候，其他字段可以是0；如果没有_id字段约束，多个其他字段必须同为0或同为1。</li>
</ul>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36619" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>如果查询返回的条目数量较多，mongo shell则会自动实现分批显示。默认情况下每次只显示20条，可以输入it命令读取下一批。</p>
<p>findOne查询集合中的第一个文档。语法格式如下：</p>
<p>​                db.collection.findOne(query, projection)              </p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36608" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>如果你需要以易读的方式来读取数据，可以使用pretty)方法，语法格式如下:</p>
<p>​                db.collection.find().pretty()              </p>
<p>注意：pretty()方法以格式化的方式来显示所有文档</p>
<p><strong>条件查询</strong></p>
<p><strong>指定条件查询</strong></p>
<p>​                #查询带有nosql标签的book文档： db.books.find({tag:”nosql”}) #按照id查询单个book文档： db.books.find({_id:ObjectId(“61caa09ee0782536660494d9”)}) #查询分类为“travel”、收藏数超过60个的book文档： db.books.find({type:”travel”,favCount:{$gt:60}})              </p>
<p><strong>查询条件对照表</strong></p>
<table>
<thead>
<tr>
<th>SQL</th>
<th>MQL</th>
</tr>
</thead>
<tbody><tr>
<td>a &#x3D; 1</td>
<td>{a: 1}</td>
</tr>
<tr>
<td>a &lt;&gt; 1</td>
<td>{a: {$ne: 1}}</td>
</tr>
<tr>
<td>a &gt; 1</td>
<td>{a: {$gt: 1}}</td>
</tr>
<tr>
<td>a &gt;&#x3D; 1</td>
<td>{a: {$gte: 1}}</td>
</tr>
<tr>
<td>a &lt; 1</td>
<td>{a: {$lt: 1}}</td>
</tr>
<tr>
<td>a &lt;&#x3D; 1</td>
<td>{a: {$lte: 1}}</td>
</tr>
</tbody></table>
<p><strong>查询逻辑对照表</strong></p>
<table>
<thead>
<tr>
<th>SQL</th>
<th>MQL</th>
</tr>
</thead>
<tbody><tr>
<td>a &#x3D; 1 AND b &#x3D; 1</td>
<td>{a: 1, b: 1}或{$and: [{a: 1}, {b: 1}]}</td>
</tr>
<tr>
<td>a &#x3D; 1 OR b &#x3D; 1</td>
<td>{$or: [{a: 1}, {b: 1}]}</td>
</tr>
<tr>
<td>a IS NULL</td>
<td>{a: {$exists: false}}</td>
</tr>
<tr>
<td>a IN (1, 2, 3)</td>
<td>{a: {$in: [1, 2, 3]}}</td>
</tr>
</tbody></table>
<p><strong>查询逻辑运算符</strong></p>
<ul>
<li>$lt: 存在并小于</li>
<li>$lte: 存在并小于等于</li>
<li>$gt: 存在并大于</li>
<li>$gte: 存在并大于等于</li>
<li>$ne: 不存在或存在但不等于</li>
<li>$in: 存在并在指定数组中</li>
<li>$nin: 不存在或不在指定数组中</li>
<li>$or: 匹配两个或多个条件中的一个</li>
<li>$and: 匹配全部条件</li>
</ul>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36613" srcset="/img/loading.gif" lazyload alt="0"></p>
<h3 id="排序-amp-分页"><a href="#排序-amp-分页" class="headerlink" title="排序&amp;分页"></a><strong>排序&amp;分页</strong></h3><p><strong>指定排序</strong></p>
<p>在 MongoDB 中使用 sort() 方法对数据进行排序</p>
<p>​                #指定按收藏数（favCount）降序返回 db.books.find({type:”travel”}).sort({favCount:-1})              </p>
<ul>
<li>1 为升序排列，而 -1 是用于降序排列</li>
</ul>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36643" srcset="/img/loading.gif" lazyload alt="0"></p>
<p><strong>分页查询</strong></p>
<p>skip用于指定跳过记录数，limit则用于限定返回结果数量。可以在执行find命令的同时指定skip、limit参数，以此实现分页的功能。比如，假定每页大小为8条，查询第3页的book文档：</p>
<p>​                db.books.find().skip(8).limit(4)              </p>
<p><strong>处理分页问题 – 巧分页</strong> </p>
<p>数据量大的时候，应该避免使用skip&#x2F;limit形式的分页。</p>
<p>替代方案：<strong>使用查询条件+唯一排序条件；</strong></p>
<p>例如： </p>
<p>第一页：db.posts.find({}).sort({_id: 1}).limit(20); </p>
<p>第二页：db.posts.find({_id: {$gt: &lt;第一页最后一个_id&gt;}}).sort({_id: 1}).limit(20); </p>
<p>第三页：db.posts.find({_id: {$gt: &lt;第二页最后一个_id&gt;}}).sort({_id: 1}).limit(20);</p>
<p><strong>处理分页问题 – 避免使用 count</strong> </p>
<p>尽可能不要计算总页数，特别是数据量大和查询条件不能完整命中索引时。 </p>
<p>考虑以下场景：假设集合总共有 1000w 条数据，在没有索引的情况下考虑以下查询：</p>
<p>​                db.coll.find({x: 100}).limit(50); db.coll.count({x: 100});               </p>
<ul>
<li>前者只需要遍历前 n 条，直到找到 50 条 x&#x3D;100 的文档即可结束； </li>
<li>后者需要遍历完 1000w 条找到所有符合要求的文档才能得到结果。 为了计算总页数而进行的 count() 往往是拖慢页面整体加载速度的原因</li>
</ul>
<h3 id="正则表达式匹配查询"><a href="#正则表达式匹配查询" class="headerlink" title="正则表达式匹配查询"></a><strong>正则表达式匹配查询</strong></h3><p>MongoDB 使用 $regex 操作符来设置匹配字符串的正则表达式。</p>
<p>​                &#x2F;&#x2F;使用正则表达式查找type包含 so 字符串的book db.books.find({type:{$regex:”so”}}) &#x2F;&#x2F;或者 db.books.find({type:&#x2F;so&#x2F;})              </p>
<h2 id="3-3-更新文档"><a href="#3-3-更新文档" class="headerlink" title="3.3 更新文档"></a><strong>3.3 更新文档</strong></h2><p>可以用update命令对指定的数据进行更新，命令的格式如下：</p>
<p>​                db.collection.update(query,update,options)              </p>
<ul>
<li><p>query：描述更新的查询条件；</p>
</li>
<li><p>update：描述更新的动作及新的内容；</p>
</li>
<li><p>options：描述更新的选项</p>
</li>
<li><ul>
<li>upsert:  可选，如果不存在update的记录，是否插入新的记录。默认false，不插入</li>
<li>multi: 可选，是否按条件查询出的多条记录全部更新。 默认false,只更新找到的第一条记录</li>
<li>writeConcern :可选，决定一个写操作落到多少个节点上才算成功。</li>
</ul>
</li>
</ul>
<h3 id="更新操作符"><a href="#更新操作符" class="headerlink" title="更新操作符"></a><strong>更新操作符</strong></h3><table>
<thead>
<tr>
<th><strong>操作符</strong></th>
<th><strong>格式</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>$set</td>
<td>{$set:{field:value}}</td>
<td>指定一个键并更新值，若键不存在则创建</td>
</tr>
<tr>
<td>$unset</td>
<td>{$unset : {field : 1 }}</td>
<td>删除一个键</td>
</tr>
<tr>
<td>$inc</td>
<td>{$inc : {field : value } }</td>
<td>对数值类型进行增减</td>
</tr>
<tr>
<td>$rename</td>
<td>{$rename : {old_field_name : new_field_name } }</td>
<td>修改字段名称</td>
</tr>
<tr>
<td>$push</td>
<td>{ $push : {field : value } }</td>
<td>将数值追加到数组中，若数组不存在则会进行初始化</td>
</tr>
<tr>
<td>$pushAll</td>
<td>{$pushAll : {field : value_array }}</td>
<td>追加多个值到一个数组字段内</td>
</tr>
<tr>
<td>$pull</td>
<td>{$pull : {field : _value } }</td>
<td>从数组中删除指定的元素</td>
</tr>
<tr>
<td>$addToSet</td>
<td>{$addToSet : {field : value } }</td>
<td>添加元素到数组中，具有排重功能</td>
</tr>
<tr>
<td>$pop</td>
<td>{$pop : {field : 1 }}</td>
<td>删除数组的第一个或最后一个元素</td>
</tr>
</tbody></table>
<p><strong>更新单个文档</strong></p>
<p>某个book文档被收藏了，则需要将该文档的favCount字段自增</p>
<p>​                db.books.update({_id:ObjectId(“61caa09ee0782536660494d9”)},{$inc:{favCount:1}})              </p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36708" srcset="/img/loading.gif" lazyload alt="0"></p>
<p><strong>更新多个文档</strong></p>
<p>默认情况下，update命令只在更新第一个文档之后返回，如果需要更新多个文档，则可以使用multi选项。</p>
<p>将分类为“novel”的文档的增加发布时间（publishedDate）</p>
<p>​                db.books.update({type:”novel”},{$set:{publishedDate:new Date()}},{“multi”:true})              </p>
<p>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36722" srcset="/img/loading.gif" lazyload alt="0"></p>
<h3 id="update命令的选项配置较多，为了简化使用还可以使用一些快捷命令"><a href="#update命令的选项配置较多，为了简化使用还可以使用一些快捷命令" class="headerlink" title="update命令的选项配置较多，为了简化使用还可以使用一些快捷命令:"></a><strong>update命令的选项配置较多，为了简化使用还可以使用一些快捷命令:</strong></h3><ul>
<li>updateOne：更新单个文档。</li>
<li>updateMany：更新多个文档。</li>
<li>replaceOne：替换单个文档。</li>
</ul>
<h3 id="使用upsert命令"><a href="#使用upsert命令" class="headerlink" title="使用upsert命令"></a><strong>使用upsert命令</strong></h3><p>upsert是一种特殊的更新，其表现为如果目标文档不存在，则执行插入命令。</p>
<p>​                db.books.update(    {title:”my book”},    {$set:{tags:[“nosql”,”mongodb”],type:”none”,author:”fox”}},    {upsert:true} )              </p>
<p>nMatched、nModified都为0，表示没有文档被匹配及更新，nUpserted&#x3D;1提示执行了upsert动作</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36737" srcset="/img/loading.gif" lazyload alt="0"></p>
<h3 id="实现replace语义"><a href="#实现replace语义" class="headerlink" title="实现replace语义"></a><strong>实现replace语义</strong></h3><p>update命令中的更新描述（update）通常由操作符描述，如果更新描述中不包含任何操作符，那么MongoDB会实现文档的replace语义</p>
<p>​                db.books.update(    {title:”my book”},    {justTitle:”my first book”} )                  </p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36751" srcset="/img/loading.gif" lazyload alt="0"></p>
<h3 id="findAndModify命令"><a href="#findAndModify命令" class="headerlink" title="findAndModify命令"></a><strong>findAndModify命令</strong></h3><p>findAndModify兼容了查询和修改指定文档的功能，findAndModify只能更新单个文档</p>
<p>​                &#x2F;&#x2F;将某个book文档的收藏数（favCount）加1 db.books.findAndModify({    query:{_id:ObjectId(“61caa09ee0782536660494dd”)},    update:{$inc:{favCount:1}} })              </p>
<p>该操作会返回符合查询条件的文档数据，并完成对文档的修改。</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36773" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>默认情况下，findAndModify会返回修改前的“旧”数据。如果希望返回修改后的数据，则可以指定new选项</p>
<p>​                db.books.findAndModify({    query:{_id:ObjectId(“61caa09ee0782536660494dd”)},    update:{$inc:{favCount:1}},    new: true })              </p>
<p>与findAndModify语义相近的命令如下：</p>
<ul>
<li>findOneAndUpdate：更新单个文档并返回更新前（或更新后）的文档。</li>
<li>findOneAndReplace：替换单个文档并返回替换前（或替换后）的文档。</li>
</ul>
<h2 id="3-4-删除文档"><a href="#3-4-删除文档" class="headerlink" title="3.4 删除文档"></a><strong>3.4 删除文档</strong></h2><h3 id="使用-remove-删除文档"><a href="#使用-remove-删除文档" class="headerlink" title="使用 remove 删除文档"></a><strong>使用 remove 删除文档</strong></h3><ul>
<li>remove 命令需要配合查询条件使用；</li>
<li>匹配查询条件的文档会被删除；</li>
<li>指定一个空文档条件会删除所有文档；</li>
</ul>
<p>示例：</p>
<p>​                db.user.remove({age:28})&#x2F;&#x2F; 删除age 等于28的记录 db.user.remove({age:{$lt:25}})   &#x2F;&#x2F; 删除age 小于25的记录 db.user.remove( { } ) &#x2F;&#x2F; 删除所有记录 db.user.remove() &#x2F;&#x2F;报错              </p>
<p>remove命令会删除匹配条件的全部文档，如果希望明确限定只删除一个文档，则需要指定justOne参数，命令格式如下：</p>
<p>​                db.collection.remove(query,justOne)              </p>
<p>例如：删除满足type:novel条件的首条记录</p>
<p>​                db.books.remove({type:”novel”},true)              </p>
<h3 id="使用-delete-删除文档"><a href="#使用-delete-删除文档" class="headerlink" title="使用 delete 删除文档"></a><strong>使用 delete 删除文档</strong></h3><p>官方推荐使用 deleteOne() 和 deleteMany() 方法删除文档，语法格式如下：</p>
<p>​                db.books.deleteMany ({})  &#x2F;&#x2F;删除集合下全部文档 db.books.deleteMany ({ type:”novel” })  &#x2F;&#x2F;删除 type等于 novel 的全部文档 db.books.deleteOne ({ type:”novel” })  &#x2F;&#x2F;删除 type等于novel 的一个文档              </p>
<p>注意： remove、deleteMany等命令需要对查询范围内的文档逐个删除，如果希望删除整个集合，则使用drop命令会更加高效</p>
<h3 id="返回被删除文档"><a href="#返回被删除文档" class="headerlink" title="返回被删除文档"></a><strong>返回被删除文档</strong></h3><p>remove、deleteOne等命令在删除文档后只会返回确认性的信息，如果希望获得被删除的文档，则可以使用findOneAndDelete命令</p>
<p>​                db.books.findOneAndDelete({type:”novel”})              </p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36852" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>除了在结果中返回删除文档，findOneAndDelete命令还允许定义“删除的顺序”，即按照指定顺序删除找到的第一个文档</p>
<p>​                db.books.findOneAndDelete({type:”novel”},{sort:{favCount:1}})              </p>
<p>remove、deleteOne等命令只能按默认顺序删除，利用这个特性，findOneAndDelete可以实现队列的先进先出。</p>
<p><strong>文档操作最佳实践</strong></p>
<p>关于文档结构 </p>
<ul>
<li>防止使用太长的字段名（浪费空间）</li>
<li>防止使用太深的数组嵌套（超过2层操作比较复杂）</li>
<li>不使用中文，标点符号等非拉丁字母作为字段名</li>
</ul>
<p>关于写操作</p>
<ul>
<li>update 语句里只包括需要更新的字段 </li>
<li>尽可能使用批量插入来提升写入性能 </li>
<li>使用TTL自动过期日志类型的数据</li>
</ul>
<h1 id="4-MongoDB数据模型"><a href="#4-MongoDB数据模型" class="headerlink" title="4. MongoDB数据模型"></a><strong>4. MongoDB数据模型</strong></h1><p>思考：MongoDB为什么会使用BSON？</p>
<h2 id="4-1-BSON协议与数据类型"><a href="#4-1-BSON协议与数据类型" class="headerlink" title="4.1 BSON协议与数据类型"></a><strong>4.1 BSON协议与数据类型</strong></h2><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a><strong>JSON</strong></h3><p>JSON是当今非常通用的一种跨语言Web数据交互格式，属于ECMAScript标准规范的一个子集。JSON（JavaScript Object Notation, JS对象简谱）即JavaScript对象表示法，它是JavaScript对象的一种文本表现形式。</p>
<p>作为一种轻量级的数据交换格式，JSON的可读性非常好，而且非常便于系统生成和解析，这些优势也让它逐渐取代了XML标准在Web领域的地位，当今许多流行的Web应用开发框架，如SpringBoot都选择了JSON作为默认的数据编&#x2F;解码格式。</p>
<p>JSON只定义了6种数据类型： </p>
<ul>
<li>string:  字符串</li>
<li>number :  数值</li>
<li>object:  JS的对象形式，用{key:value}表示，可嵌套</li>
<li>array:  数组，JS的表示方式[value]，可嵌套</li>
<li>true&#x2F;false:  布尔类型</li>
<li>null:  空值</li>
</ul>
<p>大多数情况下，使用JSON作为数据交互格式已经是理想的选择，但是JSON基于文本的解析效率并不是最好的，在某些场景下往往会考虑选择更合适的编&#x2F;解码格式，一些做法如：</p>
<ul>
<li>在微服务架构中，使用gRPC（基于Google的Protobuf）可以获得更好的网络利用率。</li>
<li>分布式中间件、数据库，使用私有定制的TCP数据包格式来提供高性能、低延时的计算能力。</li>
</ul>
<h3 id="BSON"><a href="#BSON" class="headerlink" title="BSON"></a><strong>BSON</strong></h3><p>BSON由10gen团队设计并开源，目前主要用于MongoDB数据库。BSON（Binary JSON）是二进制版本的JSON，其在性能方面有更优的表现。BSON在许多方面和JSON保持一致，其同样也支持内嵌的文档对象和数组结构。二者最大的区别在于JSON是基于文本的，而BSON则是二进制（字节流）编&#x2F;解码的形式。在空间的使用上，BSON相比JSON并没有明显的优势。</p>
<p>MongoDB在文档存储、命令协议上都采用了BSON作为编&#x2F;解码格式，主要具有如下优势：</p>
<ul>
<li>类JSON的轻量级语义，支持简单清晰的嵌套、数组层次结构，可以实现模式灵活的文档结构。</li>
<li>更高效的遍历，BSON在编码时会记录每个元素的长度，可以直接通过seek操作进行元素的内容读取，相对JSON解析来说，遍历速度更快。</li>
<li>更丰富的数据类型，除了JSON的基本数据类型，BSON还提供了MongoDB所需的一些扩展类型，比如日期、二进制数据等，这更加方便数据的表示和操作。</li>
</ul>
<p><strong>BSON的数据类型</strong></p>
<p>MongoDB中，一个BSON文档最大大小为16M，文档嵌套的级别不超过100</p>
<p><a target="_blank" rel="noopener" href="https://docs.mongodb.com/v4.4/reference/bson-types/">https://docs.mongodb.com/v4.4/reference/bson-types/</a></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Number</th>
<th>Alias</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>Double</td>
<td>1</td>
<td>“double”</td>
<td></td>
</tr>
<tr>
<td>String</td>
<td>2</td>
<td>“string”</td>
<td></td>
</tr>
<tr>
<td>Object</td>
<td>3</td>
<td>“object”</td>
<td></td>
</tr>
<tr>
<td>Array</td>
<td>4</td>
<td>“array”</td>
<td></td>
</tr>
<tr>
<td>Binary data</td>
<td>5</td>
<td>“binData”</td>
<td>二进制数据</td>
</tr>
<tr>
<td>Undefined</td>
<td>6</td>
<td>“undefined”</td>
<td>Deprecated.</td>
</tr>
<tr>
<td>ObjectId</td>
<td>7</td>
<td>“objectId”</td>
<td>对象ID，用于创建文档ID</td>
</tr>
<tr>
<td>Boolean</td>
<td>8</td>
<td>“bool”</td>
<td></td>
</tr>
<tr>
<td>Date</td>
<td>9</td>
<td>“date”</td>
<td></td>
</tr>
<tr>
<td>Null</td>
<td>10</td>
<td>“null”</td>
<td></td>
</tr>
<tr>
<td>Regular Expression</td>
<td>11</td>
<td>“regex”</td>
<td>正则表达式</td>
</tr>
<tr>
<td>DBPointer</td>
<td>12</td>
<td>“dbPointer”</td>
<td>Deprecated.</td>
</tr>
<tr>
<td>JavaScript</td>
<td>13</td>
<td>“javascript”</td>
<td></td>
</tr>
<tr>
<td>Symbol</td>
<td>14</td>
<td>“symbol”</td>
<td>Deprecated.</td>
</tr>
<tr>
<td>JavaScript code with scope</td>
<td>15</td>
<td>“javascriptWithScope”</td>
<td>Deprecated in MongoDB 4.4.</td>
</tr>
<tr>
<td>32-bit integer</td>
<td>16</td>
<td>“int”</td>
<td></td>
</tr>
<tr>
<td>Timestamp</td>
<td>17</td>
<td>“timestamp”</td>
<td></td>
</tr>
<tr>
<td>64-bit integer</td>
<td>18</td>
<td>“long”</td>
<td></td>
</tr>
<tr>
<td>Decimal128</td>
<td>19</td>
<td>“decimal”</td>
<td>New in version 3.4.</td>
</tr>
<tr>
<td>Min key</td>
<td>-1</td>
<td>“minKey”</td>
<td>表示一个最小值</td>
</tr>
<tr>
<td>Max key</td>
<td>127</td>
<td>“maxKey”</td>
<td>表示一个最大值</td>
</tr>
</tbody></table>
<p><strong>$type操作符</strong></p>
<p>$type操作符基于BSON类型来检索集合中匹配的数据类型，并返回结果。</p>
<p>​                db.books.find({“title” : {$type : 2}}) &#x2F;&#x2F;或者 db.books.find({“title” : {$type : “string”}})              </p>
<h2 id="4-2-日期类型"><a href="#4-2-日期类型" class="headerlink" title="4.2 日期类型"></a><strong>4.2 日期类型</strong></h2><p>MongoDB的日期类型使用UTC（Coordinated Universal Time）进行存储，也就是+0时区的时间。</p>
<p>​                db.dates.insert([{data1:Date()},{data2:new Date()},{data3:ISODate()}]) db.dates.find().pretty()              </p>
<p>使用new Date与ISODate最终都会生成ISODate类型的字段（对应于UTC时间）</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36966" srcset="/img/loading.gif" lazyload alt="0"></p>
<h2 id="4-3-ObjectId生成器"><a href="#4-3-ObjectId生成器" class="headerlink" title="4.3 ObjectId生成器"></a><strong>4.3 ObjectId生成器</strong></h2><p>MongoDB集合中所有的文档都有一个唯一的_id字段，作为集合的主键。在默认情况下，_id字段使用ObjectId类型，采用16进制编码形式，共12个字节。</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36980" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>为了避免文档的_id字段出现重复，ObjectId被定义为3个部分：</p>
<ul>
<li>4字节表示Unix时间戳（秒）。</li>
<li>5字节表示随机数（机器号+进程号唯一）。 </li>
<li>3字节表示计数器（初始化时随机）。</li>
</ul>
<p>大多数客户端驱动都会自行生成这个字段，比如MongoDB Java Driver会根据插入的文档是否包含_id字段来自动补充ObjectId对象。这样做不但提高了离散性，还可以降低MongoDB服务器端的计算压力。在ObjectId的组成中，5字节的随机数并没有明确定义，客户端可以采用机器号、进程号来实现：</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/36989" srcset="/img/loading.gif" lazyload alt="0"></p>
<table>
<thead>
<tr>
<th>属性&#x2F;方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>str</td>
<td>返回对象的十六进制字符串表示。</td>
</tr>
<tr>
<td>ObjectId.getTimestamp()</td>
<td>将对象的时间戳部分作为日期返回。</td>
</tr>
<tr>
<td>ObjectId.toString()</td>
<td>以字符串文字“”的形式返回 JavaScript 表示ObjectId(…)。</td>
</tr>
<tr>
<td>ObjectId.valueOf()</td>
<td>将对象的表示形式返回为十六进制字符串。返回的字符串是str属性。</td>
</tr>
</tbody></table>
<p>生成一个新的 ObjectId</p>
<p>​                x &#x3D; ObjectId()              </p>
<h2 id="4-4-内嵌文档和数组"><a href="#4-4-内嵌文档和数组" class="headerlink" title="4.4 内嵌文档和数组"></a><strong>4.4 内嵌文档和数组</strong></h2><h3 id="内嵌文档"><a href="#内嵌文档" class="headerlink" title="内嵌文档"></a><strong>内嵌文档</strong></h3><p>一个文档中可以包含作者的信息，包括作者名称、性别、家乡所在地，一个显著的优点是，当我们查询book文档的信息时，作者的信息也会一并返回。</p>
<p>​                db.books.insert({    title: “撒哈拉的故事”,    author: {        name:”三毛”,        gender:”女”,        hometown:”重庆”    } })              </p>
<p>查询三毛的作品</p>
<p>​                db.books.find({“author.name”:”三毛”})              </p>
<p>修改三毛的家乡所在地</p>
<p>​                db.books.updateOne({“author.name”:”三毛”},{$set:{“author.hometown”:”重庆&#x2F;台湾”}})              </p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h3><p>除了作者信息，文档中还包含了若干个标签，这些标签可以用来表示文档所包含的一些特征，如豆瓣读书中的标签（tag）</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37180" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>增加tags标签</p>
<p>​                db.books.updateOne({“author.name”:”三毛”},{$set:{tags:[“旅行”,”随笔”,”散文”,”爱情”,”文学”]}})              </p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37190" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>查询数组元素</p>
<p>​                # 会查询到所有的tags db.books.find({“author.name”:”三毛”},{title:1,tags:1}) #利用$slice获取最后一个tag db.books.find({“author.name”:”三毛”},{title:1,tags:{$slice:-1}})              </p>
<p>$silice是一个查询操作符，用于指定数组的切片方式</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37202" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>数组末尾追加元素，可以使用$push操作符</p>
<p>​                db.books.updateOne({“author.name”:”三毛”},{$push:{tags:”猎奇”}})              </p>
<p>$push操作符可以配合其他操作符，一起实现不同的数组修改操作，比如和$each操作符配合可以用于添加多个元素</p>
<p>​                db.books.updateOne({“author.name”:”三毛”},{$push:{tags:{$each:[“伤感”,”想象力”]}}})              </p>
<p>如果加上$slice操作符，那么只会保留经过切片后的元素</p>
<p>​                db.books.updateOne({“author.name”:”三毛”},{$push:{tags:{$each:[“伤感”,”想象力”],$slice:-3}}})              </p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37213" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>根据元素查询</p>
<p>​                #会查出所有包含伤感的文档 db.books.find({tags:”伤感”}) # 会查出所有同时包含”伤感”,”想象力”的文档 db.books.find({tags:{$all:[“伤感”,”想象力”]}})              </p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37215" srcset="/img/loading.gif" lazyload alt="0"></p>
<h3 id="嵌套型的数组"><a href="#嵌套型的数组" class="headerlink" title="嵌套型的数组"></a><strong>嵌套型的数组</strong></h3><p>数组元素可以是基本类型，也可以是内嵌的文档结构</p>
<p>​                {    tags:[        {tagKey:xxx,tagValue:xxxx},        {tagKey:xxx,tagValue:xxxx}    ] }              </p>
<p>这种结构非常灵活，一个很适合的场景就是商品的多属性表示</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37235" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>一个商品可以同时包含多个维度的属性，比如尺码、颜色、风格等，使用文档可以表示为：</p>
<p>​                db.goods.insertMany([{    name:”羽绒服”,    tags:[        {tagKey:”size”,tagValue:[“M”,”L”,”XL”,”XXL”,”XXXL”]},        {tagKey:”color”,tagValue:[“黑色”,”宝蓝”]},        {tagKey:”style”,tagValue:”韩风”}    ] },{    name:”羊毛衫”,    tags:[        {tagKey:”size”,tagValue:[“L”,”XL”,”XXL”]},        {tagKey:”color”,tagValue:[“蓝色”,”杏色”]},        {tagKey:”style”,tagValue:”韩风”}    ] }])              </p>
<p>以上的设计是一种常见的多值属性的做法，当我们需要根据属性进行检索时，需要用到$elementMatch操作符：</p>
<p>​                #筛选出color&#x3D;黑色的商品信息 db.goods.find({    tags:{        $elemMatch:{tagKey:”color”,tagValue:”黑色”}    } })              </p>
<p>如果进行组合式的条件检索，则可以使用多个$elemMatch操作符：</p>
<p>​                # 筛选出color&#x3D;蓝色，并且size&#x3D;XL的商品信息 db.goods.find({    tags:{        $all:[            {$elemMatch:{tagKey:”color”,tagValue:”黑色”}},            {$elemMatch:{tagKey:”size”,tagValue:”XL”}}        ]      } })              </p>
<h2 id="4-5-固定集合"><a href="#4-5-固定集合" class="headerlink" title="4.5 固定集合"></a><strong>4.5 固定集合</strong></h2><p>固定集合（capped collection）是一种限定大小的集合，其中capped是覆盖、限额的意思。跟普通的集合相比，数据在写入这种集合时遵循FIFO原则。可以将这种集合想象为一个环状的队列，新文档在写入时会被插入队列的末尾，如果队列已满，那么之前的文档就会被新写入的文档所覆盖。通过固定集合的大小，我们可以保证数据库只会存储“限额”的数据，超过该限额的旧数据都会被丢弃。</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37009" srcset="/img/loading.gif" lazyload alt="0"></p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a><strong>使用示例</strong></h3><p><strong>创建固定集合</strong></p>
<p>​                db.createCollection(“logs”,{capped:true,size:4096,max:10})              </p>
<ul>
<li>max：指集合的文档数量最大值，这里是10条</li>
<li>size：指集合的空间占用最大值，这里是4096字节（4KB）</li>
</ul>
<p>这两个参数会同时对集合的上限产生影响。也就是说，只要任一条件达到阈值都会认为集合已经写满。其中size是必选的，而max则是可选的。</p>
<p>可以使用collection.stats命令查看文档的占用空间</p>
<p>​                db.logs.stats()              </p>
<p><strong>测试</strong></p>
<p>尝试在这个集合中插入15条数据，再查询会发现，由于文档数量上限被设定为10条，前面插入的5条数据已经被覆盖了</p>
<p>​                for(var i&#x3D;0;i&lt;15;i++){    db.logs.insert({t:”row-“+i}) }              </p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37034" srcset="/img/loading.gif" lazyload alt="0"></p>
<h3 id="优势与限制"><a href="#优势与限制" class="headerlink" title="优势与限制"></a><strong>优势与限制</strong></h3><p>固定集合在底层使用的是顺序I&#x2F;O操作，而普通集合使用的是随机I&#x2F;O。顺序I&#x2F;O在磁盘操作上由于寻道次数少而比随机I&#x2F;O要高效得多，因此固定集合的写入性能是很高的。此外，如果按写入顺序进行数据读取，也会获得非常好的性能表现。</p>
<p>但它也存在一些限制，主要有如下5个方面：</p>
<ol>
<li>无法动态修改存储的上限，如果需要修改max或size，则只能先执行collection.drop命令，将集合删除后再重新创建。</li>
<li>无法删除已有的数据，对固定集合中的数据进行删除将会得到如下错误：</li>
</ol>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37054" srcset="/img/loading.gif" lazyload alt="0"></p>
<ol>
<li>对已有数据进行修改，新文档大小必须与原来的文档大小一致，否则不允许更新：</li>
</ol>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37056" srcset="/img/loading.gif" lazyload alt="0"></p>
<ol>
<li>默认情况下，固定集合只有一个_id索引，而且最好是按数据写入的顺序进行读取。当然，也可以添加新的索引，但这会降低数据写入的性能。</li>
<li>固定集合不支持分片，同时，在MongoDB 4.2版本中规定了事务中也无法对固定集合执行写操作。</li>
</ol>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p>固定集合很适合用来存储一些“临时态”的数据。“临时态”意味着数据在一定程度上可以被丢弃。同时，用户还应该更关注最新的数据，随着时间的推移，数据的重要性逐渐降低，直至被淘汰处理。</p>
<p>一些适用的场景如下：</p>
<ul>
<li>系统日志，这非常符合固定集合的特征，而日志系统通常也只需要一个固定的空间来存放日志。在MongoDB内部，副本集的同步日志（oplog）就使用了固定集合。</li>
<li>存储少量文档，如最新发布的TopN条文章信息。得益于内部缓存的作用，对于这种少量文档的查询是非常高效的。</li>
</ul>
<p><strong>使用固定集合实现FIFO队列</strong></p>
<p>在股票实时系统中，大家往往最关心股票价格的变动。而应用系统中也需要根据这些实时的变化数据来分析当前的行情。倘若将股票的价格变化看作是一个事件，而股票交易所则是价格变动事件的“发布者”，股票APP、应用系统则是事件的“消费者”。这样，我们就可以将股票价格的发布、通知抽象为一种数据的消费行为，此时往往需要一个消息队列来实现该需求。</p>
<p>结合业务场景： 利用固定集合实现存储股票价格变动信息的消息队列</p>
<p>\1. 创建stock_queue消息队列，其可以容纳10MB的数据</p>
<p>​                db.createCollection(“stock_queue”,{capped:true,size:10485760})              </p>
<p>\2. 定义消息格式</p>
<p>​                {    timestamped:new Date(),    stock: “MongoDB Inc”,    price: 20.33 }              </p>
<ul>
<li>timestamp指股票动态消息的产生时间。</li>
<li>stock指股票的名称。</li>
<li>price指股票的价格，是一个Double类型的字段。</li>
</ul>
<p>为了能支持按时间条件进行快速的检索，比如查询某个时间点之后的数据，可以为timestamp添加索引</p>
<p>​                db.stock_queue.createIndex({timestamped:1})              </p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37141" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>\3. 构建生产者，发布股票动态</p>
<p>模拟股票的实时变动</p>
<p>​                function pushEvent(){    while(true){        db.stock_queue.insert({            timestamped:new Date(),            stock: “MongoDB Inc”,            price: 100*Math.random(1000)        });        print(“publish stock changed”);        sleep(1000);    } }               </p>
<p>执行pushEvent函数，此时客户端会每隔1秒向stock_queue中写入一条股票信息</p>
<p>​                pushEvent()              </p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37143" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>\4. 构建消费者，监听股票动态</p>
<p>对于消费方来说，更关心的是最新数据，同时还应该保持持续进行“拉取”，以便知晓实时发生的变化。根据这样的逻辑，可以实现一个listen函数</p>
<p>​                function listen(){    var cursor &#x3D; db.stock_queue.find({timestamped:{$gte:new Date()}}).tailable();    while(true){        if(cursor.hasNext()){                print(JSON.stringify(cursor.next(),null,2));        }        sleep(1000);    } }              </p>
<p>find操作的查询条件被指定为仅查询比当前时间更新的数据，而由于采用了读取游标的方式，因此游标在获取不到数据时并不会被关闭，这种行为非常类似于Linux中的tail-f命令。在一个循环中会定时检查是否有新的数据产生，一旦发现新的数据（cursor.hasNext()&#x3D;true），则直接将数据打印到控制台。</p>
<p>执行这个监听函数，就可以看到实时发布的股票信息</p>
<p>​                listen()              </p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/37146" srcset="/img/loading.gif" lazyload alt="0"></p>
<h1 id="5-WiredTiger读写模型详解"><a href="#5-WiredTiger读写模型详解" class="headerlink" title="5. WiredTiger读写模型详解"></a><strong>5. WiredTiger读写模型详解</strong></h1><h2 id="5-1-WiredTiger介绍"><a href="#5-1-WiredTiger介绍" class="headerlink" title="5.1 WiredTiger介绍"></a><strong>5.1 WiredTiger介绍</strong></h2><p>MongoDB从3.0开始引入可插拔存储引擎的概念。目前主要有MMAPV1、WiredTiger存储引擎可供选择。在3.22源的消耗,节省约60%以上的硬盘资源；</p>
<h2 id="5-2-WiredTiger读写模型"><a href="#5-2-WiredTiger读写模型" class="headerlink" title="5.2 WiredTiger读写模型"></a><strong>5.2 WiredTiger读写模型</strong></h2><h3 id="读缓存"><a href="#读缓存" class="headerlink" title="读缓存"></a><strong>读缓存</strong></h3><p>理想情况下，MongoDB可以提供近似内存式的读写性能。WiredTiger引擎实现了数据的二级缓存，第一层是操作系统的页面缓存，第二层则是引擎提供的内部缓存。</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/43548" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>读取数据时的流程如下：</p>
<ul>
<li>数据库发起Buffer I&#x2F;O读操作，由操作系统将磁盘数据页加载到文件系统的页缓存区。</li>
<li>引擎层读取页缓存区的数据，进行解压后存放到内部缓存区。</li>
<li>在内存中完成匹配查询，将结果返回给应用。</li>
</ul>
<p>MongoDB为了尽可能保证业务查询的“热数据”能快速被访问，其内部缓存的默认大小达到了内存的一半，该值由wiredTigerCacheSize参数指定，其默认的计算公式如下：</p>
<p>​                wiredTigerCacheSize&#x3D;Math.max(0.5*(RAM-1GB),256MB)              </p>
<h3 id="写缓冲"><a href="#写缓冲" class="headerlink" title="写缓冲"></a><strong>写缓冲</strong></h3><p>当数据发生写入时，MongoDB并不会立即持久化到磁盘上，而是先在内存中记录这些变更，之后通过CheckPoint机制将变化的数据写入磁盘。为什么要这么处理？主要有以下两个原因：</p>
<ul>
<li>如果每次写入都触发一次磁盘I&#x2F;O，那么开销太大，而且响应时延会比较大。</li>
<li>多个变更的写入可以尽可能进行I&#x2F;O合并，降低资源负荷。</li>
</ul>
<p>思考：MongoDB会丢数据吗？</p>
<p>MongoDB单机下保证数据可靠性的机制包括以下两个部分：</p>
<p><strong>CheckPoint（检查点）机制</strong></p>
<p>快照（snapshot）描述了某一时刻（point-in-time）数据在内存中的一致性视图，而这种数据的一致性是WiredTiger通过MVCC（多版本并发控制）实现的。当建立CheckPoint时，WiredTiger会在内存中建立所有数据的一致性快照，并将该快照覆盖的所有数据变化一并进行持久化（fsync）。成功之后，内存中数据的修改才得以真正保存。默认情况下，MongoDB每60s建立一次CheckPoint，在检查点写入过程中，上一个检查点仍然是可用的。这样可以保证一旦出错，MongoDB仍然能恢复到上一个检查点。</p>
<p><strong>Journal日志</strong></p>
<p>Journal是一种预写式日志（write ahead log）机制，主要用来弥补CheckPoint机制的不足。如果开启了Journal日志，那么WiredTiger会将每个写操作的redo日志写入Journal缓冲区，该缓冲区会频繁地将日志持久化到磁盘上。默认情况下，Journal缓冲区每100ms执行一次持久化。此外，Journal日志达到100MB，或是应用程序指定journal：true，写操作都会触发日志的持久化。一旦MongoDB发生宕机，重启程序时会先恢复到上一个检查点，然后根据Journal日志恢复增量的变化。由于Journal日志持久化的间隔非常短，数据能得到更高的保障，如果按照当前版本的默认配置，则其在断电情况下最多会丢失100ms的写入数据。</p>
<p>​    <img src="/1%E3%80%81MongoDB%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/43547" srcset="/img/loading.gif" lazyload alt="0"></p>
<p>WiredTiger写入数据的流程：</p>
<ul>
<li>应用向MongoDB写入数据（插入、修改或删除）。</li>
<li>数据库从内部缓存中获取当前记录所在的页块，如果不存在则会从磁盘中加载（Buffer I&#x2F;O） </li>
<li>WiredTiger开始执行写事务，修改的数据写入页块的一个更新记录表，此时原来的记录仍然保持不变。</li>
<li>如果开启了Journal日志，则在写数据的同时会写入一条Journal日志（Redo Log）。该日志在最长不超过100ms之后写入磁盘</li>
<li>数据库每隔60s执行一次CheckPoint操作，此时内存中的修改会真正刷入磁盘。</li>
</ul>
<p>Journal日志的刷新周期可以通过参数storage.journal.commitIntervalMs指定，MongoDB 3.4及以下版本的默认值是50ms，而3.6版本之后调整到了100ms。由于Journal日志采用的是顺序I&#x2F;O写操作，频繁地写入对磁盘的影响并不是很大。</p>
<p>CheckPoint的刷新周期可以调整storage.syncPeriodSecs参数（默认值60s），在MongoDB 3.4及以下版本中，当Journal日志达到2GB时同样会触发CheckPoint行为。如果应用存在大量随机写入，则CheckPoint可能会造成磁盘I&#x2F;O的抖动。在磁盘性能不足的情况下，问题会更加显著，此时适当缩短CheckPoint周期可以让写入平滑一些。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/" class="category-chain-item">系统架构</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6/" class="category-chain-item">架构之分布式框架</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6/MongoDB/" class="category-chain-item">MongoDB</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/MongoDB/">#MongoDB</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>1、MongoDB快速实战与基本原理</div>
      <div>https://kblayt.github.io/2023/06/18/系统架构/架构之分布式框架/MongoDB/1、MongoDB快速实战与基本原理/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Kblayt</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年6月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/06/18/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6/MongoDB/2%E3%80%81MongoDB%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C%E5%8F%8A%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" title="2、MongoDB聚合操作及索引底层原理">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">2、MongoDB聚合操作及索引底层原理</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/06/18/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6/Redis/10%E3%80%81%E6%B7%B1%E5%85%A5%E5%BA%95%E5%B1%82C%E6%BA%90%E7%A0%81%E8%AE%B2%E9%80%8FRedis%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%862/" title="10、深入底层C源码讲透Redis核心设计原理2">
                        <span class="hidden-mobile">10、深入底层C源码讲透Redis核心设计原理2</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
