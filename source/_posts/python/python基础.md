---

title: python基础
date: 2022-10-21 16:38:52
categories:
    - Python
tags:
    - Python
    - Python基础 
---

# **python中的算数运算符**

| 运算符 | 描述   | 实例                                  |
| ------ | ------ | ------------------------------------- |
| +      | 加     | 10 + 20 = 30                          |
| -      | 减     | 10 - 20 = -10                         |
| *      | 乘     | 10 * 20 = 200                         |
| /      | 除     | 10 / 20 = 0.5                         |
| //     | 取整除 | 返回除法的整数部分(商) 9//2输出结果 4 |
| %      | 取余数 | 返回除法的余数 9 % 2 = 1              |
| **     | 幂     | 又称次方、乘方， 2 ** 3 = 8           |

# 赋值运算符

| 运算符 | 描述                  | 实例                            |
| ------ | --------------------- | ------------------------------- |
| =      | 简单的赋值运算符      | c = a + b将a+b的运算结果赋值给c |
| +=     | 加法赋值运算符        | c += a 等效于 c = c + a         |
| -=     | 减法赋值运算符        | c -= a 等效于 c = c - a         |
| *=     | 乘法赋值运算符        | c *= a 等效于 c = c * a         |
| /=     | 除法赋值运算符        | c /= a 等效于 c = c / a         |
| //=    | 取整除赋值运算符      | c //= a 等效于 c = c // a       |
| %=     | 取 模(余数)赋值运算符 | c %= a 等效于 c = c % a         |
| **=    | 幂赋值运算符          | c **= a 等效于 c = c xx a       |

# **python中的变量类型**

- 在Python中定义变量是不需要指定类型
- 数据类型可以分为数据子和非数字型
- 数字型
  - 整行 int
  - 浮点型 float
  - 布尔型 bool
    - 真true 非0数 --非零即真
    - 假 false 0
  - 复数型（complex）
    - 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题

- 非数字型
  - 字符串
  - 列表
  - 元组
  - 字典

提示：在Python2.x中，整数根据保存数值的长度还分为：

- int （整数）
- long （长整数）
- 使用type函数可以查看一个变量的类型

```
In [1]:type(name)
```

# **变量的格式化输出**

- % 被称为格式化操作符，专门用于处理字符串中的格式
  - 包含 % 的字符串，被称为格式化字符串
  - % 和不同的字符串连用，不同类型的数据需要使用不同的格式化字符

| 格式化字符 | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| %s         | 字符串                                                       |
| %d         | 有符号十进制整数，%06d表述输出的数据显示位数，不足的地方使用0补全 |
| %f         | 浮点数，%.02f 表示小数点后只显示两位                         |
| %%         | 输出 %                                                       |

- 语法格式如下：

```
print("格式化字符串" % 变量1)

print("格式化字符串" % (变量1,变量2...))

print("我的名字叫 %s，请多多关照" % name)
```

# 关键字

- 关键字就是在Python内部已经使用的标识符
- 关键字具有特殊的功能和含义
- 开发者不允许定义和关键字相同的名字的标识符

通过以下命令可以查看Python中的关键字

```
In [1]: import keyword
In [2]: print(keyword.kwlist)
```

提示：关键字的学习及使用

- import 关键字可以导入一个“工具包”
- 在Python中不同的工具包，提供有不同的工具

# 判断(if-elseif-else)语句

在Python中，if语句就是用来进行判断的，格式如下：

```
if 条件1：
	条件成立时，要做的事情
	......
elseif 条件2:
	条件成立时，要做的事情
	......
elseif 条件3:
	条件成立时，要做的事情
	......
else:
	条件不成立时，要做的事情
	......
```

```
age = int(input(please scan age:))

if age>=18 :
    print("成年了")
    print("dasfasdf")
else:
    print("没成年")
print("走下面的逻辑")
```

# 逻辑运行(and、or、not)

# if嵌套

```
if 条件1:
	条件1满足执行的代码
	......
	if 条件1基础上的条件2:
		条件2满足时，执行的代码
	else:
		条件2不满足时，执行的代码
else:
	条件1不满足时，执行的代码
```

# 随机数的处理

- 在Python中，要使用随机数，首先需要导入随机数的模块--”工具包“

```
import random
```

- 导入模块后，可以直接在模块名称后面敲一个.然后按Tab键，会提示该模块中包含的所有函数
- random.randint(a,b)，返回[a,b]之间的整数，包含a和b

# 循环

while语句基本语法

```
while 条件(判断 计数器 是否达到 目标次数):
	条件满足时，做的事情1
	条件满足时，做的事情2
	条件满足时，做的事情3
	......
	
	处理条件(计数器 + 1)
```

```python
i = 1
while i <= 5:
    print("Hello World")

    i = i + 1
print("循环结束后的 i = %d" % i)
```

```python
i = 0
count = 0
while i<=100:
    count = count + i
    i = i + 1

print(count)
```

break和continue

- break 满足某一条件时，退出循环，不再执循环
- continue 满足某一条件时，不执行该次循环后续的代码

# 循环嵌套

```python
while 条件1:
	条件满足时，做的事情1
	条件满足时，做的事情2
	条件满足时，做的事情3
	......
	while 条件2：
		条件满足时，做的事情1
		条件满足时，做的事情2
		条件满足时，做的事情3
		......
		处理条件2
	处理条件1
```

```python
row = 1
while row <= 9:
    col = 1
    while col <= row:
        print("%d * %d = %d\t" % (row, col, row * col),end="")
        col = col + 1
    print("")
    row = row + 1
```

# 字符串中的转义字符

| 转义字符 | 描述       |
| -------- | ---------- |
| \\\      | 反斜杠符号 |
| \\\'     | 单引号     |
| \\"      | 双引号     |
| \n       | 换行       |
| \t       | 横向制表符 |
| \r       | 回车       |

# 函数基础

- 所谓函数，就是把具有独立功能的代码块组织为一个小模块，在需要的时候调用
- 函数的使用包含两个步骤：
  1. 定义函数 -- 封装独立的功能
  2. 调用函数 -- 销售封装的效果
- 函数的作用，在开发程序时，使用函数可以提高编写的效率以及代码的重用

函数的定义格式如下：

```python
def 函数名():
	函数封装的代码
	......
```

带参函数：

```python
def sum_2_num(num1, num2):
	"""对两个数字求和"""
	result = num1 + num2
	print("%d + %d = %d" % (num1, num2, result))
	
	
sum_2_num(50, 20)
```

函数返回值:

```python
def sum_2_num(num1, num2):
	"""对两个数字求和"""
	return num1 + num2
	
	
result = sum_2_num(50, 20)
print("计算结果是 %d" % result)
```

嵌套函数：

```python
def test1():
    print("*" * 50)


def test2():
    print("-" * 50)

    test1()

    print("-" * 50)


test2()

```

# 模块

模块是Python程序架构的一个核心概念

- 模块就好比是工具包，下用药使用这个工具包中的工具，就需要导入import这个模块
- 每一个以扩展名 py 结尾的 Python 源代码文件都是一个模块
- 在模块中定义的全局变量、函数 都是模块能够提供给外界直接使用的工具
- 可以在一个Python文件中定义变量或者函数
- 然后再另外一个文件中使用import导入这个模块
- 导入之后，就可以使用 模块名.变量/模块名.函数 的方式，使用这个模块中定义的变量或者函数

模块方便代码复用

# Pyc文件

C是compiled 编译过的意思

操作步骤

1. 浏览程序目录会发现一个__pycache的目录
2. 目录下面会有一个***.cpyhon-35.pyc文件，cpython-35表示Python解释器的版本
3. 这个pyc文件是由Python解释器将模块的源码转换为字节码
   - Python这样保存字节码是作为一种启动速度的优化

字节码

- Python在解释源程序时是分成两个步骤的
  1. 首先处理源代码，编译生成一个二进制字节码
  2. 在对字节码进行处理，才会生成CPU能够识别的机器码
- 有了模块的字节码文件之后，下一次运行程序时，如果在上次保存字节码之后没有修改过源代码，Python将会加载.pyc文件并跳过编译这个步骤
- 当Python重编译时，它会自动检查源文件和字节码文件的时间戳
- 如果你又修改了源代码，下次程序运行时，字节码将自动重新创建

# 高级变量类型

ps：对象.之后按Tab键可以查看对象可以使用的操作方法

- 列表
- 元组
- 字典
- 字符串
- 公共方法
- 变量高级

## 1、列表（可以修改）

### **定义：**

- List（列表）是Python中使用最频繁的数据类型。
- 专门用于存储一串信息
- 列表用[ ]定义，数据之间使用，分隔
- 列表的索引从0开始
  - 索引就是数据在列表中的位置编号，索引又可以被称为下标

1. 定义一个列表，例如：name_list = []
2. 列表的各类方法：

| 序号 | 分类 | 关键字/函数/方法        | 说明                     |
| ---- | ---- | ----------------------- | ------------------------ |
| 1    | 增加 | 列表.insert(索引，数据) | 在指定位置插入数据       |
|      |      | 列表.append(数据)       | 在末尾追加数据           |
|      |      | 列表.extend(列表2)      | 将列表2的数据追加到列表  |
| 2    | 修改 | 列表[索引] = 数据       | 修改指定索引的数据       |
| 3    | 删除 | del列表[索引]           | 删除指定索引的数据       |
|      |      | 列表.remove[数据]       | 删除第一个出现的指定数据 |
|      |      | 列表.pop                | 删除末尾数据             |
|      |      | 列表.pop(索引)          | 删除指定索引数据         |
|      |      | 列表.clear              | 清空列表                 |
| 4    | 统计 | len(列表)               | 列表长度                 |
|      |      | 列表.count(数据)        | 数据在列表中出现的次数   |
| 5    | 排序 | 列表.sort()             | 升序排序                 |
|      |      | 列表.sort(reverse=True) | 降序排序                 |
|      |      | 列表.reverse()          | 逆序，反转               |

### 循环遍历

- 遍历 就是 从头到尾 依次从列表中获取数据

  - 在循环体内部针对每一个元素，执行相同的操作

- 在Python中为了提高列表的遍历效率，专门提供的迭代Iteration遍历

- 使用for就能够实现迭代遍历

  ```python
  # for 循环内部使用的变量 in 列表
  for name in name_list:
  	循环内部针对列表元素进行操作
  	print(name)
  ```

## 2、元组（不可修改）

### **定义：**

- Tuple（元组）与列表类似，不同之处在于元组的元素不能修改
  - 元组表示多个元素组成的序列
  - 元组在Python开发中，有特定的应用场景
- 用于存储一串信息，数据之间使用，分割
- 元组用()定义
- 元组的索引 从0开始
  - 索引就是数据在元组中的位置编号

```python
info_tuple = ("zhangsan",18,1.75)
```

创建空元组

```python
tuple = ()
```

元组中 只包含一个元素时，需要在元素后面添加逗号

```
info_tuple = (50,)
```

元组的常用方法

```
info.count	info.index
```

### 循环遍历

- 取值 就是从 元组中获取存储在指定位置的数据
- 遍历就是从头到尾依次从元组中获取数据

```
# for 循环内部使用的变量 in 元组
for item in info:
	循环内部针对元组元素进行操作
	print(item)
```

- **在 Python中，可以使用for循环遍历所有非数字型类型的变量：列表、元组、字典以及字符串**
- ps：在实际开发中，除非能够确认元组中的数据类型，否则针对元组的循环遍历需求并不是很多

### **应用场景**

- 尽管可以使用for in 遍历元组
- 但是在开发中，更多的应用场景是：
  - 函数的参数和返回值，一个函数可以接受任意多个参数，或者一次返回多个数据
  - 格式字符串，格式化字符串后面的()本质上就是一个元组
  - 让列表不可以被修改，以保护数据安全

**元组和列表之间的转化**

- 使用 list 函数可以把元组转换成列表

```
list(元组)
```

- 使用tuple函数可以把列表转换成元组

```
tuple(列表)
```

## 3、字典

### **定义：**

- dictionary（字典）是除列表以外Python之中最灵活的数据类型
- 字典同样可以用来存储多个数据
  - 通常用于存储描述一个**物体**的相关信息
- 和列表的区别
  - 列表是有序的对象集合
  - 字典是无序的对象集合
- 字典用{}定义
- 字典使用**键值对**存储数据，键值对之间使用，分隔
  - 键key是索引
  - 值value是数据
  - 键和值之间使用:分割
  - 键必须是唯一的
  - 值可以取任何数据类型，但**键**只能使用字符串、数字或元组

```python
xiaoming = {"name": "小明",
			"age": 18,
			"gender": True,
			"height": 1.75}
```

### **常用操作：**

len(字典)：获取字典的键值对数量

字典.keys()：获取所有key列表

字典.values()：所有value列表

字典.items()：所有(key,value)元组列表

字典[key]：可以从字典中取值，key不存在会报错

字典.get(key)：可以从字典中取值，key不存在不会报错

del 字典[key]：删除指定键值对，key不会存在报错

字典.pop(key)：删除指定键值对，key不存在会报错

字典.popitem()：随机删除一个键值对

字典[key] = value：如果key存在，修改数据，如果key不存在，新增键值对

字典.setdefault(key,value)：如果key存在，不会修改数据秒如果key不存在，新增键值对

字典.update(字典2)：将字典2的数据合并到字典1

### 循环遍历

- 遍历就是依次从字典中获取所有键值对

```python
# for 循环内部使用的 key的变量 in 字典
for key in xiaoming：
	print(""%s : %s" % (key,xiaoming[key]))
```

ps：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所有正对字典的循环遍历需求并不是很多。

### 应用场景

- 尽管可以使用for in遍历字典
- 但是在开发中，更多的应用场景是：
  - 使用多个键值对，存储描述一个物体的相关信息——描述更复杂的数据信息
  - 将多个字典放在一个列表中，再进行遍历，再循环体内部针对每一个字典进行相同的处理

```python
card_list = [{"name":"zhangsan",
			  "qq":"123456",
			  "phone":"110"},
			 {"name":"lisi",
			  "qq":"56789",
			  "phone":"11111"
			}]
```

## 4、字符串

### 定义：

- 字符串就是一串字符，是编程语言中表示文本的数据类型
- 在Python中可以使用一对双引号""或者一对单引号''定义一个字符串
  - 跟java一样需要用到多重引号需要转义
- 可以使用索引获取一个字符串中指定位置的字符，索引计数从0开始
- 也可以使用for循环遍历字符串中每一个字符

```python
string = "Hello Python"

for c in string:
	print(c)
```

### 常用操作：

len(字符串)：获取字符串的长度

字符串.count(字符串)：小字符串在大字符串出现的次数

字符串[索引]：从字符串中取出单个字符

字符串.index(字符串)：获取小字符串第一次出现的索引

#### **判断类型**

| 方法               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| string.isspace()   | 如果string中只包含空额，则返回True                           |
| string.isalnum()   | 如果string至少有一个字符并且所有字符都是字母或数字则返回True |
| string.isalpha()   | 如果string至少有一个字符并且所有字符都是字母则返回True       |
| string.isdecimal() | 如果string只包含数字则返回True，全角数字                     |
| string.isdigit()   | 如果string只包含数字则返回True，全角数字、(1)、\u00b2        |
| string.isnumeric() | 如果string只包含数字则返回True，全角数字，汉字数字           |
| string.istitle     | 如果string是标题化的（每个单词的首字母大写）则返回True       |
| string.islower()   | 如果string中包含至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是小写，则返回True |
| string.isupper()   | 如果string中包含至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是大写，则返回True |

#### 查找和替换

| 方法                                                  | 说明                                                         |
| ----------------------------------------------------- | ------------------------------------------------------------ |
| string.startswith(str)                                | 检查字符串是否是以str开头，是则返回True                      |
| string.endswith(str)                                  | 检查字符串是否是以str结束，是则返回True                      |
| string.find(str,start=0,end=len(string))              | 检测str是否包含在string中，如果start和end指定范围，则检测是否包含在指定范围内，如果是返回开始的索引值，否则返回-1 |
| string.rfind(str,start=0,end=len(string))             | 类似于find()函数，不过是从右边开始查找                       |
| string.index(str,start=0,end=len(string))             | 跟find()方法类似，只不过如果str不在string会报错              |
| string.rindex(str,start=0,end=len(string))            | 类似于index()，不过是从右边开始                              |
| string.replace(old_str,new_str,num=string.count(old)) | 把string中的old_str替换new_str,如果num指定，则替换不超过num次 |

#### 大小写转化

| 方法                | 说明                             |
| ------------------- | -------------------------------- |
| string.capitalize() | 把字符串的第一个字符大写         |
| string.title()      | 把字符串的每个单词首字母大写     |
| string.lower()      | 转换 string 中所有大写字符为小写 |
| string.upper()      | 转换 string 中的小写字母为大写   |
| string.swapcase()   | 翻转 string 中的大小写           |

#### 文本对齐

| 方法                 | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| string.ljust(width)  | 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串 |
| string.rjust(width)  | 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串 |
| string.center(width) | 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串  |

#### 去除空白字符

| 方法            | 说明                             |
| --------------- | -------------------------------- |
| string.lstrip() | 截掉string 左边(开始)的空白字符  |
| string.rstrip() | 截掉 string 右边(末尾)的空白字符 |
| string.strip()  | 截掉string左右两边的空白字符     |

#### 拆分和连接

| 方法                     | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| string.partition(str)    | 把字符串 string 分成一个3元素的元组(str前面,str,str后面)     |
| string.rpartition(str)   | 类似于 partition0方法，不过是从右边开始查找                  |
| string.split(str="",num) | 以str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num +1个子字符串，str 默认包含 r; tn'和空格 |
| string.splitlines()      | 按照行('\r','\n','\r\n')分隔，返回一个包含各行作为元素的列表 |
| string.join(seq)         | 以string 作为分隔符，将 seq中所有的元素 (的字符串表示) 合并为一个新的字符串 |

### 字符串的切片：

- 切片 方法适用于字符串、列表、元组
  - 切片 使用索引值来限定范围，从一个大的字符串中切出小的字符串
  - 列表和元组都是有序的集合，都能够通过索引值获取到对应的数据
  - 字典是一个无序的集合，是使用键值对保存数据

![image-20230314162133065](python%E5%9F%BA%E7%A1%80/image-20230314162133065.png)

```
字符串[开始索引:结束索引:步长]
```

**注意：**

1. 指定的区间属于左闭右开型 [开始索引，结束索引）=> 开始索引 >= 范围 < 结束索引
2. 从头开始，开始索引数字可以省略，冒号不能省略
3. 到末尾结束，结束索引数字可以省略，冒号不能省略
4. 步长默认为1，如果连续切片，数字和冒号都可以省略

## 5、公共方法

### 5.1、Python内置函数

Python包含了一下内置函数：

| 函数             | 描述                           | 备注                      |
| ---------------- | ------------------------------ | ------------------------- |
| len(item)        | 计算容器中元素个数             |                           |
| del(item)        | 删除变量                       | del有两种方式             |
| max(item)        | 返回容器中元素最大值           | 如果是字典，只针对key比较 |
| min(item)        | 返回容器中元素最小值           | 如果是字典，只针对key比较 |
| cmp(item1,item2) | 比较两个值，-1小于/0相等/1大于 | Python 3.x取消了cmp函数   |

ps：字符串标胶符合一下规则："0" < "A" < "a"

### 5.2、切片

| 描述 | Python表达式       | 结果    | 支持的数据类型     |
| ---- | ------------------ | ------- | ------------------ |
| 切片 | "0123456789"[::-2] | "97531" | 字符串、列表、元组 |

- 切片使用索引值来限定范围，从一个大的字符串中切出小的字符串
- 列表和元组都是有序的集合，都能够通过索引值获取到对应的数据
- 字典是一个无序的集合，时使用键值对保存数据

### 5.3、运算符

| 运算符       | Python表达式      | 结果                      | 描述           | 支持的数据类型           |
| ------------ | ----------------- | ------------------------- | -------------- | ------------------------ |
| +            | [1,2]+[3,4]       | [1,2,3,4]                 | 合并           | 字符串、列表、元组       |
| *            | ["Hi!"] * 4       | ["Hi!","Hi!","Hi!","Hi!"] | 重复           | 字符串、列表、元组       |
| ln           | 3 in (1,2,3)      | True                      | 元素是否存在   | 字符串、列表、元组、字典 |
| not in       | 4 not in（1,2,3） | True                      | 元素是否不存在 | 字符串、列表、元组、字典 |
| > >= == < <= | (1,2,3) < (2,2,3) | True                      | 元素比较       | 字符串、列表、元组       |

ps：

- in在对字典操作时，判断的是字典的键
- in和not in 被称为成员运算符

### 5.4、完整的For循环语法

在Python中完成的for循环的语法如下：

```python
for 变量 in 集合:
	循环体代码
else:
	没有通过break退出循环，循环结束后，会执行的代码
```

# 变量进阶

目标：

- 变量的引用
- 可变和不可变类型
- 局部变量和全局变量

## 1、变量的引用

- 变量和数据都是保存在内存中的
- 在Python中函数的参数传递以及返回值都是靠引用传递的

### 1.1、引用的概念

在Python中

- 变量和数据是分开存储的
- 数据保存在内存中的一个位置
- 变量中保存着数据在内存中的地址
- 变量中记录数据的地址，就叫作引用
- 使用id()函数可以查看变量中保存数据所在的内存地址

ps：如果变量已经被定义，当给一个变量赋值的时候，本质上是修改了数据的引用

- 变量不再对之前的数据引用
- 变量改为对新赋值的数据引用

### 1.2、变量引用的示例

### 1.3、函数的参数和返回值的传递

在Python中，函数的实参/返回值 都是靠引用来传递来的

```python
def test(num):
	print("-" * 50)
	print("%d 在函数内的内存地址是 %x" % (num, id(num)))
	
	result = 100
	
	print("返回值 %d 在内存中的地址是 %x" % (result, id(result)))
	print("-" * 50)
	
	return result

a = 10
print("调用函数前 实参内存地址是 %x" % id(a))
print("调用函数前 返回值内存地址是 %x" % id(r))

```

## 2、可变和不可变类型

- 不可变类型，内存中的数据不允许被修改
  - 数据类型 int，bool，float，complex，long(2.x)
  - 字符串 str
  - 元组 tuple
- 可变类型，内存中的数据可以被修改
  - 列表 list
  - 字典 dict

ps：字典的key只能使用不可变类型的数据

1. 可变类型的数据变化，是通过方法来实现的
2. 如果给一个可变类型的变量，赋值了一个新的数据，引用会修改
   - 变量不再对之前的数据引用
   - 变量改为对新赋值的数据引用

哈希（hash）

- Python中内置有一个名字叫做hash(o)的函数
  - 接受一个不可变类型的数据作为参数
  - 返回结果是一个整数
- hash是一种算法，其作用就是提起数据的特征码（指纹）
  - 相同的内容得到相同的结果
  - 不同的内容得到不同的结果
- 在Python中，设置字典的键值对时，会首先对key进行hash已决定如何在内存中保存字典的数据，以方便后续对字典的操作：CRUD
  - 键值对的key必须是不可变类型数据
  - 键值对的value可以是任意类型的数据

## 3、局部变量和全局变量

- 局部变量实在函数内部定义的变量，只能在函数内部使用
- 全局变量实在函数外部定义的变量（没有定义在某一个函数内），所有函数内部都可以使用这个变量

### 3.1 局部变量

- 局部变量是在函数内部定义的变量，只能在函数内部使用
- 函数执行结束后，函数内部的局部变量会被系统回收
- 不同的函数，可以定义相同名字的局部变量，但是各用各的不会产生影响

局部变量的生命周期

- 所谓生命周期就是变量从被创建到被系统回收的过程
- 局部变量在函数执行时，才会被创建
- 函数执行结束后局部变量被系统回收
- 局部变量在生命周期内，可以用来存储函数内部临时使用到的数据

### 3.2 全局变量

- 全局变量是在函数外部定义的变量，所有函数内部都可以使用这个变量

ps：函数执行时，需要处理变量时会：

1. 首先查找函数内部是否存在指定名称的局部变量，如果有，直接使用
2. 如果没有，查找函数外部是否存在指定名称的全局变量，如果有，直接使用
3. 如果还没有，程序报错。

1）函数不能直接修改全局变量的引用

- 全局变量是在函数外部定义的变量（没有定义在某一个函数内），所有函数内部都可以使用这个变量
- 在函数内部，可以通过全局变量的引用获取对应的数据
- 但是，不允许直接修改全局变量的引用——使用赋值语句修改全局变量的值

ps：如果在函数内部定义了一个与全局变量相同的局部变量，他们只是名称相同而已，在函数内部不能直接修改全局变量的值。

```python
demo1()
#全局变量
num = 10

def demo1():
	num = 99
	print("demo1 ==> %d" % num)
	
def demo2():
	print("demo1 ==> %d" % num)
	
demo1()
demo2()
```

2）在函数内部修改全局变量的值

- 如果在函数中需要修改全局变量，需要使用global进行声明

  ```python
  num = 10
  def demo1():
  
  	print("demo1" + "-" * 50)
  	
  	global num
  	
  	num = 100
  	print(100)
  	
  def demo2():
  	
  	print("demo2" + "-" *50)
  	print(num)
  	
  demo1()
  demo2()
  
  print("over")
  ```


3）全局变量定义的位置

- 为了保证所有的函数都能够正确使用到全局变量，应该将全局变量定义在其他函数的上方

```python
a = 10


def demo():
	print("%d" % a)
	print("%d" % b)
	print("%d" % c)

b = 20
demo()
c = 30
```

**注意**

- 由于全局变量c，是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所以程序会报错！

代码的结构示意图如下

![image-20230327214025738](python%E5%9F%BA%E7%A1%80/image-20230327214025738.png)

4）全局变量命名的建议

- 为了避免局部变量和全局变量出现混淆，在定义全局变量时，有一些公司会有开发要求，例如：全局变量名前应该改加g_或者gl的前缀

# 函数

目标

- 函数参数和返回值的作用
- 函数的返回值 进阶
- 函数的参数 进阶
- 递归函数

## 01.函数参数和返回值的作用

函数根据有没有参数以及有没有返回值，可以相互组合，一共有四种组合形式

1. 无参数，无返回值
2. 无参数，有返回值
3. 有参数，无返回值
4. 有参数，有返回值

![image-20230327214521586](python%E5%9F%BA%E7%A1%80/image-20230327214521586.png)

## 02.函数的返回值 进阶

- 在程序开发中，有时候，会希望一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理
- 返回值 是函数 完成过工作后，最后 给调用者的一个结果
- 在函数中使用 return 关键字可以返回结果
- 调用函数一方，可以使用变量来接受函数的返回结果

```python
当方法返回值是一个元组时，
def ab():
return a,b;
可以使用一个元组来接收
result = ab()
也可以将元组拆开来接收
a, b = ab();
```

交换两个数字

```python
# 解法1 - 使用临时变量
c = b
b = a
a = c

# 解法2 - 不适用临时变量
a = a + b
b = a - b
a = a - b

# 解法3 - python的元组
a, b = b, a
```

## 03.函数的参数 进阶

**3.1.不可变和可变的参数**

**问题1：**在函数内部，针对参数使用的赋值语句，会不会影响到调用函数时传递的实参变量？

不会

- 无论传递的参数是可变的还是不可变的
  - 只要针对参数使用赋值语句，会在函数内部修改局部变量的引用，不会影响到外部变量的引用

```python
def demo(num, num_list):

	print("函数内部")
	
	# 赋值语句
	num = 200
	num_list = [1, 2, 3]
	
	print(num)
	print(num_list)
	
	print("函数代码完成")
	
gl_num = 99
gl_list = [4, 5, 6]
demo(gl_num, gl_list)
print(gl_num)
print(gl_list)
	
```

**问题2：**如果传递的参数是可变类型，在函数内部，使用方法修改了数据的内容，同样会影响到外部的数据

```python
def mutable(num_list):
	# num_list = [1, 2, 3]
	num_list.extend([1, 2, 3])
	
	print(num_list)
	
gl_list = [6, 7, 8]
mutable(gl_list)
print(gl_list)
```

- 在python中，列表变量调用+=本质上实在执行列表变量的extend方法，不会修改变量的引用

```python
def demo(num, num_list):

	print("函数内部代码")
	
	# num = num + num
	num += num
	# num_list.extend(num_list)由于是调用方法，使用不会修改变量的引用
	# 函数执行结束后， 外部数据同样会发生变化
	num_list += num_list
	
	print(num)
	print(num_list)
	print("函数代码完成")
	
gl_num = 9
gl_list = [1, 2, 3]
demo(gl_num, gl_list)
print(gl_num)
print(gl_list)
```

**3.2 缺省参数**

- 定义函数时，可以给某个参数指定一个默认值，具有默认值的参数就叫做缺省参数
- 调用函数时，如果没有传入缺省参数的值，则在函数内部使用定义函数时指定的参数默认值
- 函数的缺省参数，将常见的值设置为参数的缺省值，从而简化函数的调用
- 例如：对列表排序的方法

```python
gl_num_list = [6, 3, 9]

# 默认就是升序排序，因为这种应用需求更多
gl_num_list.sort()
print(gl_num_list)

# 只有当需要降序排序时，才需要传递"reverse"参数
gl_num_list.sort(reverse=True)
print(gl_num_list)
```

**指定函数的缺省参数**

- 在参数后使用赋值语句，可以指定参数的缺省值

```python
def print_info(name, gender=True):

	gender_text = "男生"
	if not gender:
		gender_text = "女生"
	
	print("%s 是 %s" % (name, gender_text))
```

ps:

1. 缺省参数，需要使用最常见的值作为默认值！
2. 如果一个参数的值布恩那个确定，则不应该设置默认值，具体的数值在调用函数时，由外界传递

**缺省参数的注意事项**

1）缺省参数的定义位置

- 必须保证带有默认值的缺省参数在参数列表末尾
- 所以，一下定义是错误的！

```python
def print_info(name, gender=True, title):
```

2)调用带有多个缺省参数的函数

- 在调用函数时，如果有多个缺省参数，需要指定参数名，这样解释器才能够知道参数的对应关系！

**3.3 多值参数**

**定义支持多值参数的参数**

- 有时可能需要一个函数能够处理的参数 个数 是不确定的，这个时候，就可以使用多值参数
- python 中有两种多值参数：
  - 参数名前面增加一个 * 可以接收元组
  - 参数名前面增加两个 * 可以接收字典
- 一般在给多值参数命名时，习惯使用以下两个名字
  - *args ——存放 元组参数，前面有一个 * 
  - **kwargs —— 存放 字典 参数，前面有两个*
- args 是 arguments 的缩写，有变量的含义
- kw 是 keyword的缩写，kwargs 可以记忆键值对参数

```python
def demo(num, *args, **kwargs):
	
	print(num)
	print(args)
	print(kwargs)
	
demo(1, 2, 3, 4, 5, name="小明", age=18, gender=True)
```

提示：多指参数的应用会经常出现在网络上一些大牛开发的框架中，知道多指参数，有利于我们能够读懂大牛的代码

**多值参数案例——计算任意多个数字的和**

**需求**

1. 定义一个函数sum_numbers,可以接收的任意多个整数
2. 功能要求：将传递的所有数字累加并返回累加结果

```python
def sum_numbers(*args):
	
	num = 0
	# 遍历args元组顺序求和
	for n in args:
		num += n
		
	return num
	
print(sum_numbers(1, 2, 3))
```

**元组和字典的拆包**

- 在调节带有多值参数的函数时，如果希望
  - 将一个元组变量，直接传递给args
  - 将一个字典变量，直接传递给kwargs
- 就可以使用拆包，简化参数的传递，拆包的方式是：
  - 在元组变量前，增加一个*
  - 在字典变量前，增加两个*

```python
def demo(*args, **kwargs):
	
	print(args)
	print(kwargs)
	
	
# 需要将一个元组变量/字典变量传递给函数对应的参数
gl_nums(1, 2, 3)
gl_xiaoming = {"name": "小明", "ages": 18}

#会把 num_tuple和xiaoming作为元组传递给args
# demo(gl_nums, gl_xiaoming)
demo(*gl_nums, **gl_xiaoming)
```

## 04.函数的递归

函数调用自身的编程技巧称为递归

**4.1递归函数的特点**

- 一个函数 内部 调用自己
  - 函数内部可以调用其他函数，当然在函数内部也可以调用自己

代码特点

1. 函数内部的代码是相同的，只是针对参数不同，处理的结果不同
2. 当参数满足一个条件时，函数不再执行

```python
def sum_numbers(num):

	print(num)
	
	if num == 1
		return
		
	sum_numbers(num - 1)
	
sum_numbers(3)
```

![image-20230328100709669](python%E5%9F%BA%E7%A1%80/image-20230328100709669.png)

**4.2 递归案例——计算数字累加**

```python
def sum_numbers(num):
	
	if num == 1:
		return 1
		
	temp = sum_numbers(num - 1)
	
	return num + temp
	
print(sum_numbers(2))
```

# 面向对象(oop)基本概念

面向对象编程——Object Oriented Programming 简写OOP

**目标**

- 了解面向对象基本概念

## 01.面向对象基本概念

### 1.1 过程和函数（科普）

- 过程 是早期的一个编程概念
- 过程类似于函数，只能执行，但是没有返回值
- 函数不仅能执行，还可以返回结果

### 1.2 面向过程和面向对象基本概念

1）面向过程——怎么做？

1. 把完成某一个需求的所有步骤从头到尾逐步实现
2. 根据开发需求，将某些功能独立的代码封装成一个又一个函数
3. 最后完成的代码，就是顺序的调用不同的函数

特点

1. 注重步骤与过程，不注重职责分工
2. 如果需求复杂，代码会变得很复杂
3. 开发复杂项目，没有固定的套路，开发难度很大

![image-20230328132003869](python%E5%9F%BA%E7%A1%80/image-20230328132003869.png)

2）面向对象——谁来做？

相比较函数，面向对象是更大的封装，根据职责在一个对象中封装多个方法

1. 在完成某一个需求前，首先确定职责——要做的事情（方法）
2. 根据职责确定不同的对象，在对象内部封装不同的方法（多个）
3. 最后完成的代码，就是顺序地让不同的对象调用不同的方法

特点

1. 注重对象和职责，不同的对象承担不同的职责
2. 更加适合对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路
3. 需要在面向过程基础上，在学习一些面向对象的语法

# 类和对象

目标

- 类和对象的概念
- 类和对象的关系
- 类的设计

## 01.类和对象的概念

类和对象是面向对象编程的两个核心概念

### 1.1 类

- 类 是对一群具有相同特征或者行为的事务的一个统称，是抽象的，不能直接使用
  - 特征被称为属性
  - 行为被称为方法
- 类 就相当于制造飞机时的图纸，是一个模板，是负责创建对象的

### 1.2 对象

- 对象是由类创造出来的一个具体存在，可以直接使用
- 由 哪一个类创造出来的对象，就拥有在哪一个类中定义的
  - 属性
  - 方法
- 对象就相当于用图纸制造的飞机

在程序开发中，应该先有类，再有对象

## 0.2.类和对象的关系

- 类是模板，对象是根据类这个模板创建出来的，应该先有类，再有对象
- 类只有一个，而对象可以有很多个
  - 不同的对象之间属性可能会各不相同
- 类中定义了什么属性和方法，对象中就有什么属性和方法，不可能多也不可能少

## 03.类的设计

在使用面向对象开发前，应该首先分析需求，确定一定，程序中需要包含哪些类

![image-20230328192440145](python%E5%9F%BA%E7%A1%80/image-20230328192440145.png)

在程序卡法中，要设计一个类，通常需要满足以下三个要素：

1. 类名 这类事物的名字，满足大驼峰命名法
2. 属性 这类事物具有什么样的特征
3. 方法 这类事物具有什么样的行为

### **3.1 类名的确定**

名词提炼法分析整个业务流程，出现的名词，通常就是找到的类

### 3.2 属性和方法的确定

- 对 对象的特征描述，通常可以定义成属性
- 对象具有的行为(动词)，通常可以定义成方法

# 面向对象基础语法

目标

- dir 内置函数
- 定义简单的类(只包含方法)
- 方法中的self参数
- 初始化方法
- 内置方法和属性

## 01.dir内置函数

- 在Python中对象几乎是无所不在的，我们之前学习的变量、数据、函数都是对象

在Python中可以使用一下两个方法验证：

1. 在标识符/数据后输入一个  .  ，然后按下TAB键，iPython会提示该对象能够调用的方法列表
2. 使用内置函数dir传入标识符/数据，可以查看对象内的 所有属性及方法

> | 序号 | 方法名                 | 类型 | 作用                                  |
> | ---- | ---------------------- | ---- | ------------------------------------- |
> | 01   | 双下划线+new+双下划线  | 方法 | 创建对象时，会被自动调用              |
> | 02   | 双下划线+init+双下划线 | 方法 | 对象被初始化时，会被自动调用          |
> | 03   | 双下划线+del+双下划线  | 方法 | 对象被从内存中销毁前，会被自动调用    |
> | 04   | 双下划线+str+双下划线  | 方法 | 返回对象的描述信息，print函数输出使用 |

## 02.定义简单的类（只包含方法）

> 面向对象是更大的封装，在一个类中封装多个方法，这样通过这个类创建出来的对象，就可以直接调用这些方法了！

### 2.1 定义只包含方法的类

- 在Python中要定义一个只包含方法的类，语法格式如下：

```
class 类名：
	
	def 方法1(self,参数列表):
		pass
	
	def 方法2(self,参数列表):
		pass
```

- 方法的定义格式和之前学习过的函数几乎一样
- 区别在于第一个参数必须是self。

### 2.2 创建对象

- 当一个类定义完成之后，要是用这个类来创建对象，语法格式如下：

```
对象变量 = 类名()
```

### 2.3 第一个面向对象程序

需求

- 小猫爱吃鱼，小猫要喝水

分析

1. 定义一个猫类Cat
2. 定义两个方法eat和drink
3. 按照需求——不需要定义属性

![image-20230401103925673](python%E5%9F%BA%E7%A1%80/image-20230401103925673.png)

```
class Cat:
	"""这是一个猫类"""
	
	def eat(self):
		print("小猫爱吃鱼")
		
	def drink(self):
		print("小猫在喝水")
		
tom = Cat()
tom.drink()
tom.eat()

lazy_cat = Cat()
lazy_cat2 = lazy_cat

print(tom)
print(lazy_cat)
print(lazy_cat2)
```

**引用概念的强调**

> 在面向对象开发中，引用的概念是同样适用的！

- 在Python中使用类创建对象之后，tom变量中仍然记录的时对象在内存中的地址
- 也就是tom变量引用了新建的猫对象
- 使用print输出对象变量，默认情况下，是能够输出这个变量引用的对象 是 由哪一个类创建的对象，以及在内存中的地址（十六进制表示）

> 提示：在计算机中，通常使用十六进制 表示内存地址
>
> - 十进制 和 十六进制都是用来表达数字的，只是表示的方式不一样
>
> - 十进制 和 十六进制 的数字之间可以来回转化

- %d 可以以 10进制 输出数字
- %x 可以以 16进制 输出数字

## 03.方法中的self参数

### 3.1 案列改造——给对象增加属性

- 在Python中，要给对象设置属性，非常的容易，但是不推荐使用
  - 因为：对象属性的封装应该封装在类的内部
- 只需要在类的外部代码中直接通过.设置一个属性即可

> ps：这种方式虽然简单，但是不推荐使用！

```
tom.name = "Tom"
...

lazy_cat.name = "大懒猫"
```

### 3.2 使用self在方法内部输出每一只猫的名字

> 由 哪一个对象 调用的方法，方法内的self就是 哪一个对象的引用

- 在类封装的方法内部，self就表示当前调用方法的对象自己
- 调用方法时，程序员不需要传递self参数
- 在方法内部
  - 可以通过self，访问对象的属性
  - 也可以通过self，调用其他的对象方法
- 改造代码如下：

```
class Cat:
	
	def eat(self):
		 print("%s 爱吃鱼" % self.name)
		 
tom = Cat()
tom.name = "Tom"
tom.eat()

lazy_cat = Cat()
lazy_cat.name = "大懒猫"
lazy_cat.eat()
```

- 在类的外部，通过 变量名.  访问对象的属性和方法
- 在 类封装的方法中，通过 self.  访问对象的属性和方法

## 04.初始化方法

### 4.1 之前代码存在的问题 —— 在类的外部给对象增加属性

- 将案例代码进行调整，先调用方法 在设置属性，观察一下执行效果

```
tom = Cat()
tom.drink()
tom.eat()
tom.name() = "Tom"
print(tom)
```

- 程序执行报错如下：

```
AttributeError: 'Cat' object has no attribute 'name'
```

提示

- 在日常开发中，不推荐在类的外部给对象增加属性
  - 如果在运行时，没有找到属性，程序会报错
- 对象应该包含有哪些属性，应该 封装在类的内部

### 4.2 初始化方法

- 当使用 类名() 创建对象时，会自动执行以下操作：
  1. 为对象在内存中分配空间——创建对象
  2. 为对象的属性设置初始值——初始化方法（\__init\_\_）
- 这个初始化方法就是 \_\_init\_\_方法，\__init\_\_是对象的内置方法

> init 方法是专门用来定义一个类 具有哪些属性的方法

在Cat中增加init方法，验证该方法在创建对象时会被自动调用

```
class Cat:

	 def __init__(self):
	 	print("初始化方法")
```

### 4.3 在初始化方法内部定义属性

- 在init 方法内部使用 self.属性名 = 属性的初始值 就可以定义属性
- 定义属性之后，再使用Cat类创建的对象，都会拥有该属性

```
class Cat:

	def __init__(self):
	
		print("这是一个初始化方法")
		
		self.name = "Tom"
		
	def eat(self):
		print("%s 爱吃鱼" % self.name)
		
tom = Cat()

tom.eat()
```

### 4.4 改造初始化方法——初始化的同时设置初始值

- 在开发中，如果希望在创建对象的同时，就设置对象的属性，可以对\__init\_\_方法进行改造
  1. 把希望设置的属性值，定义成\__init\_\_方法的参数
  2. 在方法内部使用 self.属性 = 形参 接收外部传递的参数
  3. 在创建对象时，使用 类名(属性1，属性2...) 调用

```
class Cat：
	
	def __init__(self,name):
		print("初始化方法 %s" % name)
		self.name = name
	...
	
tom = Cat("Tom")
...

lazy_cat = Cat("大懒猫")
...
```

## 05.内置方法和属性

| 序号 | 方法名      | 类型 | 作用                                  |
| ---- | ----------- | ---- | ------------------------------------- |
| 01   | \__del\_\_  | 方法 | 对象被从内存中销毁前，会被自动调用    |
| 02   | \_\_str\_\_ | 方法 | 返回对象的描述信息，print函数输出使用 |

### 5.1 \_\_del\_\_方法

- 在Python中
  - 当使用 类名() 创建对象时，为对象分配完空间后，自动调用\_\_init\_\_方法
  - 当一个对象被从内存中销毁前，会自动调用\_\_del\_\_方法
- 应用场景
  - \_\_init\_\_改造初始化方法，可以让创建对象更加灵活
  - \_\_del\_\_如果希望在对象被销毁前，再做一些事情，可以考虑一下\_\_del\_\_方法
- 生命周期
  - 一个对象从调用 类名() 创建，生命周期开始
  - 一个对象的\_\_del\_\_方法一旦被调用，生命周期结束
  - 在对象的生命周期内，可以访问对象属性，或者让对象调用方法

### 5.2 \_\_str\_\_方法

- 在Python中，使用print输出对象变量，默认情况下，会输出这个变量引用的对象是由哪一个类创建的对象，以及在内存中的地址（十六进制表示）
- 如果在开发中，希望使用print输出对象时，能够打印自定义的内容，就可以利用\_\_str\_\_这个内置方法了

> ps:\_\_str\_\_方法必须返回一个字符串

```
class Cat:

	def __init__(self, new_name):
	
		self.name = new_name
		
		print("%s 来了" % self.name)
		
	def __del__(self):
	
		print("%s 去了" % self.name)
		
	def __str__(self):
		return "我是小猫: %s" % self.name
		
tom = Cat("Tom")
print(tom)
```

# 面向对象封装案列

**目标**

- 封装
- 小明爱跑步
- 存放家具



## 01.封装

1. 封装是面向对象编程的一大特点
2. 面向对象编程的第一步——将属性和方法封装到一个抽象的类中
3. 外接使用类创建对象，然后让对象调用方法
4. 对象方法的细节，被封装在类的内部

## 02.小明爱跑步

**需求**

1. 小明体重75公斤
2. 小明每次跑步会减肥0.5kg
3. 小明每次吃东西体重增加1kg

![image-20230404191843224](python%E5%9F%BA%E7%A1%80/image-20230404191843224.png)

## 03.摆放家具

**需求**

1. 房子（House）有 户型、总面积 和 家具名称列表
   - 新房子没有任何家具
2. 家具（HousrItem）有名字 和占地面积
   - 席梦思（bed）占地4平米
   - 衣柜（chest）占地2平米
   - 餐桌（table）占地1.5平米
3. 将以上三件家具添加到房子中
4. 打印房子时，要求输出：户型、总面积、剩余面积、家具名称列表

![image-20230404194416886](python%E5%9F%BA%E7%A1%80/image-20230404194416886.png)

**剩余面积**

1. 在创建房子对象时，定义一个剩余面积的属性，初始值和总面积相等
2. 当调用add_item方法，向房间添加家具时，让 剩余面积 -= 家具面积

思考：应该先开发哪一个类？

答案——家具类

1. 家具简单
2. 房子要使用到家具，被使用的类通常应该先开发

**小结**

1. 创建了一个房子类，使用到\_\_init\_\_ 和 \_\_str\_\_两个内置方法
2. 准备了一个 add_item 方法 准备添加家具
3. 使用房子类 创建了 一个房子对象
4. 让房子对象调用了三次 add_item方法，将 三件家具 以实参船吊 add_item内部

**添加家具：**

**需求**

- 判断 家具的面积 是否 超过剩余面积，如果超过，提示不能添加这件家具
- 将 家具的名称追加到家具名称列表中
- 用 房子的剩余面积 - 家具面积

# 私有属性和私有方法

## 01.应用场景及定义方式

**应用场景**

- 在实际开发中，对象的某些属性或方法可能只希望在对象的内部被使用，而不希望在外部被访问到
- 私有属性就是对象不希望公开的属性
- 私有方法就是对象不希望公开的方法

**定义方式**

- 在定义属性或方法时，在属性名或者方法名前增加两个下划线，定义的就是私有属性或方法

![image-20230407185607587](python%E5%9F%BA%E7%A1%80/image-20230407185607587.png)

## 02.伪私有属性和私有方法（科普）

> ps：在日常开发中，不要使用这种方式，访问对象的私有属性或私有方法

Python中，并没有真正意义的私有

- 在给属性、方法命名时，实际是对名称做了一些特殊处理，使得外界无法访问到
- 处理方式：在 名称 前面加上 \_类名 => \_类名\_\_名称

```
# 私有属性，外部不能直接访问到
print(xiaofang._Women__age)

# 私有方法，外部不能直接调用
xiaofang._Women__secret()
```

# 继承

**目标**

- 单继承
- 多继承

**面向对象三大特征**：封装、继承、多态

## 01.单继承

### 1.1 继承的概念、语法和特点

**继承的概念**：子类 拥有 父类的所有方法和属性

![image-20230407190504525](python%E5%9F%BA%E7%A1%80/image-20230407190504525.png)

1）**继承的语法**

```
class 类名(父类名)：

	pass
```

- 子类 继承自 父类，可以直接享受 父类中已经封装好的方法，不需要再次开发
- 子类 中应该根据 职责，封装子类特有的属性和方法

2）**专业术语**

- Dog 类是 Animal 类的子类，Animal类是 Dog 类的父类，Dog 类从 Animal 类继承
- Dog 类是 Animal的派生类，Animal类是Dog类的基类，Dog类从Animal类派生

3）**继承的传递性**

- C 类从 B类继承，B类又从A类继承
- 那么 C 类就具有B类和A类的所有属性和方法

子类拥有父类以及父类的父类中封装的所有属性和方法

### 1.2方法的重写

- 子类 拥有父类的所有方法和属性
- 子类 继承自父类，可以直接享受父类中硬件封装好的方法，不需要再次开发

**应用场景**

- 当 父类 的方法实现不能满足子类需求时，可以对方法进行 重写(override)

![image-20230408104141174](python%E5%9F%BA%E7%A1%80/image-20230408104141174.png)

**重写** 父类方法有两种情况：

1. **覆盖** 父类的方法
2. 对父类方法进行 **扩展**

1）**覆盖父类的方法**

- 如果在开发中，父类的方法实现和子类的方法实现，完全不同
- 就可以使用 覆盖的方式，在子类中重新编写父类的方法实现

> 具体的实现方式，就相当于在子类中 定义了一个 和 父类同名的方法并且实现

重写之后，在运行时，只会调用子类中重写的方法，而不再会调用父类封装的方法

2）**对父类方法进行扩展**

- 如果在开发中，子类的方法实现中包含父类方法实现
  - 父类原本封装的方法实现是子类方法的一部分
- 就可以使用扩展的方式
  1. 在子类中 重写父类的方法
  2. 在需要的位置使用super().父类方法 来调用父类方法的执行
  3. 代码其他的位置针对子类的需求，编写子类特有的代码实现

关于super

- 在Python中super是一个特殊的类
- super()就是使用super类创建出来的对象
- 最常 使用的场景就是在 重写父类方法时，调用在父类中封装的方法实现

**调用父类方法的另外一种方式（不推荐使用）**

> 在Python 2.x时，如果需要调用父类的方法，还可以使用以下方式

```
父类名.方法(self)
```

- 这种方式，目前在Python 3.x还支持这种方式
- 这种方法不推荐使用，因为一旦父类发生变化，方法调用位置的类名同样需要求改

**提示**

- 在开发时，父类名 和 super()两种方式不要混用
- 如果使用当前子类名调用方法，会形成递归调用，出现死循环











