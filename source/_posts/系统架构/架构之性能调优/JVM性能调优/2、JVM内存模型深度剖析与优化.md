---
title: 2、JVM内存模型深度剖析与优化
date: 2023-06-16 16:48:42
categories:
    - 系统架构
    - 架构之性能调优
    - JVM性能调优
tags:
    - JVM性能调优
---

# **JDK体系结构**

------

​    ![0](2%E3%80%81JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/94563)

# **Java语言的跨平台特性**

------

​    ![0](2%E3%80%81JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/94569)

# **JVM整体结构及内存模型**

------

​    ![0](2%E3%80%81JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/95302)

1. **堆**：堆是用于存储对象实例的区域，而且它是在JVM启动时创建的，被所有线程共享。	
   1. **年轻代**：占总堆的1/3
      1. **Eden**：占年轻代8/10
      2. **Survivor**：占年轻代的2/8
         1. **S0**：占Survivor的1/2即年轻代的1/10
         2. **S1**：占Survivor的1/2即年轻代的1/10
   2. **老年代**：占总堆的2/3
2. **栈**：每个线程都有一个私有的Java虚拟机栈（Java Virtual Machine Stack），每个Java虚拟机栈都由一系列帧（Frame）组成，每个帧对应着一个方法的调用。在多线程的情况下，每个线程都有自己的栈，互不影响。
   1. **局部变量表**：每个栈帧都私有一个局部变量表，是方法在执行过程中用于存放方法中变量的一块内存空间，是数组结构。（main方法与不同方法不同，main方法局部变量表存放的是所用到的对象在堆中的内存地址）
   2. **操作数栈**：每个栈帧都私有一个操作数栈，是方法在执行过程中操作数临时存放的一块内存空间。
   3. **动态链接**：动态链接主要涉及方法的调用和解析，目的是将符号引用转换为直接引用，使得方法能够正确地被调用。这个过程包括解析阶段，解析阶段就是动态链接的一部分。*但这个直接引用可能并不是具体的内存地址。它可能是一个指向方法在方法区中的地址或者是一个偏移量等。*
   4. **方法出口**：是用来记录方法调用完成后程序执行的下一条指令的位置。每当一个方法被调用，JVM都会在当前线程的栈帧中保存方法出口。这个方法出口通常是指向调用该方法的指令的下一条指令的地址。
3. **本地方法栈**：本地方法既是native方法，是用于调用C/C++代码而写，本地方法栈既是本地方法存储的内存位置，是每个线程私有的。
4. **程序计数器**：每个线程都有一个私有的程序计数器，主要用于标记线程执行的位置，也可以称为当前线程执行的字节码的行号指示器。
5. **方法区（元空间）**：被所有线程共享，在Java 7及之前的版本，方法区是用于存储类信息、常量、静态变量等的区域。在Java虚拟机规范中，并未规定方法区的具体实现方式，但大多数JVM实现都将方法区视为堆的一部分。因此，方法区是线程共享的，所有线程都可以访问其中的类信息和静态变量。 在Java 8及以后的版本中，元空间取代了方法区的概念。元空间的设计目的是为了解决方法区的一些性能和内存管理的问题。元空间同样是线程共享的，不同的线程可以同时访问元空间中的类信息。    但如果说静态变量是个对像，则在方法区中存放的是该对象在堆中的地址。      



## **补充一个问题：**

### **在minor gc过程中对象挪动后，引用如何修改？**

对象在堆内部挪动的过程其实是复制，原有区域对象还在，一般不直接清理，JVM内部清理过程只是将对象分配指针移动到区域的头位置即可，比如扫描s0区域，扫到gcroot引用的非垃圾对象是将这些对象**复制**到s1或老年代，最后扫描完了将s0区域的对象分配指针移动到区域的起始位置即可，s0区域之前对象并不直接清理，当有新对象分配了，原有区域里的对象也就被清除了。

minor gc在根扫描过程中会记录所有被扫描到的对象引用(在年轻代这些引用很少，因为大部分都是垃圾对象不会扫描到)，如果引用的对象被复制到新地址了，最后会一并更新引用指向新地址。

这里面内部算法比较复杂，感兴趣可以参考R大的这篇文章：

https://www.zhihu.com/question/42181722/answer/145085437

https://hllvm-group.iteye.com/group/topic/39376#post-257329

JVM内存参数设置

------

​    ![0](2%E3%80%81JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/77391)

Spring Boot程序的JVM参数设置格式(Tomcat启动直接加在bin目录下catalina.sh文件里)：

```
java -Xms2048M -Xmx2048M -Xmn1024M -Xss512K -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -jar microservice-eureka-server.jar
```

**-Xss**：每个线程的栈大小

**-Xms**：设置堆的初始可用大小，默认物理内存的1/64 

**-Xmx**：设置堆的最大可用大小，默认物理内存的1/4

**-Xmn**：新生代大小

**-XX:NewRatio**：默认2表示新生代占年老代的1/2，占整个堆内存的1/3。

**-XX:SurvivorRatio**：默认8表示一个survivor区占用1/8的Eden内存，即1/10的新生代内存。

关于元空间的JVM参数有两个：-XX:MetaspaceSize=N和 -XX:MaxMetaspaceSize=N

**-XX：MaxMetaspaceSize**： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。

**-XX：MetaspaceSize**： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M左右，达到该值就会触发full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。这个跟早期jdk版本的**-XX:PermSize**参数意思不一样，-**XX:PermSize**代表永久代的初始容量。

由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大，对于8G物理内存的机器来说，一般我会将这两个值都设置为256M。

**StackOverflowError**示例：

```java
// JVM设置  -Xss128k(默认1M)
public class StackOverflowTest {
    
    static int count = 0;
    
    static void redo() {
        count++;
        redo();
    }

    public static void main(String[] args) {
        try {
            redo();
        } catch (Throwable t) {
            t.printStackTrace();
            System.out.println(count);
        }
    }
}

运行结果：
java.lang.StackOverflowError
	at com.tuling.jvm.StackOverflowTest.redo(StackOverflowTest.java:12)
	at com.tuling.jvm.StackOverflowTest.redo(StackOverflowTest.java:13)
	at com.tuling.jvm.StackOverflowTest.redo(StackOverflowTest.java:13)
   ......
```

**结论：**

-Xss设置越小count值越小，说明一个线程栈里能分配的栈帧就越少，但是对JVM整体来说能开启的线程数会更多

# **JVM内存参数大小该如何设置？**

JVM参数大小设置并没有固定标准，需要根据实际项目情况分析，给大家举个例子

# **日均百万级订单交易系统如何设置JVM参数**

​    ![0](2%E3%80%81JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/94575)

**结论：**通过上面这些内容介绍，大家应该对JVM优化有些概念了，就是尽可能让对象都在新生代里分配和回收，尽量别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收。

