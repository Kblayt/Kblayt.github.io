---
title: 并发编程与多线程
date: 2022-10-28 19:08:51
categories:
    - Java
tags:
    - 多线程
    - 并发编程 
---





# 1、什么是并发与并行

并行：之两个或多个时间在**同一时刻**发生（同时发生）

并发：之两个或多个时间在**同一个时间段内**发生。

![image-20221103140028421](image-20221103140028421.png)

# 2、什么是进程、线程

**进程：**

- 进程是正在运行的程序的实例。
- 进程是线程的容器，即一个进程中可以开启多个线程。
- 比如打开一个浏览器、打开一个word等操作，都会创建进程。

**线程：**

- 线程是进程内部的一个独立执行单元。
- 一个进程可以同时并发运行多个线程。
- 比如进程可以理解为医院，线程是挂号、就诊、缴费、拿药等业务活动

**多线程**：多个线程并发执行

# 3、线程创建

Java中线程有四种创建方式：

- 继承Thread类
- 实现Runnable接口
- 实现Callable接口
- 线程池

## 3.1、继承Thread类

**MyThread.class**

```
public class MyThread extends Thread{
	
	public void run(){
		for(int i<0; i<10; i++){
			System.out.println("myThread执行了:"+new Date().getTime());
		}
	}
	
}
```

**ThreadCreateDemo.class:**

```
public class ThreadCreateDemo{

	public static void main(String[] args){
		//1.创建自定义线程类实例
		MyThread myThread = new MyThread();
		//2.启动线程
		myThread.start();
		//3.在main主线程打印行信息
		for(int i=0; i<10; i++){
			System.out.println("main主线程执行了："+new Date().getTime());
		}
	}

}
```

## 3.2、实现Runnable接口

**MyRunnable.class:**

```
public class MyRunnable implements Runnable{
	public void run(){
		for(int i=0; i<10; i++){
			System.out.println(Thread.currentThread().getName()+"执行时间是："+new Date().getTime()+";执行次数是："+i)
		}
	}
}
```

**ThreadCreateDemo.class:**

```
public class ThreadCreateDemo{

	public static void main(String[] args){

		for(int i=0; i<10; i++){
			System.out.println("main主线程执行了："+new Date().getTime());
		}
		//通过thread类执行MyRunnable类
		Thread thread = new Thread(new MyRunnable(),"MyRunnable");
		thread.start();
	}

}
```

## 3.3、实现Callable接口

Callable需要使用FutureTask类帮助执行，FutureTask类结构如下：

![image-20221103142346879](image-20221103142346879.png)

Future接口：

- 判断任务是否完成：isDone()
- 能够终端任务：cancel()
- 能够获取任务执行结果：get()

**MyCallable.class:**

```
public class MyCallable implements Callable<String>{
	public String call() throws Exception{
		for(int i=0; i<10; i++){
			System.out.println(Thread.currentThread().getName()+"执行时间是："+new Date().getTime()+"；循环次数是："+i);
		}
		return "MyCallable接口执行完成";
	}
}
```

**ThreadCreateDemo.class:**

```
public class ThreadCreateDemo{

	public static void main(String[] args){
		//1、创建FutureTask实例，创建MyCallable实例
		FutureTask<String> task = new FutureTask<String>(new MyCallable());
		//2、创建Thread实例，执行FutureTask
		Thread thread = new Thread(task,"MyCallable");
		thread.start();
		//3、在主线程打印信息
		for(int i=0; i<10; i++){
			System.out.println("main主线程执行了："+new Date().getTime());
		}
		//4、获取并打印MyCallable执行结果
		try{
			String result = task.get();
			System.out.println("MyCallable执行结果是："+result)
		}catch (ExecutionException e){
			e.printStackTrace();
		}
		
	}

}
```

## 3.4、线程池-Executor

**线程池线类关系图**：

![img](1378444-20191125143829962-1722847086.png)

**MyRunnable.class:**

```
public class MyRunnable implements Runnable{
	public void run(){
		for(int i=0; i<10; i++){
			System.out.println(Thread.currentThread().getName()+"执行时间是："+new Date().getTime()+";执行次数是："+i)
		}
	}
}
```

**ThreadCreateDemo.class:**

```
public class ThreadCreateDemo{

	public static void main(String[] args){
		//1.使用Executors获取线程池对象
		ExecutorService executorService = Executors.newFixedThreadPool(10);//(10个线程)
		//2.通过线程池对象获取线程并执行MyRunnable实例
		executorService.execute(new MyRunnable());
		//3.主线程打印信息
		for(int i=0; i<10; i++){
			System.out.println("main主线程执行了："+new Date().getTime());
		}
	}

}
```

## 3.5、小结

### 3.5.1、实现接口和继承Thread类比较

- 接口更高适合多个相同的程序代码的线程去共享同一个资源。
- 接口可以避免java中的单继承的局限性。
- 接口代码可以被多个线程共享，代码和线程独立。
- 线程池只能放入实现Runnable或Callable接口的线程，不能直接放入继承Thread的类。

扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。

### 3.5.2、Runnable和Callable接口比较

**相同点：**

- 两者都是借口。
- 两者都可用来编写多线程程序。
- 两者都需要调用Thread.start()启动线程。

**不同点：**

- 实现Callable接口的线程能返回执行结果，而实现Runnable接口的线程不能返回结果。
- Callable接口的call()方法允许抛出异常，而Runnable接口的run()方法不允许抛异常。
- 实现Callable接口的线程可以调用Future.cancel取消执行，而实现Runnable接口的线程不能

**注意点：**

- Callable接口支持返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞主线程直到获取“将来”结果，当不调用此方法时，主线程不会阻塞。

# 4、线程生命周期

![image-20221103152613817](image-20221103152613817.png)

## 4.1、新建

- new关键字创建了一个线程之后，该线程就处于新建状态。
- JVM为线程分配内存，初始化成员变量值。

## 4.2、就绪

- 当线程对象调用了start()方法之后，该线程处于就绪状态。
- JVM为线程创建方法栈和程序计数器，等待线程调度器调度。

## 4.3、运行

- 就绪状态的线程获得CPU资源，开始运行run()方法，该线程进如运行状态

## 4.4、阻塞

当发生如下情况时，线程将会进入阻塞状态

- 线程调用sleep()方法主动放弃所占用的处理器资源
- 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞
- 线程试图获得一个同步锁（同步监视器），但该同步锁正在被其他线程所持有。
- 线程在等待某个通知（notify）
- 程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应尽量避免使用该方法

## 4.5、死亡

线程会以如下三种方式结束，结束后就处于死亡状态：

- run()或call()方法执行完成，线程正常结束。
- 线程抛出一个未捕获的Exception或Error。
- 调用该线程stop()方法来结束该线程，该方法容易导致死亡锁，不推荐使用。

# 5、线程安全问题

## 5.1、什么是线程安全

如果有多个线程同时运行同一个实现了Runnable接口的类，程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。反之，则是线程不安全的。

## 5.2、问题演示

**Ticket.class**

```
public class Ticket implements Runnable{
	private int ticketNum = 100;
	
	public void run(){
		while(true){
			if(ticketNum >0){
				try{
					Thread.sleep(100);
				}catch(InterruptedException e){
					e.printStackTrace();
				}
				//2.打印进程号和票号，票数减1
				String name = Thread.currentThread().getName();
				System.out.printLn("线程："+name+"售票："+ticketNum--)
			}
		}
	}
}
```

**TicketDemo.class**

```
public class TicketDemo{
	public static void main(String[] args){
		Ticket ticket = new Ticket();
		Thread thread1 = new Thread(ticket,"窗口1");
		Thread thread2 = new Thread(ticket,"窗口2");
		Thread thread3 = new Thread(ticket,"窗口3");
		
		thread1.start();
		thread2.start();
		thread3.start();
	}
}
```

程序出现了两个问题：

1、相同的票数，比如5这张票被卖了两回。

2、不存在的票，比如0票与-1票，是不存在的。

## 5.3、问题分析

线程安全问题都是由全局变量及静态变量引起的。

若每个线程对全局变量、静态变量只读，不屑，一般来说，这个变量是线程安全的。

若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。

综上所述，线程安全问题根本原因：

- 多个线程在操作共享的数据。
- 操作共享数据的线程代码有多条。
- 多个线程对共享数据有些操作。

## 5.4、问题解决-线程同步

​	要解决以上线程问题，只要在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。

​	为了保证每个现车给都能正常执行共享资源操作，Java引入了7中线程同步机制：

- 同步代码块（synchronized）
- 同步方法（synchronized）
- 同步锁（ReentrantLock）
- 特殊域变量（volatile）
- 局部变量（ThreadLocal）
- 阻塞队列（LinkedBloclingQueue）
- 原子变量（Atomic*）

### 5.4.1、同步代码块的方式（synchronized）

```
public class Ticket implements Runnable{
	private int ticketNum = 100;
	private Object obj = new Object();
	
	public void run(){
		while(true){
			synchronized(obj){
				if(ticketNum >0){
					try{
						Thread.sleep(100);
					}catch(InterruptedException e){
						e.printStackTrace();
					}
					//2.打印进程号和票号，票数减1
					String name = Thread.currentThread().getName();
					System.out.printLn("线程："+name+"售票："+ticketNum--)
				}
			}

		}
	}
}
```

- **同步锁是自定义的obj对象**
- **这种方式会将多线程变为单线程**

### 5.4.2、同步方法的方式（synchronized）

```
public class Ticket implements Runnable{
	private int ticketNum = 100;
	
	public void run(){
		while(true){
			saleTicket();
		}
	}
	
	private synchronized void saleTicket(){
		if(ticketNum >0){
			try{
				Thread.sleep(100);
			}catch(InterruptedException e){
				e.printStackTrace();
			}
			//2.打印进程号和票号，票数减1
			String name = Thread.currentThread().getName();
			System.out.printLn("线程："+name+"售票："+ticketNum--)
		}
	}
	
}
```

- 对于非static方法，同步锁就是this。
- 对于static方法，同步锁时当前方法所在类的字节码对象(类名.class)

### 5.4.3、同步锁方式（ReentrantLock）

**同步锁：**

java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作，同步代码块同步方法具有的功能Lock都有，除此之外更加强大，更提现面向对象。

**同步锁方法：**

```
public void lock():加同步锁。
public void unlock():释放同步锁。
```

```
public class Ticket implements Runnable{
	private int ticketNum = 100;
	private Lock lock = new ReentrantLock(true);//参数是是否公平锁：true是公平锁，多个线程都公平拥有执行权。false非公平，独占锁。
	
	public void run(){
		while(true){
			lock.lock();
			try{
				if(ticketNum >0){
					try{
						Thread.sleep(100);
					}catch(InterruptedException e){
						e.printStackTrace();
					}
				//2.打印进程号和票号，票数减1
				String name = Thread.currentThread().getName();
				System.out.printLn("线程："+name+"售票："+ticketNum--)
				}
			} finally{
				lock.unlock();
			}
		}
	}	
	
}
```

## 5.5、小结

Synchronized和Lock区别

- synchronized是java内置关键字，在jvm层面，lock是个java类。
- synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁。
- synchronized会自动释放锁（a线程执行完同步代码会释放锁，b线程执行过程中发生异常会释放锁），Lock需要在finally中手动释放锁（unlock()方法释放锁），否则容易造成线程死锁。
- 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了。
- synchronized的锁可重入、不可中断、非公平、而Lock锁可重入、可判断、可公平（两者皆可）
- Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。

# 6、线程死锁

## 6.1、什么是死锁

​	多线程以及多进程改善了系统资源的利用率并提高了系统的处理能。然而，并发执行也带来了新的问题——死锁。

​	所谓死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力所用，这些进程都将无法向前推进。

![image-20221103165227368](image-20221103165227368.png)

## 6.2、死锁产生的必要条件

​	以下这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要以下条件之一不满足，就不会发生死锁。

### 6.2.1、互斥条件

​	进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。

### 6.2.2、不可剥夺条件

​	进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放）。

### 6.2.3、请求与保持条件

​	进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。

### 6.2.4、循环等待条件

​	存在一种进程资源的循环等待链，链中没有给进程已获得的资源同时被链中下一个进程锁请求。即存在于给处于等待状态的进程集合{p1,p1...,pn},其中pi等待的资源被p(i+1)占有（i0，1，...，n-1），pn等待的资源被p0占有，如图：

![循环等待](image-20221103165844699.png)

![满足条件但无死循环](image-20221103165935140.png)

## 6.3、死锁处理

### 6.3.1、死锁预防

- 预防思索：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生。
- 避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全的状态，从而避免死锁的发生。
- 检测死锁：允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。
- 解除死锁：当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来。

#### 6.3.1.1、破坏”互斥“条件

”互斥条件“是无法破坏的，因此，在思索预防里主要是破坏其他几个必要条件，而不去涉及破坏”互斥“条件。

#### 6.3.1.2、破坏”占有并等待“条件

破坏”占有并等待“条件，就是在系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，组织进程在持有资源的同时申请其他资源。

- 方法一：一次性分配资源，即创建进程时，要求它申请所需要的全部资源，系统或满足其所有要求，或什么也不给它。
- 方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源 s 时，须先把它先前占有的资源 R 释放掉，然后才能提出对 s 的申请面积十它可能很快又要用到资源 R 。

#### 6.3.1.3、破坏”不可抢占“条件

破坏”不可抢占“条件就是允许资源实行抢夺。

- 方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。
- 方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。之后任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。

#### 6.3.1.4、破坏”循环等待“条件

破环”循环等待“条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。

### 6.3.2、死锁避免

​	避免死锁不严格限制产生死锁的必要条件的存在，因为即使死锁的必要条件存在，也不一定发生死锁。

#### 6.3.2.1、有序资源分配发

该算法实现步骤如下：

- 必须为所有资源统一编号，例如打印机为1、传真机为2、磁盘为3等
- 同类资源必须一次申请完，例如打印机和传真机一般为同一个机器，必须同时申请
- 不同类资源必须按顺序申请

例如：有两个进程P1和P2，有两个资源R1和R2

P1请求资源：R1、R2

P2请求资源：R1、R2

这样就破坏了环路条件，避免了死锁的发生。

#### 6.3.2.2、银行家算法

​	银行家算法（Banker's Algorithm）是一个避免死锁（Deadlock）的著名算法，是由艾兹格.迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁的算法。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。流程图如下：

![image-20221103180400921](image-20221103180400921.png)

​	银行家算法的基本思想是分配资源之前，判断系统是否是安全的。若是，才分配。它是最具有代表性的避免死锁的算法。

设进程i提出请求REQUEST[i],则银行家算法按如下规则进行判断。

1. 如果REQUEST[i]<=NEED[i,j],则转②。否则，出错。

2. 如果REQUEST[i]<=AVAILABLE[i,j],则转③。否则，等待。

3. 系统试探分配资源，修改相关数据：

   AVAILABLE[i]  -= REQUEST[i];//可用资源数-请求资源数

   ALLOCATION[i] += REQUEST[i];//已分配资源数+请求资源数

   NEED[i] -= REQUEST[i];//需要资源数-请求资源数

4. 系统执行安全性检查，如果安全，则分配成立；否则试探险性分配作废，系统恢复原装，进程等待。

#### 6.3.2.3、顺序枷锁

​	当个多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。

​	例如一下两个线程就会死锁：

Thread1：

```
lock A (when C locked)
lock B (when C locked)
wait for C
```

Thread2：

```
wait for A
wait for B
lock C (when A locked)
```

​	如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。

​	例如以下两个线程就不会死锁

Thread1：

```
lock A
lock B
lock C
```

Thread2：

```
wait for A
wait for B
wait for C
```

​	按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要事先知道所有可能会用到的锁，但总是有些时候是无法预知的，所有该种方式只适合特定场景。

#### 6.3.2.4、限时加锁

​	限时加锁是线程在尝试获取锁的时候加一个超时时间，若超过这个时间则放弃对该所请求，并回退并释放所有已经获得的锁，然后等待一段随机的时间再重试

​	以下是一个例子，展示了两个线程以不同的顺序尝试获取相同的两个锁，在发生超时后回退并重试的场景：

```
Thread1 locks A
Thread2 locks B
Thread1 attempts to lock B but is blocked
Thread2 attempts to lock A but is blocked
Thread1's lock attempt on B times out
Thread1 backs up and releases A as well
Thread1 waits randomly(e.g.257millis) before retrying
Thread2's lock attempt on A times out
Thread2 backs up and releases B as well
Thread2 waits randomly(e.g.43millis) before retrying
```

​	在上面的例子中，线程2比线程1早200ms进行重试加锁，因此它可以先成功地获取到两个锁。这时，线程1尝试获取锁A并且处于等待状态。当线程2结束时，线程1也可以顺利的获得这两个锁。

​	这种方式有两个缺点：

- 当线程数量少时，该种方式可避免死锁，但当线程数量过多，这些线程的加锁时限相同的概率就会高很多，可能会导致超时后重试的死循环。
- Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具。

### 6.3.3、死锁检测

​	预防和避免死锁系统开销大且不能充分利用资源，更好的方法是不采取任何限制性措施，而是提供检测和解脱死锁的手段，这就是死锁检测和恢复。

死锁检测数据结构：

- E是现有资源向量（existing resource vector），代码每种已存在资源的总数。
- A是可用资源向量（available resource vector），那么Ai表示当前可供使用的资源数（即没有分配的资源）
- C是当前分配矩阵（current allocation matrix），C的第i行代表Pi当前所持有的每一种类型资源的资源数
- R是请求矩阵（request matrix），R的每一行代表P所需要的资源的数量

![image-20221104093135512](image-20221104093135512.png)

死锁检测步骤：

1）寻找一个没有结束标记的进程Pi，对于它而言R矩阵的第i行向量小于或等于A。

2）如果找到了这样一个进程，执行该进程，然后将C矩阵的第i行向量加到A中，标记该进程，并转到第1步。

3）如果没有这样的进程，那么算法终止

4）算法结束时，所有没有标记过的进程都是死锁进程。

### 6.3.4、死锁恢复

**利用抢占恢复：**

- 临时将某个资源从它的当前所属进程转移到另一个进程。
- 这种做法很可能需要人工干预，主要做法是否可行需取决于资源本身的特性。

**利用滚回恢复：**

- 周期性的将进程的状态进行备份，当发现进程死锁后，根据备份将该进程复位到一个更早的，还没有取得所需的资源的状态，接着就把这些金源分配给其他死锁进程。

**通过杀死进程恢复：**

- 最直接简单的方式就是杀死一个或若干个进程。
- 尽可能保证杀死的进程可用从头再来而不带来副作用。















