---
title: 多线程和网络编程
date: 2022-10-21 10:41:21
categories:
    - Java
tags:
    - Java
    - 多线程
    - 网络编程
---
# 多线程（Thread）

## 1.什么是线程、主线程和其他子线程

线程是程序执行的一条路径，一个进程中可以包含多条线程

多线程并发执行可以提高程序的效率，可以同时完成多项工作

main()方法即为主线程入口

## 2.多线程并行和并发的区别

并行是指两个任务同时进行，就是甲任务进行的同时，乙任务也在进行。（需多核CPU）

并发是指两个任务都请求运行，而处理器只能接受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。

## 3.Java程序运行原理和JVM的启动是多线程的吗？

A：Jva程序运行原理

Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。该进程会自动启动一个”主线程“，然后主线程去调用某个类的main方法。

B：JVM的启动是多线程的吗

JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。

## 4.多线程程序实现的方式

①继承Thread(无返回值)

定义类继承Thread

重写run()方法

把新线程要做的事写在run()方法中

创建线程对象

开启新线程，内部会自动执行run()方法

```
public class ThreadTest {
    public static void main(String[] args) {
        MyThread mt = new MyThread();                   //4.创建Thread类的子类对象
        mt.start();                                     //5.开启线程

        for (int i = 0 ; i < 1000; i++){
            System.out.println("bbbbbbb");
        }
    }

}
```

```
public class MyThread extends Thread{               //1.继承Thread
    public void run(){                              //2.重写run方法
        for (int i=0; i<1000; i++){                 //3.将要执行的代码写在run方法中
            System.out.println("aaaaaaaa");
        }
    }
}
```

②实现Runnable接口(无返回值)

定义实现Runnable接口

实现run()方法

把新线程要做的事写在run()方法中

创建自定义的Runnable的子类对象

创建Thread对象，传入Runnable

调用start()开启新线程，内部会自动调用Runnable的run()方法

```
public class ThreadTest {

    public static void main(String[] args) {
        MyRunnable mr = new MyRunnable();            //4.创建Runnable的子类对象
        Thread t  = new Thread(mr);                  //5.将子类对象当作参数传递给Thread的构造函数
        t.start();                                   //6.开启线程

        for (int i = 0 ; i < 1000; i++){
            System.out.println("bbbbbbb");
        }
    }
}

```

```
public class MyRunnable implements Runnable{        //1.定义一个类实现Runnable
    @Override
    public void run() {                             //2.重写run方法
        for (int i=0; i<1000; i++){                 //3.将要执行的代码写在run方法中
            System.out.println("aaaaaaaa");
        }
    }
}
```

③Callable方式(有返回值)

## 5.两种方式的区别

查看源码的区别：

①继承Thread：由于子类重写了Thread类的run()，当调用start()时，直接找子类的run()方法

②实现Runnable：构造函数中传入了Runnable的引用，成员变量记住了它，start()调用run()方法时内部判断成员变量Runnable的引用是否为空，不为空编译时看的时Runnable的run()，运行时执行的是子类的run()方法。

继承Thread

好处是：可以直接使用Thread类中的方法，代码简单

弊端是：如果已经有了父类，就不能用这种方法

实现Runnable接口

好处是：即使自己定义的线程类有了父类也没关系，因为有了父类也可以实现接口，而且接口是可以多实现的

弊端是：不能直接使用Thread中的方法需要先获取到线程对象后，才能得到Thread的方法，代码复杂

## 6.匿名内部类实现线程的两种方式

①继承(extends)Thread类

```
public class Demo4 {
    public static void main(String[] args) {
        new Thread(){                                       //1.继承Thread类
            public void run() {                             //2.重写run方法
                for (int i = 0; i < 1000; i++) {            //3.将执行的代码写入run方法中
                    System.out.println("aaaaaaaaaaaaa");
                }
            }
        }.start();                                          //4.开启线程
    }
}
```

②实现(implement)Runnable接口（可实现数据共享）

```
public class Demo4 {
    public static void main(String[] args) {
        new Thread(new Runnable(){                          //1.将Runnable的子类对象传递给Thread的构造方法
            public void run(){                              //2.重写run方法
                for (int i = 0; i < 1000; i++) {            //3.将执行的代码写入run方法中
                    System.out.println("bbbbbbbbbb");       
                }
            }
        }).start();                                         //4.开启线程
    }
}

```

③(有返回值)

## 7.线程的getName()、setName()、currentThread()方法

currentThread()方法用于Runnable中，使之可以顺利的执行getName()、setName()方法。

## 8.休眠线程

Thread.sleep(毫秒,纳秒)，控制当前线程休眠若干毫秒1s=1000毫秒=1000*1000*1000纳秒

## 9.守护线程



## 10.线程的状态转换(五个状态)



## 11.线程调度

void setPriority(int newPriority)

static void sleep(long millis)

void join()			强制

static void yield()		”礼让“

void interrupt()

## 12.锁synchronized

①public synchronized void 方法名(){



}



②同步代码块

synchronized（this）{

//所控制的变量或代码块

}

# 网络编程（socket）(传输层）（TCP/IP）

## 1.基础原理（7层模型）

## 2.什么是Socket

流式套接字（SOCK_STREAM）

面向链接、可靠的数据传输服务，基于TCP协议

数据报式套接字（SOCK_DGRAM）

无连接服务(UDP)

原始套接字（SOCK_RAW）

操作下层

传输层的API

## 3.java.net包

Socket

ServerSocket

DatagramPacket

DatagramSocket

InetAddress

...

## 4.基于TCP协议的socket网络编程一般可以分为以下几个步骤

<C/S>模式

①创建Client端和Server端两个Socket对象，对于Client端时Socket对象、对于Server端是ServerSocket对象

②在Client端和Server端之间建立连接

③在输入和输出之间借助数据流来传递信息

④关闭所有数据流和Socket

## 5.socket中实现对象的传输

借助于序列化和反序列化就能实现

![](WEBRESOURCE97f71c4a1f3001729950f4a437554737.png)

## 6.多线程处理多请求

借助多线程，实现多客户端与服务器网络通信



