---
title: 算法与数据结构-基础
date: 2023-12-19 17:59:50
categories:
    - 数据结构与算法
tags:
    - 数据结构与算法
---

# 排序算法

## 选择排序

时间复杂度:

- 最差情况：((n-1)+1)*(n-1)/2=($n^2$-n)/2=o($n^2$)
- 最优情况：

空间复杂度：o(1)

```java
package org.example.algorithm.sortingAlogrithm;

public class SelectionSort {

    public static void selectionSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }

        for (int i = 0; i < arr.length; i++) {
            //设定最小下标
            int minIndex = i;
            for (int j = i + 1; j < arr.length; j++) {
                minIndex = arr[minIndex] < arr[j] ? minIndex : j;
            }
            swap(arr, minIndex, i);
        }
    }

    public static void swap(int[] arr, int minIndex, int i) {
        int template = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = template;
    }

    public static void main(String[] args) {

        //int[] arr = {4, 2, 46, 2, 6, 56, 34, 7};
        //int[] arr = {4,34, 46, 245, 66, 456, 4534, 7};
        //int[] arr = {4, 289, 4345, 2, 689, 56, 454, 78};
        //int[] arr = {4, 2, 4345, 24, 6, 56, 34, 79};
        int[] arr = {4, 2876, 46, 287, 6, 5636, 34, 73};
        selectionSort(arr);
        System.out.println(arr);

    }

}
```

## 冒泡排序

时间复杂度:

- 最差情况：((n-1)+1)*(n-1)/2=($n^2$-n)/2=o($n^2$)
- 最优情况：

空间复杂度：o(1)

```java
package org.example.algorithm.sortingAlogrithm;

import java.util.Arrays;

public class BubbleSort {

    public static void bubbleSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        //为什么i不从0开始计算？
        //因为如果从0开始，此方法为冒泡最大数，一轮冒泡过后最大数便已经确定了，如果从零开始会出现多余的比较。
        //如果这继承冒泡最小数，则i，j情况与下列代码相反。
        for (int i = arr.length - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (arr[j] > arr[j+1]) {
                    swap(arr,j,j+1);
                }
            }
        }
    }

    public static void swap(int[] arr,int i,int j){
        arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    }

    public static void main(String[] args) {

        //int[] arr = {4, 2, 46, 2, 6, 56, 34, 7};
        //int[] arr = {4,34, 46, 245, 66, 456, 4534, 7};
        //int[] arr = {4, 289, 4345, 2, 689, 56, 454, 78};
        int[] arr = {4, 2, 4345, 24, 6, 56, 34, 79};
        //int[] arr = {4, 2876, 46, 287, 6, 5636, 34, 73};
        bubbleSort(arr);
        System.out.println(Arrays.toString(arr));

    }

}
```

## 运算符

### 逻辑运算符

![image-20231220170610517](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80/image-20231220170610517.png)

### 位运算符

![image-20231220170627375](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80/image-20231220170627375.png)

利用异或^进行数值交换原理

![image-20231220121211820](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80/image-20231220121211820.png)

问题一：当一个数组中，有一种数出现奇数次，另外两种数出现偶数次，请问如何在空间复杂度为o(1)，时间复杂度为o(n)的情况下找出该出现奇数次的数？

```java
//思路：将数组中的数全部进行异或运算，得到的数便是那一个出现奇数次的数。例如数组[a,a,b,b,c,c,c]
```

问题二：接问题一，如果有两种数出现奇数次，其它数出现偶数次，应该如何在空间复杂度为o(1)，时间复杂度为o(n)的情况下找出这两种出现奇数次的数？

```java
//思路：利用位运算分组求异或，则分别能得出两这两个奇数

package org.example.algorithm.sortingAlogrithm;

public class printTimesOddTimes {

    public static void printOddTimesNum2(int[] arr) {
        int eor = 0;
        for (int curNum : arr) {
            eor ^= curNum;
        }

        //把一个不为零的数最右侧的1提取出来
        /**
         * 例如：
         * eor：1010111100
         * ~eor：0101000011
         * ~eor+1：0101000100
         * rightOne：0000000100
         */
        int rightOne = eor & (~eor + 1);

        int onlyOne = 0;
        for (int cur : arr) {
            //或者==rightOne 或者!=0
            if ((cur & rightOne) == 0) {
                onlyOne ^= cur;
            }
        }
        System.out.println(onlyOne + " " + (eor ^ onlyOne));
    }

    public static void main(String[] args) {
        int[] arr = {1,1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,5,5};

        printOddTimesNum2(arr);
    }

}
```

## 插入排序

时间复杂度:

- 最差情况：((n-1)+1)*(n-1)/2=($n^2$-n)/2=o($n^2$)
- 最优情况：

空间复杂度：o(1)

```JAVA
public class InsertionSort {

    public static void insertionSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }

        for (int i = 1; i < arr.length; i++) {
            for (int j = i; j > 0 && arr[j] < arr[j - 1]; j--) {
                swap(arr, j, j - 1);
            }
        }
    }

    public static void swap(int[] arr, int i, int j) {
        arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    }

    public static void main(String[] args) {
        //int[] arr = {4, 2, 46, 2, 6, 56, 34, 7};
        //int[] arr = {4,34, 46, 245, 66, 456, 4534, 7};
        //int[] arr = {4, 289, 4345, 2, 689, 56, 454, 78};
        int[] arr = {4, 2, 4345, 24, 6, 56, 34, 79};
        //int[] arr = {4, 2876, 46, 287, 6, 5636, 34, 73};
        insertionSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```

## 二分法

时间复杂度：o($log_2^N$)

情景

1. 在一个有序数组中，找某个数是否存在。
2. 在一个有序数组中，找>=某个数最左侧的位置
3. 局部最小值问题（arr、无序、相邻数一定不相等）

## 对数器的概念和使用 

1，有一个你想要测的方法a
2，实现复杂度不好但是容易实现的方法b
3，实现一个随机样本产生器
4，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。
5，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者方法b
6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。

## 递归

时间复杂度：

​	master公式：T(N)=a*T($N/b$)+o($n^d$) (a为子函数调了主函数多少次，b为子问题规模，d为子函数的时间复杂度指数)(子规模要相等才满足此公式)

​	如果：$log_b^a$<d则时间复杂度为o($N^d$)。

​	如果：$log_b^a$>d则时间复杂度为o(N\^$log_d^a$)。

​	如果：$log_b^a$=d则时间复杂度为o($N^d$*$log_2^N$)。

```java
public class getMax {

    public static int getMax(int[] arr){
        return process(arr,0, arr.length-1);
    }

    // arr[L...R]范围上求最大值
    private static int process(int[] arr,int L,int R) {
        if (L == R){
            return arr[L];
        }
        int mid= L+((R-L)>>1); //一般是(L+R)/2但是L+R可能会溢出，导致出现负数
        int leftMax = process(arr, L, mid);
        int rightMax = process(arr,mid+1,R);
        return Math.max(leftMax,rightMax);

    }

    public static void main(String[] args) {
        int[] arr = {1,3,5,8,7,6,9,4,8,5};
        //int[] arr = {4, 2, 46, 2, 6, 56, 34, 7};
        //int[] arr = {4,34, 46, 245, 66, 456, 4534, 7};
        //int[] arr = {4, 289, 4345, 2, 689, 56, 454, 78};
        //int[] arr = {4, 2, 4345, 24, 6, 56, 34, 79};
        //int[] arr = {4, 2876, 46, 287, 6, 5636, 34, 73};
        System.out.println(getMax(arr));
       
    }

}
```

## 归并排序

1）整体就是一个简单递归，左边排好序、右边排好序、让其整体有序
2）让其整体有序的过程里用了排外序方法
3）利用master公式来求解时间复杂度
4）归并排序的实质

时间复杂度：适用master公式，该方法a=2,b=2,d=1,所以T(N)=2T(N/2)+o(N)，因为$log_a^b$=1=d，所以时间复杂度为o(N$log_2^N$)

空间复杂度：o(N)

```java
public class MergeSort {

    public static void mergeSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        process(arr, 0, arr.length - 1);
    }

    public static void process(int[] arr, int L, int R) {
        if (L == R) {
            return;
        }
        int mid = L + ((R - L) >> 1);
        process(arr, L, mid);
        process(arr, mid+1, R);
        merge(arr, L, mid, R);
    }

    public static void merge(int[] arr, int L, int M, int R) {
        int[] help = new int[R - L + 1];
        int i = 0;
        int p1 = L;
        int p2 = M + 1;
        while (p1 <= M && p2 <= R) {
            help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
        }
        while (p1 <= M) {
            help[i++] = arr[p1++];
        }
        while (p2 <= R) {
            help[i++] = arr[p2++];
        }
        for (i = 0; i < help.length; i++) {
            arr[L + i] = help[i];
        }
    }

    public static void main(String[] args) {
        //int[] arr = {4, 2, 46, 2, 6, 56, 34, 7};
        //int[] arr = {4,34, 46, 245, 66, 456, 4534, 7};
        //int[] arr = {4, 289, 4345, 2, 689, 56, 454, 78};
        int[] arr = {4, 2, 4345, 24, 6, 56, 34, 79};
        //int[] arr = {4, 2876, 46, 287, 6, 5636, 34, 73};
        mergeSort(arr);
        System.out.println(Arrays.toString(arr));
    }

}
```

小和问题和逆序对问题
小和问题
在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组 的小和。例子:[1,3,4,2,5] 1左边比1小的数，没有; 3左边比3小的数，1; 4左边比4小的数，1、3; 2左边比2小的数，1; 5左边比5小的数，1、3、4、2; 所以小和为1+1+3+1+1+3+4+2=16

```java
public class MergeSort {

    public static int mergeSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return 0;
        }
        return process(arr, 0, arr.length - 1);
    }

    public static int process(int[] arr, int L, int R) {
        if (L == R) {
            return 0;
        }
        int mid = L + ((R - L) >> 1);
        return process(arr, L, mid) + process(arr, mid + 1, R) + merge(arr, L, mid, R);
    }

    public static int merge(int[] arr, int L, int M, int R) {
        int[] help = new int[R - L + 1];
        int i = 0;
        int p1 = L;
        int p2 = M + 1;
        int res = 0;
        while (p1 <= M && p2 <= R) {
            res += arr[p1] < arr[p2] ? (R - p2 + 1) * arr[p1] : 0;
            help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
        }
        while (p1 <= M) {
            help[i++] = arr[p1++];
        }
        while (p2 <= R) {
            help[i++] = arr[p2++];
        }
        for (i = 0; i < help.length; i++) {
            arr[L + i] = help[i];
        }
        return res;
    }

    public static void main(String[] args) {
        //int[] arr = {4, 2, 46, 2, 6, 56, 34, 7};
        //int[] arr = {4,34, 46, 245, 66, 456, 4534, 7};
        //int[] arr = {4, 289, 4345, 2, 689, 56, 454, 78};
        //int[] arr = {4, 2, 4345, 24, 6, 56, 34, 79};
        int[] arr = {1, 3, 4, 2, 8};
        //int[] arr = {4, 2876, 46, 287, 6, 5636, 34, 73};
        System.out.println(mergeSort(arr));
        System.out.println(Arrays.toString(arr));
    }

}
```

逆序对问题 在一个数组中，左边的数如果比右边的数大，则折两个数
构成一个逆序对，请打印所有逆序 对

## 快速排序

时间复杂度：o($Nlog_2^N$)

空间复杂度：o($log_2^N$)

```java
public class QuickSort {

    public static void quickSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }

    public static void quickSort(int[] arr, int L, int R) {
        if (L < R) {
            swap(arr, L + (int) Math.random() * (R - L + 1), R);
            int[] p = partition(arr, L, R);
            quickSort(arr, L, p[0] - 1);
            quickSort(arr, p[1] + 1, R);
        }
    }

    public static int[] partition(int[] arr, int L, int R) {
        int less = L - 1;
        int more = R;
        while (L < more) {
            if (arr[L] < arr[R]) {
                swap(arr, ++less, L++);
            } else if (arr[L] > arr[R]) {
                swap(arr, --more, L);
            } else {
                L++;
            }
        }
        swap(arr, more, R);
        return new int[] { less + 1, more };
    }

    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    public static void main(String[] args) {

        //int[] arr = {4, 2, 46, 2, 6, 56, 34, 7};
        //int[] arr = {4,34, 46, 245, 66, 456, 4534, 7};
        //int[] arr = {4, 289, 4345, 2, 689, 56, 454, 78};
        //int[] arr = {4, 2, 4345, 24, 6, 56, 34, 79};
        //int[] arr = {4, 2876, 46, 287, 6, 5636, 34, 73};
        //int[] arr = {5,6,8,7,1,2,3,9,8,2,5,8};
        int[] arr = {3,2,1,5,7,6,8,5,8,9,7,4,6,1,9,2,8,5};

        quickSort(arr);
        System.out.println(Arrays.toString(arr));

    }

}
```

## 堆(heap)

![image-20231223122234820](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80/image-20231223122234820.png)

### 大根堆**Max-heap**

时间复杂度：o($log_2^N$)

空间复杂度：o(1)

父节点的值大于或等于子节点的值；

```java
public class heapSort {

    public static void heapSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        //1、便利整个数组，进行大根堆排序
        for (int i = 0; i < arr.length; i++) {
            heapInsert(arr, i);
        }
        //3、获取数组长度
        int size = arr.length;
        //4、交换根节点最叶子节点
        swap(arr, 0, --size);
        while (size > 0) {
            heapify(arr, 0, size);
            swap(arr, 0, --size);
        }
    }

    //大根堆排序
    public static void heapInsert(int[] arr, int index) {
        //2、当节点大于父节点时，进行交换
        while (arr[index] > arr[(index - 1) / 2]) {
            swap(arr, index, (index - 1) /2);
            index = (index - 1)/2 ;
        }
    }

    public static void public class heapSort {

    public static void heapSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        //1、便利整个数组，对新的数进行大根堆排序,相当于不知道后面新增数，对堆进行新增操作
        for (int i = 0; i < arr.length; i++) {
            heapInsert(arr, i);
        }

        //如果知道了所有堆的数据，那么可以用此方法进行大根堆排序
//        for (int i = arr.length-1;i>=0;i--){
//            heapify(arr,i, arr.length);
//        }

        //3、获取数组长度
        int size = arr.length;
        //4、交换根节点最叶子节点
        swap(arr, 0, --size);
        while (size > 0) {
            heapify(arr, 0, size);
            swap(arr, 0, --size);
        }
    }

    //大根堆排序
    public static void heapInsert(int[] arr, int index) {
        //2、当节点大于父节点时，进行交换
        while (arr[index] > arr[(index - 1) / 2]) {
            swap(arr, index, (index - 1) /2);
            index = (index - 1)/2 ;
        }
    }

    public static void heapify(int[] arr, int index, int size) {
        //获取左子节点
        int left = index * 2 + 1;
        //如果计算出的左子节点存在
        while (left < size) {
            //如果右子节点存在并且右子节点大于左子节点，则比较右子节点与根节点
            int largest = left + 1 < size && arr[left + 1] > arr[left] ? left + 1 : left;
            largest = arr[largest] > arr[index] ? largest : index;
            //如果三个值根节点最大则直接跳出
            if (largest == index) {
                break;
            }
            //否则交换根节点和最大值的位置
            swap(arr, largest, index);
            //将index指针指向根节点
            index = largest;
            //计算出该根节点的左子节点
            left = index * 2 + 1;
        }
    }

    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

}
(int[] arr, int index, int size) {
        //获取左子节点
        int left = index * 2 + 1;
        //如果计算出的左子节点存在
        while (left < size) {
            //如果右子节点存在并且右子节点大于左子节点，则比较右子节点与根节点
            int largest = left + 1 < size && arr[left + 1] > arr[left] ? left + 1 : left;
            largest = arr[largest] > arr[index] ? largest : index;
            //如果三个值根节点最大则直接跳出
            if (largest == index) {
                break;
            }
            //否则交换根节点和最大值的位置
            swap(arr, largest, index);
            //将index指针指向根节点
            index = largest;
            //计算出该根节点的左子节点
            left = index * 2 + 1;
        }
    }

    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

}
```



### 小根堆**Min-heap** 

父节点的值小于或等于子节点的值；

```
//代码与大根堆相反
//java中优先队列底层就是小根堆
PriorityQueue<Integer> heap = new PriorityQueue<>();
```



### 堆排序扩展题目

已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过K，并且K相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。

```java
public class sortedArrDistanceLessK {

    public void sortedArrDistanceLessK(int[] arr,int k){
        //默认小根堆
        PriorityQueue<Integer> heap = new PriorityQueue<>();
        int index = 0;
        for (; index <= Math.min(arr.length,k);index++){
            heap.add(arr[index]);
        }
        int i = 0;
        for (;index <arr.length;i++,index++){
            heap.add(arr[index]);
            arr[i] = heap.poll();
        }
        while (!heap.isEmpty()){
            arr[i++] = heap.poll();
        }
    }

}
```

## 比较器Comparator

```java
public class Code03_Comparator {

	public static class Student {
		public String name;
		public int id;
		public int age;

		public Student(String name, int id, int age) {
			this.name = name;
			this.id = id;
			this.age = age;
		}
	}

	public static class IdAscendingComparator implements Comparator<Student> {

		@Override
		public int compare(Student o1, Student o2) {
			return o1.id - o2.id;
		}

	}

	public static class IdDescendingComparator implements Comparator<Student> {

		@Override
		public int compare(Student o1, Student o2) {
			return o2.id - o1.id;
		}

	}

	public static class AgeAscendingComparator implements Comparator<Student> {

		@Override
		public int compare(Student o1, Student o2) {
			return o1.age - o2.age;
		}

	}

	public static class AgeDescendingComparator implements Comparator<Student> {

		@Override
		public int compare(Student o1, Student o2) {
			return o2.age - o1.age;
		}

	}

	public static void printStudents(Student[] students) {
		for (Student student : students) {
			System.out.println("Name : " + student.name + ", Id : " + student.id + ", Age : " + student.age);
		}
	}

	public static void printArray(Integer[] arr) {
		if (arr == null) {
			return;
		}
		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
		System.out.println();
	}

	public static class MyComp implements Comparator<Integer> {

		@Override
		public int compare(Integer o1, Integer o2) {
			return o2 - o1;
		}

	}

	public static void main(String[] args) {
		Student student1 = new Student("A", 2, 23);
		Student student2 = new Student("B", 3, 21);
		Student student3 = new Student("C", 1, 22);

		Student[] students = new Student[] { student1, student2, student3 };

		Arrays.sort(students, new IdAscendingComparator());
		printStudents(students);
		System.out.println("===========================");

		Arrays.sort(students, new IdDescendingComparator());
		printStudents(students);
		System.out.println("===========================");

		Arrays.sort(students, new AgeAscendingComparator());
		printStudents(students);
		System.out.println("===========================");

		Arrays.sort(students, new AgeDescendingComparator());
		printStudents(students);
		System.out.println("===========================");
		System.out.println("===========================");
		System.out.println("===========================");
		System.out.println("===========================");

		PriorityQueue<Student> maxHeapBasedAge = new PriorityQueue<>(new AgeDescendingComparator());
		maxHeapBasedAge.add(student1);
		maxHeapBasedAge.add(student2);
		maxHeapBasedAge.add(student3);
		while (!maxHeapBasedAge.isEmpty()) {
			Student student = maxHeapBasedAge.poll();
			System.out.println("Name : " + student.name + ", Id : " + student.id + ", Age : " + student.age);
		}
		System.out.println("===========================");

		PriorityQueue<Student> minHeapBasedId = new PriorityQueue<>(new IdAscendingComparator());
		minHeapBasedId.add(student1);
		minHeapBasedId.add(student2);
		minHeapBasedId.add(student3);
		while (!minHeapBasedId.isEmpty()) {
			Student student = minHeapBasedId.poll();
			System.out.println("Name : " + student.name + ", Id : " + student.id + ", Age : " + student.age);
		}
		System.out.println("===========================");
		System.out.println("===========================");
		System.out.println("===========================");

		TreeSet<Student> treeAgeDescending = new TreeSet<>(new AgeDescendingComparator());
		treeAgeDescending.add(student1);
		treeAgeDescending.add(student2);
		treeAgeDescending.add(student3);

		Student studentFirst = treeAgeDescending.first();
		System.out.println("Name : " + studentFirst.name + ", Id : " + studentFirst.id + ", Age : " + studentFirst.age);

		Student studentLast = treeAgeDescending.last();
		System.out.println("Name : " + studentLast.name + ", Id : " + studentLast.id + ", Age : " + studentLast.age);
		System.out.println("===========================");

	}

}
```

## 计数排序

```java
public class Code01_CountSort {

	// only for 0~200 value
	public static void countSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		int max = Integer.MIN_VALUE;
		for (int i = 0; i < arr.length; i++) {
			max = Math.max(max, arr[i]);
		}
		int[] bucket = new int[max + 1];
		for (int i = 0; i < arr.length; i++) {
			bucket[arr[i]]++;
		}
		int i = 0;
		for (int j = 0; j < bucket.length; j++) {
			while (bucket[j]-- > 0) {
				arr[i++] = j;
			}
		}
	}

}
```

## 桶排序、基数排序

```java
public class RadixSort {

    // only for no-negative value
    public static void radixSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        radixSort(arr, 0, arr.length - 1, maxbits(arr));
    }

    //找到数组中最大的数，确定从个位数比对到第几位数
    public static int maxbits(int[] arr) {
        int max = Integer.MIN_VALUE;
        for (int i = 0; i < arr.length; i++) {
            max = Math.max(max, arr[i]);
        }
        int res = 0;
        while (max != 0) {
            res++;
            max /= 10;
        }
        return res;
    }


    public static void radixSort(int[] arr, int begin, int end, int digit) {
        final int radix = 10;
        int i = 0, j = 0;

        int[] bucket = new int[end - begin + 1];
        //遍历这个最大的数的位数，从个位数开始遍历
        for (int d = 1; d <= digit; d++) {
            //新建一个辅助记录数组
            int[] count = new int[radix];
            //遍历需要排序的数组
            for (i = begin; i <= end; i++) {
                //获取arr[i]的第d位上的数
                j = getDigit(arr[i], d);
                //生成桶记录
                count[j]++;
            }
            //生成辅助记录数组
            for (i = 1; i < radix; i++) {
                count[i] = count[i] + count[i - 1];
            }
            //需要排序的数组根据辅助记录数组去出桶
            for (i = end; i >= begin; i--) {
                j = getDigit(arr[i], d);
                bucket[count[j] - 1] = arr[i];
                count[j]--;
            }
            //将排序完成的内容返回给arr准备进行下一轮桶排序
            for (i = begin, j = 0; i <= end; i++, j++) {
                arr[i] = bucket[j];
            }
        }
    }

    //获取数x的第d位上的数
    public static int getDigit(int x, int d) {
        //Math.pow(a,b)是a的b次方
        return ((x / ((int) Math.pow(10, d - 1))) % 10);
    }

}

```

## 排序算法的稳定性及其汇总

同样值的个体之间，如果不因为排序而改变相对次序，就是这个排序是有稳定性的；否则就没有。

![image-20231224162427342](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80/image-20231224162427342.png)

**不具备稳定性的排序：**
选择排序、快速排序、堆排序

**具备稳定性的排序：**
冒泡排序、插入排序、归并排序、一切桶排序思想下的排序

当一个对象中存在多个属性，要求按照多个属性进行排序时，如果使用不具备稳定性的排序算法，会打乱第一次排序之后的结果

|          | 时间复杂度    | 空间复杂度   | 稳定性 |
| -------- | ------------- | ------------ | ------ |
| 选择排序 | o($N^2$)      | o(1)         | ×      |
| 冒泡排序 | o($N^2$)      | o(1)         | √      |
| 插入排序 | o($N^2$)      | o(1)         | √      |
| 归并排序 | o($Nlog_2^N$) | o(N)         | √      |
| 快速排序 | o($Nlog_2^N$) | o($log_2^N$) | ×      |
| 堆排序   | o($Nlog_2^N$) | o(1)         | ×      |

目前没有找到时间复杂度O(N*logN)，额外空间复杂度O(1)，又稳定的排序。

## 关于排序算法常见的坑

1，归并排序的额外空间复杂度可以变成O(1)，但是非常难，不需要掌握，有兴趣可以搜“归并排序 内部缓存法”
2，“原地归并排序”的帖子都是垃圾，会让归并排序的时间复杂度变成O(N^2)
3，快速排序可以做到稳定性问题，但是非常难，不需要掌握， 可以搜“01stable sort”
4，所有的改进都不重要，因为目前没有找到时间复杂度O(N*logN)，额外空间复杂度O(1)，又稳定的排序。
5，有一道题目，是奇数放在数组左边，偶数放在数组右边，还要求原始的相对次序不变，碰到这个问题，能实现，但很难，在01stable sort论文中阐述了该问题。这类问题一般在工作中没啥实际意义，不建议学习。

# 哈希表

1）哈希表在使用层面上可以理解为一种集合结构
2）如果只有key，没有伴随数据value，可以使用HashSet结构(C++中叫UnOrderedSet)
3）如果既有key，又有伴随数据value，可以使用HashMap结构(C++中叫UnOrderedMap)
4）有无伴随数据，是HashMap和HashSet唯一的区别，底层的实际结构是一回事
5）使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为O(1)，但是常数时间比较大
6）放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小
7）放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地址的大小

# 有序表

1）有序表在使用层面上可以理解为一种集合结构
2）如果只有key，没有伴随数据value，可以使用TreeSet结构(C++中叫OrderedSet)
3）如果既有key，又有伴随数据value，可以使用TreeMap结构(C++中叫OrderedMap)
4）有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事
5）有序表和哈希表的区别是，有序表把key按照顺序组织起来，而哈希表完全不组织
5）红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同
6）放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小
7）放入哈希表的东西，如果不是基础类型，必须提供比较器，内部按引用传递，内存占用是这个东西内存地址的大小
8）不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度

## 有序表的固定操作

1）void put(K key, V value)：将一个（key，value）记录加入到表中，或者将key的记录更新成value。
2）V get(K key)：根据给定的key，查询value并返回。
3）void remove(K key)：移除key的记录。
4）boolean containsKey(K key)：询问是否有关于key的记录。
5）K firstKey()：返回所有键值的排序结果中，最左（最小）的那个。
6）K lastKey()：返回所有键值的排序结果中，最右（最大）的那个。
7）K floorKey(K key)：如果表中存入过key，返回key；否则返回所有键值的排序结果中，key的前一个。
8）K ceilingKey(K key)：如果表中存入过key，返回key；否则返回所有键值的排序结果中，key的后一个。

以上所有操作时间复杂度都是O(logN)，N为有序表含有的记录数

# 单链表

问题1：反转单向和双向链表
【题目】 分别实现反转单向链表和反转双向链表的函数
【要求】 如果链表长度为N，时间复杂度要求为O(N)，额外空间复杂度要求为O(1)

> 单纯的code题



问题2：打印两个有序链表的公共部分
【题目】 给定两个有序链表的头指针head1和head2，打印两个链表的公共部分。
【要求】 如果两个链表的长度之和为N，时间复杂度要求为O(N)，额外空间复杂度要求为O(1)

> 思路：head1和head2进行比对，不相同时小的指针往后指，相同时两个指针同时往后指



问题3：判断一个链表是否为回文结构
【题目】给定一个单链表的头节点head，请判断该链表是否为回文结构。
【例子】1->2->1，返回true； 1->2->2->1，返回true；15->6->15，返回true；1->2->3，返回false。
【例子】如果链表长度为N，时间复杂度达到O(N)，额外空间复杂度达到O(1)。

> 思路1：利用栈的特性遍历链表入栈后与原链表进行比对
>
> 优化思路：利用快慢指针找到链表中点后将后半部分压入栈中与原链表前半部分进行比对
>
> 重要技巧：
> 1）额外数据结构记录（哈希表等）
> 2）快慢指针



问题4：将单向链表按某值划分成左边小、中间相等、右边大的形式
【题目】给定一个单链表的头节点head，节点的值类型是整型，再给定一个整
数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于pivot的
节点，中间部分都是值等于pivot的节点，右部分都是值大于pivot的节点。
【进阶】在实现原问题功能的基础上增加如下的要求
【要求】调整后所有小于pivot的节点之间的相对顺序和调整前一样
【要求】调整后所有等于pivot的节点之间的相对顺序和调整前一样
【要求】调整后所有大于pivot的节点之间的相对顺序和调整前一样
【要求】时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。

> 思路1：将node放入数组中，按照值做快速排序patition
>
> 思路2： 定义六个指针，SH、ST、EH、ET、BG、BT，遍历该链表依次将SH、ST指向小于该数的链表头和尾，EH、ET指向等于链表的头和尾、BG、BT指向大于链表的头和尾。再将三个链表从大到小链接。

问题5：复制含有随机指针节点的链表
【题目】一种特殊的单链表节点类描述如下

```java
class Node {
	int value;
	Node next;
	Node rand;
	Node(int val) {
		value = val;
	}
}
```

rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null。给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。
【要求】时间复杂度O(N)，额外空间复杂度O(1)

> 思路1：利用哈希表处理，将哈希表的K存入原链表指针，V存入拷贝的原表指针，遍历原链表，按照原链表的指针将拷贝的V之间的指针复制进去。
>
> 思路2：在每个链表元素后直接将该元素的复制节点插入，然后两个两个的遍历该链表，复制节点的rand指针就是原节点的rand指针的next节点。最后取出复制的所有节点形成新的链表结构

```java
public class copyRandomLinkedList {

    int a = 0;

    public static class Node {
        int value;
        Node next;
        Node rand;
        Node(int val) {
            this.value = val;
        }

    }

    public static Node copyRandomLinkedList(Node head){
        HashMap<Node, Node> map = new HashMap<>();
        Node cur = head;
        //遍历链表复制到hashmap中
        while (cur != null){
            map.put(cur,new Node(cur.value));
            cur = cur.next;
        }
        cur =head;
        while (cur!=null){
            map.get(cur).next = map.get(cur.next);
            map.get(cur).rand = map.get(cur.rand);
            cur = cur.next;
        }
        return map.get(head);
    }

    public static Node copyRandomLinkedList2(Node head) {
        if (head == null) {
            return null;
        }
        Node cur = head;
        Node next = null;
        // copy node and link to every node
        while (cur != null) {
            next = cur.next;
            cur.next = new Node(cur.value);
            cur.next.next = next;
            cur = next;
        }
        cur = head;
        Node curCopy = null;
        // set copy node rand
        while (cur != null) {
            next = cur.next.next;
            curCopy = cur.next;
            curCopy.rand = cur.rand != null ? cur.rand.next : null;
            cur = next;
        }
        Node res = head.next;
        cur = head;
        // split
        while (cur != null) {
            next = cur.next.next;
            curCopy = cur.next;
            cur.next = next;
            curCopy.next = next != null ? next.next : null;
            cur = next;
        }
        return res;
    }
    
    public static void printRandLinkedList(Node head) {
        Node cur = head;
        System.out.print("order: ");
        while (cur != null) {
            System.out.print(cur.value + " ");
            cur = cur.next;
        }
        System.out.println();
        cur = head;
        System.out.print("rand:  ");
        while (cur != null) {
            System.out.print(cur.rand == null ? "- " : cur.rand.value + " ");
            cur = cur.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Node head = null;
        Node res1 = null;
        Node res2 = null;
        printRandLinkedList(head);
        res1 = copyRandomLinkedList(head);
        printRandLinkedList(res1);
        res2 = copyRandomLinkedList2(head);
        printRandLinkedList(res2);
        printRandLinkedList(head);
        System.out.println("=========================");

        head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);
        head.next.next.next.next.next = new Node(6);

        head.rand = head.next.next.next.next.next; // 1 -> 6
        head.next.rand = head.next.next.next.next.next; // 2 -> 6
        head.next.next.rand = head.next.next.next.next; // 3 -> 5
        head.next.next.next.rand = head.next.next; // 4 -> 3
        head.next.next.next.next.rand = null; // 5 -> null
        head.next.next.next.next.next.rand = head.next.next.next; // 6 -> 4

        printRandLinkedList(head);
        res1 = copyRandomLinkedList(head);
        printRandLinkedList(res1);
        res2 = copyRandomLinkedList2(head);
        printRandLinkedList(res2);
        printRandLinkedList(head);
        System.out.println("=========================");

    }
}
```

问题6：两个单链表相交的一系列问题
【题目】给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null
【要求】如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。

PS：判断一个单链表是否有环，可以使用哈希标或者快慢指针，当一个单链表有环时，使用快慢指针当快慢指针第一次相遇时，快指针回到head节点每次走一步，慢指针留在原地一次走一步，他们下一次相遇的节点一定是入环节点。

> 定义loop1、loop2为入环节点
>
> 情况1：loop1，loop2==null，有可能相交
>
> 情况2：loop1，loop2一个为null一个不为null，不可能相交
>
> 情况3：loop1，loop2都不为null，则可能不相交各自都有自己的环，或者可能共用一个环，有可能相交。当共用一个环时，又可分为两种情况，第一种情况是共用一个入环节点，第二种情况是不共用入环节点。
>
> ![image-20231225201343749](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80/image-20231225201343749.png)
>
> 思路1：利用哈希表（不符合题意，额外空间复杂度为o(N)）
>
> 思路2：快慢指针

```

```

# 二叉树

二叉树节点结构

1. 用递归和非递归两种方式实现二叉树的先序、中序、后序遍历
2. 如何直观的打印一颗二叉树
3. 如何完成二叉树的宽度优先遍历(常见题目：求一棵二叉树的宽度)

```java
class TreeNode<V>{
	V value;
	Node left;
	Node right;
}

public class BinaryTree {

    private TreeNode root;

    public void buildBinaryTree(int[] nums) {
        for (int num : nums) {
            insert(num);
        }
    }

    private void insert(int val) {
        root = insert(root, val);
    }

    private TreeNode insert(TreeNode root, int val) {
        if (root == null){
            return new TreeNode(val);
        }

        if (val < root.val) {
            root.left = insert(root.left, val);
        } else if (val > root.val) {
            root.right = insert(root.right, val);
        }

        return root;
    }

    //层次遍历
    public static void levelOrder(TreeNode head) {
        if (head == null){
            return;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(head);
        HashMap<TreeNode, Integer> levelMap = new HashMap<>();
        levelMap.put(head,1);
        //当前层级
        int curLevel = 1;
        //当前层级的节点数
        int curLevelNodes = 0;
        //所有层中那一层节点数量是最多的
        int max = Integer.MIN_VALUE;
        while (!queue.isEmpty()){
            TreeNode cur = queue.poll();
            int curNodeLevel = levelMap.get(cur);
            if (curLevel == curNodeLevel){

                curNodeLevel++;
            }else {
                max = Math.max(max,curLevelNodes);
                curLevel++;
                curLevelNodes = 0;
            }
            //System.out.println(cur.val);
            if (cur.left!=null){
                levelMap.put(cur.left,curNodeLevel+1);
                queue.add(cur.left);
            }
            if (cur.right != null){
                levelMap.put(cur.right,curNodeLevel+1);
                queue.add(cur.right);
            }
        }
    }

    //不进行递归的先序遍历
    public static void preOrderUnRecur(TreeNode head) {
        System.out.println("pre-order:");
        if (head != null) {
            Stack<TreeNode> stack = new Stack<TreeNode>();
            stack.add(head);
            while (!stack.isEmpty()) {
                head = stack.pop();
                System.out.println(head.val + "");
                if (head.right != null) {
                    stack.push(head.right);
                }
                if (head.left != null) {
                    stack.push(head.left);
                }
            }
        }
        System.out.println();
    }

    //不进行递归的后序遍历
    public static void posOrderUnRecur(TreeNode head) {
        System.out.println("pos-order:");
        if (head != null) {
            Stack<TreeNode> s1 = new Stack<TreeNode>();
            Stack<TreeNode> s2 = new Stack<TreeNode>();
            s1.add(head);
            while (!s1.isEmpty()) {
                head = s1.pop();
                s2.push(head);
                if (head.right != null) {
                    s1.push(head.right);
                }
                if (head.left != null) {
                    s1.push(head.left);
                }
            }
            while (!s2.isEmpty()) {
                System.out.println(s2.pop().val + " ");
            }
        }
        System.out.println();
    }

    //不进行递归的中序遍历
    public static void inOrderUnRecur(TreeNode head) {
        System.out.println("in-order:");
        if (head != null) {
            Stack<TreeNode> stack = new Stack<TreeNode>();
            while (!stack.isEmpty() || head != null) {
                if (head != null) {
                    stack.push(head);
                    head = head.left;
                } else {
                    head = stack.pop();
                    System.out.println(head.val + " ");
                    head = head.right;
                }
            }
        }
        System.out.println();
    }

    public void preOrder() {
        preOrder(root);
    }

    //进行递归的先序遍历
    private void preOrder(TreeNode root) {
        if (root != null) {
            System.out.print(root.val + " ");
            preOrder(root.left);
            preOrder(root.right);
        }
    }

    public void inOrder() {
        inOrder(root);
    }

    //进行递归的中序遍历
    private void inOrder(TreeNode root) {
        if (root != null) {
            inOrder(root.left);
            System.out.print(root.val + " ");
            inOrder(root.right);
        }
    }

    public void postOrder() {
        postOrder(root);
    }

    //进行递归的后序遍历
    private void postOrder(TreeNode root) {
        if (root != null) {
            postOrder(root.left);
            postOrder(root.right);
            System.out.print(root.val + " ");
        }
    }

    private TreeNode findMin(TreeNode root) {
        while (root.left != null) {
            root = root.left;
        }

        return root;
    }

    public void delete(int val) {
        root = delete(root, val);
    }

    private TreeNode delete(TreeNode root, int val) {
        if (root == null) {
            return null;
        }

        if (val < root.val) {
            root.left = delete(root.left, val);
        } else if (val > root.val) {
            root.right = delete(root.right, val);
        } else {
            if (root.left == null && root.right == null) {
                root = null;
            } else if (root.left == null) {
                root = root.right;
            } else if (root.right == null) {
                root = root.left;
            } else {
                TreeNode templateTree = findMin(root.right);
                root.val = templateTree.val;
                root.right = delete(root.right, templateTree.val);
            }
        }

        return root;

    }

    public boolean search(int val) {
        return search(root, val);
    }

    public boolean search(TreeNode root, int val) {
        if (root == null)
            return false;

        if (val < root.val) {
            return search(root.left, val);
        } else if (val > root.val) {
            return search(root.right, val);
        } else {
            return true;
        }
    }

    public void modify(int oldValue, int newValue) {
        delete(oldValue);
        insert(newValue);
    }

    public static void main(String[] args) {
        BinaryTree binaryTree = new BinaryTree();
        int[] arr = {2, 1, 3, 4, 7, 6, 5, 9};
        binaryTree.buildBinaryTree(arr);

        boolean search = binaryTree.search(9);
        System.out.println(search);
        binaryTree.modify(9, 8);
        binaryTree.delete(7);

        binaryTree.preOrder();
        System.out.println("");
        binaryTree.inOrder();
        System.out.println("");
        binaryTree.postOrder();
    }
}
```

## 二叉树的相关概念及其实现判断

1. 什么是搜索二叉树？如何判断一颗二叉树是否是搜索二叉树？
2. 什么是完全二叉树？如何判断一颗二叉树是完全二叉树？
3. 如何判断一颗二叉树是否是满二叉树？
4. 如何判断一颗二叉树是否是平衡二叉树？（二叉树题目套路 树型DP）

> 1、所有左子节点都比根节点小，所有右子节点都比根节点大的二叉树叫搜索二叉树。利用中序遍历，观察中序遍历的结果，如果是搜索二叉树，则中序遍历的结果是递增的。
>
> 2、利用层序遍历，判断
>
> ​	1）当出现只有右节点，没有左子节点的根节点时，直接返回false.
>
> ​	2）当出现只有左子节点，没有右子节点的根节点后，后面的所有节点都是叶子节点(使用开关变量leaf判断)。
>
> 3、统计该树最大深度L，和节点个数N，如果N=$2^L$-1这棵树比是满二叉树，如果不是则该树不是满二叉树。
>
> 4、使用树型DP套路进行递归，判断右子树和左子树之差是否大于2。

问题：给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点。

> 思路1：遍历树利用hashmap和hashset解决
>
> 思路2：递归思路 树型DP
>
> ​	1）o1是o2的LCA，或o2是o1的LCA
>
> ​	2）o1和o2彼此不互为LCA

```java
public static Node lowestAncestor(Node head, Node o1, Node o2) {
	if (head == null || head == o1 || head == o2) { //BASECASE
		return head;
	}
	Node left = lowestAncestor(head.left, o1, o2);
	Node right = lowestAncestor(head.right, o1, o2);
	if (left != null && right != null) {
		return head;
	}
	return left != null ? left : right;
}
```

在二叉树中找到一个节点的后继节点
【题目】 现在有一种新的二叉树节点类型如下:

```java
public class Node {
	public int value;
	public Node left;
	public Node right;
	public Node parent;
	public Node(int val) {
		value = val;
	}
}
```

该结构比普通二叉树节点结构多了一个指向父节点的parent指针。假设有一棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确地指向自己的父节点，头节点的parent指向null。只给一个在二叉树中的某个节点node，请实现返回node的后继节点的函数。在二叉树的中序遍历的序列中， node的下一个节点叫作node的后继节点。

> 思路：
>
> ​	1）x有右树的时候，x的右子节点就是它的后继。
>
> ​	2）x无右树的时候，x向上找父节点，当第一次遇到某个节点是父节点的左子节点时，该节点就是x的后继。
>
> ​	3）x是整棵树上最右的节点，且向上找父节点不存在某个节点是父节点的左子节点。

```java
	public static Node getSuccessorNode(Node node) {
		if (node == null) {
			return node;
		}
		if (node.right != null) {
			return getLeftMost(node.right);
		} else {
			Node parent = node.parent;
			while (parent != null && parent.left != node) {
				node = parent;
				parent = node.parent;
			}
			return parent;
		}
	}
```

二叉树的序列化和反序列化
就是内存里的一棵树如何变成字符串形式，又如何从字符串形式变成内存里的树
如何判断一颗二叉树是不是另一棵二叉树的子树？

```java
public class Code09_SerializeAndReconstructTree {

	public static class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int data) {
			this.value = data;
		}
	}

	public static String serialByPre(Node head) {
		if (head == null) {
			return "#!";
		}
		String res = head.value + "!";
		res += serialByPre(head.left);
		res += serialByPre(head.right);
		return res;
	}

	public static Node reconByPreString(String preStr) {
		String[] values = preStr.split("!");
		Queue<String> queue = new LinkedList<String>();
		for (int i = 0; i != values.length; i++) {
			queue.offer(values[i]);
		}
		return reconPreOrder(queue);
	}

	public static Node reconPreOrder(Queue<String> queue) {
		String value = queue.poll();
		if (value.equals("#")) {
			return null;
		}
		Node head = new Node(Integer.valueOf(value));
		head.left = reconPreOrder(queue);
		head.right = reconPreOrder(queue);
		return head;
	}

	public static String serialByLevel(Node head) {
		if (head == null) {
			return "#!";
		}
		String res = head.value + "!";
		Queue<Node> queue = new LinkedList<Node>();
		queue.offer(head);
		while (!queue.isEmpty()) {
			head = queue.poll();
			if (head.left != null) {
				res += head.left.value + "!";
				queue.offer(head.left);
			} else {
				res += "#!";
			}
			if (head.right != null) {
				res += head.right.value + "!";
				queue.offer(head.right);
			} else {
				res += "#!";
			}
		}
		return res;
	}

	public static Node reconByLevelString(String levelStr) {
		String[] values = levelStr.split("!");
		int index = 0;
		Node head = generateNodeByString(values[index++]);
		Queue<Node> queue = new LinkedList<Node>();
		if (head != null) {
			queue.offer(head);
		}
		Node node = null;
		while (!queue.isEmpty()) {
			node = queue.poll();
			node.left = generateNodeByString(values[index++]);
			node.right = generateNodeByString(values[index++]);
			if (node.left != null) {
				queue.offer(node.left);
			}
			if (node.right != null) {
				queue.offer(node.right);
			}
		}
		return head;
	}

	public static Node generateNodeByString(String val) {
		if (val.equals("#")) {
			return null;
		}
		return new Node(Integer.valueOf(val));
	}


	public static void printInOrder(Node head, int height, String to, int len) {
		if (head == null) {
			return;
		}
		printInOrder(head.right, height + 1, "v", len);
		String val = to + head.value + to;
		int lenM = val.length();
		int lenL = (len - lenM) / 2;
		int lenR = len - lenM - lenL;
		val = getSpace(lenL) + val + getSpace(lenR);
		System.out.println(getSpace(height * len) + val);
		printInOrder(head.left, height + 1, "^", len);
	}

	public static String getSpace(int num) {
		String space = " ";
		StringBuffer buf = new StringBuffer("");
		for (int i = 0; i < num; i++) {
			buf.append(space);
		}
		return buf.toString();
	}

}
```

折纸问题
请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。给定一个输入参数N，代表纸条都从下边向上方连续对折N次。请从上到下打印所有折痕的方向。
例如:N=1时，打印: down N=2时，打印: down down up

> 思路：规律是新折痕会出现在老折痕的上下两侧，上面是凹折痕，下面是突折痕。利用二叉树，根节点是上一次的折痕，左子树是凹折痕，右子树是突折痕，n是树高，利用中序遍历得到结果。

# 图

## 图的存储方式 

1)邻接表

 2)邻接矩阵 

如何表达图?生成图?

> 有很多种表达图的方式，选择自己最熟悉的那种进行转换。

```java
public class Graph {
	public HashMap<Integer,Node> nodes;
	public HashSet<Edge> edges;

	public Graph() {
		nodes = new HashMap<>();
		edges = new HashSet<>();
	}
}
```

```java
public class Node {
	public int value;
	public int in;
	public int out;
	public ArrayList<Node> nexts;
	public ArrayList<Edge> edges;

	public Node(int value) {
		this.value = value;
		in = 0;
		out = 0;
		nexts = new ArrayList<>();
		edges = new ArrayList<>();
	}
}
```

```java
public class Edge {
	public int weight;
	public Node from;
	public Node to;

	public Edge(int weight, Node from, Node to) {
		this.weight = weight;
		this.from = from;
		this.to = to;
	}

}
```

## 图的宽度优先遍历

1.  利用队列实现 
2. 从源节点开始依次按照宽度进队列，然后弹出 
3. 每弹出一个点，把该节点所有没有进过队列的邻接点放入队列 
4. 直到队列变空

```java
public class GraphBFS {
    //类似于二叉树的层序遍历(宽度优先遍历)
	public static void bfs(Node node) {
		if (node == null) {
			return;
		}
		Queue<Node> queue = new LinkedList<>();
		HashSet<Node> map = new HashSet<>();
		queue.add(node);
		map.add(node);
		while (!queue.isEmpty()) {
			Node cur = queue.poll();
			System.out.println(cur.value);
			for (Node next : cur.nexts) {
				if (!map.contains(next)) {
					map.add(next);
					queue.add(next);
				}
			}
		}
	}

}
```



## 深度优先遍历

1. 利用栈实现 
2. 从源节点开始把节点按照深度放入栈，然后弹出 
3. 每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈 
4. 直到栈变空

```java
public class GraphDFS {

	public static void dfs(Node node) {
		if (node == null) {
			return;
		}
		Stack<Node> stack = new Stack<>();
		HashSet<Node> set = new HashSet<>();
		stack.add(node);
		set.add(node);
		System.out.println(node.value);
		while (!stack.isEmpty()) {
			Node cur = stack.pop();
			for (Node next : cur.nexts) {
				if (!set.contains(next)) {
					stack.push(cur);
					stack.push(next);
					set.add(next);
					System.out.println(next.value);
					break;
				}
			}
		}
	}

}
```

## 拓扑排序算法 

适用范围：要求有向图，且有入度为0的节点，且没有环

> 思路：依次找到入度为0的点，将其节点和边擦掉，再循环寻找入毒为0的点。

```java
public class Code03_TopologySort {

	// directed graph and no loop
	public static List<Node> sortedTopology(Graph graph) {
		HashMap<Node, Integer> inMap = new HashMap<>();
		Queue<Node> zeroInQueue = new LinkedList<>();
		for (Node node : graph.nodes.values()) {
			inMap.put(node, node.in);
			if (node.in == 0) {
				zeroInQueue.add(node);
			}
		}
		List<Node> result = new ArrayList<>();
		while (!zeroInQueue.isEmpty()) {
			Node cur = zeroInQueue.poll();
			result.add(cur);
			for (Node next : cur.nexts) {
				inMap.put(next, inMap.get(next) - 1);
				if (inMap.get(next) == 0) {
					zeroInQueue.add(next);
				}
			}
		}
		return result;
	}
}
```

## 最小生成树算法

### **Kruskal算法**

适用范围：要求无向图

> 思路：从最小边开始考虑，如果加上之后不形成环就加上，如果形成环就不加

```java
public class Kruskal {

	// Union-Find Set
	public static class UnionFind {
		private HashMap<Node, Node> fatherMap;
		private HashMap<Node, Integer> rankMap;

		public UnionFind() {
			fatherMap = new HashMap<Node, Node>();
			rankMap = new HashMap<Node, Integer>();
		}

		private Node findFather(Node n) {
			Node father = fatherMap.get(n);
			if (father != n) {
				father = findFather(father);
			}
			fatherMap.put(n, father);
			return father;
		}

		public void makeSets(Collection<Node> nodes) {
			fatherMap.clear();
			rankMap.clear();
			for (Node node : nodes) {
				fatherMap.put(node, node);
				rankMap.put(node, 1);
			}
		}

		public boolean isSameSet(Node a, Node b) {
			return findFather(a) == findFather(b);
		}

		public void union(Node a, Node b) {
			if (a == null || b == null) {
				return;
			}
			Node aFather = findFather(a);
			Node bFather = findFather(b);
			if (aFather != bFather) {
				int aFrank = rankMap.get(aFather);
				int bFrank = rankMap.get(bFather);
				if (aFrank <= bFrank) {
					fatherMap.put(aFather, bFather);
					rankMap.put(bFather, aFrank + bFrank);
				} else {
					fatherMap.put(bFather, aFather);
					rankMap.put(aFather, aFrank + bFrank);
				}
			}
		}
	}

	public static class EdgeComparator implements Comparator<Edge> {

		@Override
		public int compare(Edge o1, Edge o2) {
			return o1.weight - o2.weight;
		}

	}

	public static Set<Edge> kruskalMST(Graph graph) {
		UnionFind unionFind = new UnionFind();
		unionFind.makeSets(graph.nodes.values());
		PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(new EdgeComparator());
		for (Edge edge : graph.edges) {
			priorityQueue.add(edge);
		}
		Set<Edge> result = new HashSet<>();
		while (!priorityQueue.isEmpty()) {
			Edge edge = priorityQueue.poll();
			if (!unionFind.isSameSet(edge.from, edge.to)) {
				result.add(edge);
				unionFind.union(edge.from, edge.to);
			}
		}
		return result;
	}
}
```



### **Prim算法**

适用范围：要求无向图

> 思路：从某个点A开始，将与此点相连的边存入到集合E中挑选最小边联通另一个点B，再将与B点相连的边放入E中，再挑选最小边如此循环，当边的两端已经在Set中则此边不可用，再从E中挑选最小边。

```java
public class Code05_Prim {

	public static class EdgeComparator implements Comparator<Edge> {

		@Override
		public int compare(Edge o1, Edge o2) {
			return o1.weight - o2.weight;
		}

	}

	public static Set<Edge> primMST(Graph graph) {
		PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(
				new EdgeComparator());
		HashSet<Node> set = new HashSet<>();
		Set<Edge> result = new HashSet<>();
		for (Node node : graph.nodes.values()) {
			if (!set.contains(node)) {
				set.add(node);
				for (Edge edge : node.edges) {
					priorityQueue.add(edge);
				}
				while (!priorityQueue.isEmpty()) {
					Edge edge = priorityQueue.poll();
					Node toNode = edge.to;
					if (!set.contains(toNode)) {
						set.add(toNode);
						result.add(edge);
						for (Edge nextEdge : toNode.edges) {
							priorityQueue.add(nextEdge);
						}
					}
				}
			}
		}
		return result;
	}

	// 请保证graph是连通图
	// graph[i][j]表示点i到点j的距离，如果是系统最大值代表无路
	// 返回值是最小连通图的路径之和
	public static int prim(int[][] graph) {
		int size = graph.length;
		int[] distances = new int[size];
		boolean[] visit = new boolean[size];
		visit[0] = true;
		for (int i = 0; i < size; i++) {
			distances[i] = graph[0][i];
		}
		int sum = 0;
		for (int i = 1; i < size; i++) {
			int minPath = Integer.MAX_VALUE;
			int minIndex = -1;
			for (int j = 0; j < size; j++) {
				if (!visit[j] && distances[j] < minPath) {
					minPath = distances[j];
					minIndex = j;
				}
			}
			if (minIndex == -1) {
				return sum;
			}
			visit[minIndex] = true;
			sum += minPath;
			for (int j = 0; j < size; j++) {
				if (!visit[j] && distances[j] > graph[minIndex][j]) {
					distances[j] = graph[minIndex][j];
				}
			}
		}
		return sum;
	}

}
```

## 最短路径算法

### floyd算法

### dijkstra算法

适用范围：没有权值为负数的边

> 思路：锁点更新路径
>
> ![image-20240103134211129](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80/image-20240103134211129.png)

```java
// no negative weight
public class Dijkstra {

	public static HashMap<Node, Integer> dijkstra1(Node head) {
        //从head出发到所有点的最小距离
        //key：从head出发到达key
        //value：从head出发到达key的最小距离
        //如果在表中，没有T的记录，含义是从head出发到T这个点的距离为正无穷
		HashMap<Node, Integer> distanceMap = new HashMap<>();
		distanceMap.put(head, 0);
        //已经求过距离的节点，存在selectedNodes中，以后再也不碰
		HashSet<Node> selectedNodes = new HashSet<>();

		Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
		while (minNode != null) {
			int distance = distanceMap.get(minNode);
			for (Edge edge : minNode.edges) {
				Node toNode = edge.to;
				if (!distanceMap.containsKey(toNode)) {
					distanceMap.put(toNode, distance + edge.weight);
				}
				distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight));
			}
			selectedNodes.add(minNode);
			minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
		}
		return distanceMap;
	}

	public static Node getMinDistanceAndUnselectedNode(HashMap<Node, Integer> distanceMap, HashSet<Node> touchedNodes) {
		Node minNode = null;
		int minDistance = Integer.MAX_VALUE;
		for (Entry<Node, Integer> entry : distanceMap.entrySet()) {
			Node node = entry.getKey();
			int distance = entry.getValue();
			if (!touchedNodes.contains(node) && distance < minDistance) {
				minNode = node;
				minDistance = distance;
			}
		}
		return minNode;
	}

	public static class NodeRecord {
		public Node node;
		public int distance;

		public NodeRecord(Node node, int distance) {
			this.node = node;
			this.distance = distance;
		}
	}

	public static class NodeHeap {
		private Node[] nodes;
		private HashMap<Node, Integer> heapIndexMap;
		private HashMap<Node, Integer> distanceMap;
		private int size;

		public NodeHeap(int size) {
			nodes = new Node[size];
			heapIndexMap = new HashMap<>();
			distanceMap = new HashMap<>();
			this.size = 0;
		}

		public boolean isEmpty() {
			return size == 0;
		}

		public void addOrUpdateOrIgnore(Node node, int distance) {
			if (inHeap(node)) {
				distanceMap.put(node, Math.min(distanceMap.get(node), distance));
				insertHeapify(node, heapIndexMap.get(node));
			}
			if (!isEntered(node)) {
				nodes[size] = node;
				heapIndexMap.put(node, size);
				distanceMap.put(node, distance);
				insertHeapify(node, size++);
			}
		}

		public NodeRecord pop() {
			NodeRecord nodeRecord = new NodeRecord(nodes[0], distanceMap.get(nodes[0]));
			swap(0, size - 1);
			heapIndexMap.put(nodes[size - 1], -1);
			distanceMap.remove(nodes[size - 1]);
			nodes[size - 1] = null;
			heapify(0, --size);
			return nodeRecord;
		}

		private void insertHeapify(Node node, int index) {
			while (distanceMap.get(nodes[index]) < distanceMap.get(nodes[(index - 1) / 2])) {
				swap(index, (index - 1) / 2);
				index = (index - 1) / 2;
			}
		}

		private void heapify(int index, int size) {
			int left = index * 2 + 1;
			while (left < size) {
				int smallest = left + 1 < size && distanceMap.get(nodes[left + 1]) < distanceMap.get(nodes[left])
						? left + 1 : left;
				smallest = distanceMap.get(nodes[smallest]) < distanceMap.get(nodes[index]) ? smallest : index;
				if (smallest == index) {
					break;
				}
				swap(smallest, index);
				index = smallest;
				left = index * 2 + 1;
			}
		}

		private boolean isEntered(Node node) {
			return heapIndexMap.containsKey(node);
		}

		private boolean inHeap(Node node) {
			return isEntered(node) && heapIndexMap.get(node) != -1;
		}

		private void swap(int index1, int index2) {
			heapIndexMap.put(nodes[index1], index2);
			heapIndexMap.put(nodes[index2], index1);
			Node tmp = nodes[index1];
			nodes[index1] = nodes[index2];
			nodes[index2] = tmp;
		}
	}

	public static HashMap<Node, Integer> dijkstra2(Node head, int size) {
		NodeHeap nodeHeap = new NodeHeap(size);
		nodeHeap.addOrUpdateOrIgnore(head, 0);
		HashMap<Node, Integer> result = new HashMap<>();
		while (!nodeHeap.isEmpty()) {
			NodeRecord record = nodeHeap.pop();
			Node cur = record.node;
			int distance = record.distance;
			for (Edge edge : cur.edges) {
				nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance);
			}
			result.put(cur, distance);
		}
		return result;
	}

}
```

### Bellman-Ford算法

# 前缀树

根节点的p值表示该树中有多少个字符串

前缀树可以查找树中有多少个以“xx”字符串开头的字符

``` 
public class Code01_TrieTree {

	public static class TrieNode {
		public int path;
		public int end;
		public TrieNode[] nexts;//HashMap<Char,Node> nexts;//TreeMap<Char,Node> nexts;

		public TrieNode() {
			path = 0;
			end = 0;
			nexts = new TrieNode[26];
		}
	}

	public static class Trie {
		private TrieNode root;

		public Trie() {
			root = new TrieNode();
		}

        //插入某个字符
		public void insert(String word) {
			if (word == null) {
				return;
			}
			char[] chs = word.toCharArray();
			TrieNode node = root;
			int index = 0;
			for (int i = 0; i < chs.length; i++) {
				index = chs[i] - 'a';
				if (node.nexts[index] == null) {
					node.nexts[index] = new TrieNode();
				}
				node = node.nexts[index];
				node.path++;
			}
			node.end++;
		}

        //删除某个字符
		public void delete(String word) {
			if (search(word) != 0) {
				char[] chs = word.toCharArray();
				TrieNode node = root;
				int index = 0;
				for (int i = 0; i < chs.length; i++) {
					index = chs[i] - 'a';
					if (--node.nexts[index].path == 0) {
						node.nexts[index] = null;
						return;
					}
					node = node.nexts[index];
				}
				node.end--;
			}
		}
        
        //查询某个单词加入过几次
		public int search(String word) {
			if (word == null) {
				return 0;
			}
			char[] chs = word.toCharArray();
			TrieNode node = root;
			int index = 0;
			for (int i = 0; i < chs.length; i++) {
				index = chs[i] - 'a';
				if (node.nexts[index] == null) {
					return 0;
				}
				node = node.nexts[index];
			}
			return node.end;
		}

        //所有加入的字符串中，有几个是以pre这个字符串作为前缀的
		public int prefixNumber(String pre) {
			if (pre == null) {
				return 0;
			}
			char[] chs = pre.toCharArray();
			TrieNode node = root;
			int index = 0;
			for (int i = 0; i < chs.length; i++) {
				index = chs[i] - 'a';
				if (node.nexts[index] == null) {
					return 0;
				}
				node = node.nexts[index];
			}
			return node.path;
		}
	}
}
```

# 贪心算法

在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到 一个答案的算法，叫作贪心算法。 （其实是一种解决问题的思路）

也就是说，不从整体最优上加以考虑，所做出的是在某种意义上的局部最优解。 

局部最优 -?-> 整体最优

贪心算法的在笔试时的解题套路 

1. 实现一个不依靠贪心策略的解法X，可以用最暴力的尝试 
2. 脑补出贪心策略A、贪心策略B、贪心策略C... 
3. 用解法X和对数器，去验证每一个贪心策略，用实验的方式得知哪个贪心策略正确 
4. 不要去纠结贪心策略的证明

从头到尾展示最正统的贪心策略求解过程 

​	例子： 给定一个字符串类型的数组strs，找到一种拼接方式，使得把所有字符串拼起来之后形成的 字符串具有最小的字典序。 

证明贪心策略可能是件非常腌心的事情。平时当然推荐你搞清楚所有的来龙去脉，但是笔试 时用对数器的方式。

贪心策略在实现时，经常使用到的技巧： 

1. 根据某标准建立一个比较器来排序 
2. 根据某标准建立一个比较器来组成堆

问题1:一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的金条，不管切成长度多大的两半，都要花费20个铜板。 一群人想整分整块金条，怎么分最省铜板? 例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为10+20+30=60。 金条要分成10,20,30三个部分。 如果先把长度60的金条分成10和50，花费60； 再把长度50的金条分成20和30，花费50；一共花费110铜板。 但是如果先把长度60的金条分成30和30，花费60；再把长度30金条分成10和20， 花费30；一共花费90铜板。 输入一个数组，返回分割的最小代价。

> 思路：哈夫曼编码

问题2：

输入： 

正数数组costs ，正数数组profits ，正数k ，正数m 

含义： 

costs[i]表示i号项目的花费 ，profits[i]表示i号项目在扣除花费之后还能挣到的钱(利润) ，k表示你只能串行的最多做k个项目 ，m表示你初始的资金 

说明： 

你每做完一个项目，马上获得的收益，可以支持你去做下一个项目。

输出： 

你最后获得的最大钱数。

> 思路：大小根堆的配合使用

问题3：一个数据流中，随时可以取得中位数

> 思路：大小根堆的配合使用



N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列， 也不在同一条斜上。给定一个整数n，返回n皇后的摆法有多少种。 n=1，返回1。 n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0。 n=8，返回92。
