<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java重写(Override)与重载(Overload)</title>
    <link href="/2022/10/21/Java%E9%87%8D%E5%86%99-Override-%E4%B8%8E%E9%87%8D%E8%BD%BD-Overload/"/>
    <url>/2022/10/21/Java%E9%87%8D%E5%86%99-Override-%E4%B8%8E%E9%87%8D%E8%BD%BD-Overload/</url>
    
    <content type="html"><![CDATA[<h1 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a>重写(Override)</h1><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！</p><p>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p><p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，抛出 IOException 异常或者 IOException 的子类异常。</p><p>在面向对象原则里，重写意味着可以重写任何现有方法。实例如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span>()</span>&#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;动物可以移动&quot;</span>);<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-title">extends</span> <span class="hljs-title">Animal</span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span>()</span>&#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;狗可以跑和走&quot;</span>);<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestDog</span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String args[]</span>)</span>&#123;<br>      Animal a = <span class="hljs-keyword">new</span> Animal(); <span class="hljs-comment">// Animal 对象</span><br>      Animal b = <span class="hljs-keyword">new</span> Dog(); <span class="hljs-comment">// Dog 对象</span><br> <br>      a.move();<span class="hljs-comment">// 执行 Animal 类的方法</span><br> <br>      b.move();<span class="hljs-comment">//执行 Dog 类的方法</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上实例编译运行结果如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">动物可以移动<br>狗可以跑和走<br></code></pre></td></tr></table></figure><p>在上面的例子中可以看到，尽管 b 属于 Animal 类型，但是它运行的是 Dog 类的 move方法。</p><p>这是由于在编译阶段，只是检查参数的引用类型。</p><p>然而在运行时，Java 虚拟机(JVM)指定对象的类型并且运行该对象的方法。</p><p>因此在上面的例子中，之所以能编译成功，是因为 Animal 类中存在 move 方法，然而运行时，运行的是特定对象的方法。</p><p>思考以下例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span>()</span>&#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;动物可以移动&quot;</span>);<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-title">extends</span> <span class="hljs-title">Animal</span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span>()</span>&#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;狗可以跑和走&quot;</span>);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bark</span>()</span>&#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;狗可以吠叫&quot;</span>);<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestDog</span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String args[]</span>)</span>&#123;<br>      Animal a = <span class="hljs-keyword">new</span> Animal(); <span class="hljs-comment">// Animal 对象</span><br>      Animal b = <span class="hljs-keyword">new</span> Dog(); <span class="hljs-comment">// Dog 对象</span><br> <br>      a.move();<span class="hljs-comment">// 执行 Animal 类的方法</span><br>      b.move();<span class="hljs-comment">//执行 Dog 类的方法</span><br>      b.bark();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上实例编译运行结果如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">TestDog.java:<span class="hljs-number">30</span>: cannot find symbol<br>symbol  : <span class="hljs-keyword">method</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span><br><span class="hljs-title function_">location</span>: <span class="hljs-keyword">class</span> Animal<br>                b.bark()<span class="hljs-punctuation">;</span><br>                 ^<br></code></pre></td></tr></table></figure><p>该程序将抛出一个编译错误，因为b的引用类型Animal没有bark方法。</p><hr><h2 id="方法的重写规则"><a href="#方法的重写规则" class="headerlink" title="方法的重写规则"></a>方法的重写规则</h2><ul><li><p>参数列表与被重写方法的参数列表必须完全相同。</p></li><li><p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p></li><li><p>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</p></li><li><p>父类的成员方法只能被它的子类重写。</p></li><li><p>声明为 final 的方法不能被重写。</p></li><li><p>声明为 static 的方法不能被重写，但是能够被再次声明。</p></li><li><p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</p></li><li><p>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</p></li><li><p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</p></li><li><p>构造方法不能被重写。</p></li><li><p>如果不能继承一个类，则不能重写该类的方法。</p></li></ul><hr><h2 id="Super-关键字的使用"><a href="#Super-关键字的使用" class="headerlink" title="Super 关键字的使用"></a>Super 关键字的使用</h2><p>当需要在子类中调用父类的被重写方法时，要使用 super 关键字。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">move</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;动物可以移动&quot;</span>);<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">move</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">move</span>(); <span class="hljs-comment">// 应用super类的方法</span><br>      <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;狗可以跑和走&quot;</span>);<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDog</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> args[]</span>)&#123;<br> <br>      <span class="hljs-title class_">Animal</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <span class="hljs-comment">// Dog 对象</span><br>      b.<span class="hljs-title function_">move</span>(); <span class="hljs-comment">//执行 Dog类的方法</span><br> <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上实例编译运行结果如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">动物可以移动<br>狗可以跑和走<br></code></pre></td></tr></table></figure><h2 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h2><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p><p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><p>最常用的地方就是构造器的重载。</p><p>重载规则:</p><ul><li><p>被重载的方法必须改变参数列表(参数个数或类型不一样)；</p></li><li><p>被重载的方法可以改变返回类型；</p></li><li><p>被重载的方法可以改变访问修饰符；</p></li><li><p>被重载的方法可以声明新的或更广的检查异常；</p></li><li><p>方法能够在同一个类中或者在一个子类中被重载。</p></li><li><p>无法以返回值类型作为重载函数的区分标准。</p></li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Overloading</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">test</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;test1&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;test2&quot;</span>);<br>    &#125;   <br> <br>    <span class="hljs-comment">//以下两个参数类型顺序不同</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a,String s</span>)</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;test3&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;returntest3&quot;</span>;<br>    &#125;   <br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test</span>(<span class="hljs-params">String s,<span class="hljs-built_in">int</span> a</span>)</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;test4&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;returntest4&quot;</span>;<br>    &#125;   <br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span>&#123;<br>        Overloading o = <span class="hljs-keyword">new</span> Overloading();<br>        System.<span class="hljs-keyword">out</span>.println(o.test());<br>        o.test(<span class="hljs-number">1</span>);<br>        System.<span class="hljs-keyword">out</span>.println(o.test(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;test3&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.println(o.test(<span class="hljs-string">&quot;test4&quot;</span>,<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重写与重载之间的区别"><a href="#重写与重载之间的区别" class="headerlink" title="重写与重载之间的区别"></a>重写与重载之间的区别</h2><table><thead><tr><th>区别点</th><th>重载方法</th><th>重写方法</th></tr></thead><tbody><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可以修改</td><td>一定不能修改</td></tr><tr><td>异常</td><td>可以修改</td><td>可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td>访问</td><td>可以修改</td><td>一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p><ul><li><p>(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</p></li><li><p>(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</p></li><li><p>(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</p></li></ul><p><img src="/2022/10/21/Java%E9%87%8D%E5%86%99-Override-%E4%B8%8E%E9%87%8D%E8%BD%BD-Overload/WEBRESOURCE45b7836d5382c120eea20fcb0db55d5b.png"></p><p><img src="/2022/10/21/Java%E9%87%8D%E5%86%99-Override-%E4%B8%8E%E9%87%8D%E8%BD%BD-Overload/WEBRESOURCE9f2ee55d8ea4cd593246c0c4fa8be779.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>①Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java重写(Override)与重载(Overload)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java高级</title>
    <link href="/2022/10/21/Java%E9%AB%98%E7%BA%A7/"/>
    <url>/2022/10/21/Java%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p>#接口</p><p>##接口的描述：</p><p>接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用，Java中的接口更多的体现在对行为的抽象</p><p>##接口的特点：</p><p>接口用关键字interface修饰</p><p>public interface 接口名{}</p><p>类实现接口用implements表示</p><p>public class 类名 implement 接口名{}</p><p>接口不能实例化</p><p>接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态。</p><p>多态的形式：具体类多态，抽象类多态，接口多态。</p><p>多态的前提：有继承或者实现关系；有方法重写；有父（类&#x2F;接口）英勇只想（子&#x2F;实现）类对象</p><p>接口的实现类</p><p>要么重写接口中的所有抽象方法</p><p>要么是抽象类</p><p>##接口的成员特点：</p><p>###成员变量</p><p>###只能是常量</p><p>默认修饰符：public static final</p><p>###构造方法</p><p>接口没有构造方法，应为接口主要是对行为进行抽象的，是没有具体存在</p><p>一个类如果没有父类，默认继承自Object类</p><p>###成员方法</p><p>只能是抽象方法</p><p>默认修饰符：public abstract</p><p>#类和接口的关系：</p><p>类和类的关系</p><p>继承关系，只能单继承，但是可以多层继承</p><p>类和接口的关系</p><p>实现关系，可以单实线，也可以多实现，还可以在继承一个类的同时实现多个接口</p><p>接口和接口的关系</p><p>继承关系，可以单继承，也可以多继承</p><p>    </p><p>#抽象类和接口的区别</p><p>成员区别</p><p>|抽象类|变量，常量；有构造方法；有抽象方法，也有非抽象方法。|</p><p>|接口|常量；抽象方法。|</p><blockquote></blockquote><p>关系区别</p><p>|类与类|继承，单继承，多层继承|</p><p>|类与接口|实现，可以单实现，也可以多实现|</p><p>|接口与接口|继承，单继承，多继承|</p><blockquote></blockquote><p>设计理念区别</p><p>|抽象类|对类抽象，包括属性、行为|</p><p>|接口|对行为抽象，主要是行为|</p><blockquote></blockquote><p>形参和返回值</p><p>抽象类名作为形参和返回值</p><p>方法的形参是抽象类名，其实需要的时该抽象类的子类对象</p><p>方法的返回值是抽象类名，其实返回的是该抽象类的子类对象</p><p>接口名作为形参和和返回值</p><p>方法的形参是接口名，其实需要的是该接口的实现类对象</p><p>方法的返回值是接口名，其实返回的是该接口的实现类对象</p><p>内部类</p><p>内部类：就是在一个类中定义一个类。举例：在一个类A的内部定义一个类B，类B就被称为内部类</p><p>pblic class A{</p><p>public class B{</p><p>}</p><p>}</p><p>内部类的访问特点：</p><p>内部类可以直接访问外部类的成员，包括私有。</p><p>外部类要访问内部类的成员，必须创建对象。</p><p>成员内部类</p><p>按照内部类在类中定义的位置不同，可以分为如下两种形式</p><p>在类的成员位置：成员内部类</p><p>在类的局部位置：局部内部类</p><p>成员内部类，外界如何创建对象使用呢？</p><p>格式：外部类名.内部类名 对象名 &#x3D; 外部类对象.内部类对象；</p><p>范例：Outer.Inner oi &#x3D; new Outer().new Inner();</p><p>当成员内部类为私有时，在外部类中创建方法间接调用内部类：</p><p><img src="/2022/10/21/Java%E9%AB%98%E7%BA%A7/A671AF24A1314FA4B56D98FB43007486.png"></p><p>局部内部类</p><p>是在方法中定义的类，所以外界是无法直接使用的，需要在方法内部创建对象并使用</p><p>该类可以直接访问外部类的成员，也可以访问方法内的局部变量。</p><p>匿名内部类</p><p>格式：</p><p>new 类名或接口名（）{</p><p>重写方法；</p><p>}；</p><p>范例：</p><p>new Inter（）{</p><p>public void show（）{</p><p>}</p><p>}；</p><p>本质：是一个继承了该类或者实现了该接口的子类匿名对象</p><p><img src="/2022/10/21/Java%E9%AB%98%E7%BA%A7/32E1A5D1032C411B98EC1B46B2BBAE38.png"></p><p>调用：</p><p><img src="/2022/10/21/Java%E9%AB%98%E7%BA%A7/AB98A7AD90824370990DD54D9EE8E7D1.png"></p><p>Math,System,Object类的toString(),Object类的equals()</p><p>intellIj如何看方法的源码：选中方法，按下Ctrl+B</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>①Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8新特性之Stream流的集合操作</title>
    <link href="/2022/10/21/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream%E6%B5%81%E7%9A%84%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/10/21/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream%E6%B5%81%E7%9A%84%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="概JDK8-Stream详解"><a href="#概JDK8-Stream详解" class="headerlink" title="概JDK8 Stream详解"></a>概JDK8 Stream详解</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote></blockquote><p>Stream是Java8 API的新成员，它允许以声明性方式处理数据集合 。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><blockquote></blockquote><p>（1）代码简洁：函数式编程写出的代码简洁且意图明确，使用stream接口让你从此告别for循环。<br>（2）多核友好：Java函数式编程使得编写并行程序从未如此简单，你需要的全部就是调用一下方法。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-number">1</span>）第一步：把集合转换为流<span class="hljs-keyword">stream</span><br><span class="hljs-number">2</span>）第二步：操作<span class="hljs-keyword">stream</span>流<br><span class="hljs-keyword">stream</span>流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果<br><br></code></pre></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><blockquote></blockquote><p>两种：中间操作符、终止操作符</p><h3 id="中间操作符"><a href="#中间操作符" class="headerlink" title="中间操作符"></a>中间操作符</h3><table><thead><tr><th>流方法</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>filter</td><td>用于通过设置的条件过滤出元素</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“abc”, “”, “bc”, “efg”, “abcd”,””, “jkl”);List&lt;String&gt; filtered &#x3D; strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</td></tr><tr><td>distinct</td><td>返回一个元素各异（根据流所生成元素的hashCode和equals方法实现）的流。</td><td>List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 1, 3, 3, 2, 4);numbers.stream().filter(i -&gt; i % 2 &#x3D;&#x3D; 0).distinct().forEach(System.out::println);</td></tr><tr><td>limit</td><td>会返回一个不超过给定长度的流。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“abc”, “abc”, “bc”, “efg”, “abcd”,”jkl”, “jkl”);List&lt;String&gt; limited &#x3D; strings.stream().limit(3).collect(Collectors.toList());</td></tr><tr><td>skip</td><td>返回一个扔掉了前n个元素的流。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“abc”, “abc”, “bc”, “efg”, “abcd”,”jkl”, “jkl”);List&lt;String&gt; skiped &#x3D; strings.stream().skip(3).collect(Collectors.toList());</td></tr><tr><td>map</td><td>接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是&quot;创建一个新版本”而不是去&quot;修改”）。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“abc”, “abc”, “bc”, “efg”, “abcd”,”jkl”, “jkl”);List&lt;String&gt; mapped &#x3D; strings.stream().map(str-&gt;str+”-itcast”).collect(Collectors.toList());</td></tr><tr><td>flatMap</td><td>使用flatMap方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。所有使用map(Arrays::stream)时生成的单个流都被合并起来，即扁平化为一个流。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“abc”, “abc”, “bc”, “efg”, “abcd”,”jkl”, “jkl”);Stream&lt;Character&gt; flatMap &#x3D; strings.stream().flatMap(Java8StreamTest::getCharacterByString);</td></tr><tr><td>sorted</td><td>返回排序后的流</td><td>List&lt;String&gt; strings1 &#x3D; Arrays.asList(“abc”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);List&lt;String&gt; sorted1 &#x3D; strings1.stream().sorted().collect(Collectors.toList());</td></tr></tbody></table><blockquote></blockquote><p>示例代码：<br>1）filter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述:根据条件过滤集合数据<br>* @return : void<br>*/<br>  @Test<br>  public void filter()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);<br>  List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());<br>  out.println(filtered);<br>  &#125;<br></code></pre></td></tr></table></figure><p>2）distinct</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述:去除集合中重复数据<br>* @return : void<br>*/<br>  @Test<br>  public void distinct()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;abc&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  List&lt;String&gt; distincted = strings.stream().distinct().collect(Collectors.toList());<br>  out.println(distincted);<br>  &#125;<br></code></pre></td></tr></table></figure><p>3）limit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述:指定获取集合前x条数据，重新构造一个新的集合<br>* @return : void<br>*/<br>  @Test<br>  public void limit()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;abc&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  List&lt;String&gt; limited = strings.stream().limit(3).collect(Collectors.toList());<br>  out.println(limited);<br>  &#125;<br></code></pre></td></tr></table></figure><p>4）skip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述:排除集合前x条数据，把后面的数据重新构造一个新的集合<br>* @return : void<br>*/<br>  @Test<br>  public void skip()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;abc&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  List&lt;String&gt; skiped = strings.stream().skip(3).collect(Collectors.toList());<br>  out.println(skiped);<br>  &#125;<br></code></pre></td></tr></table></figure><p>5）map</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">    /**<br>    * 功能描述:对集合中所有元素统一处理<br>* @return : void<br>  */<br>  @Test<br>  public void map()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;abc&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  List&lt;String&gt; mapped = strings.stream().map(str-&gt;str+&quot;-itcast&quot;).collect(Collectors.toList());<br>  out.println(mapped);<br>  &#125;<br></code></pre></td></tr></table></figure><p>6）flatMap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述:对集合中所有元素统一处理<br>* @return : void<br>*/<br>  @Test<br>  public void flatMap()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;abc&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  Stream&lt;String&gt; stringStream = strings.stream().map(x -&gt; x);<br>  Stream&lt;String&gt; stringStream1 = strings.stream().flatMap(x -&gt; Arrays.asList(x.split(&quot; &quot;)).stream());<br>  &#125;<br></code></pre></td></tr></table></figure><p>7）sorted</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述 : 对集合进行排序<br>* @return : void<br>*/<br>  @Test<br>  public void sorted()&#123;<br>  List&lt;String&gt; strings1 = Arrays.asList(&quot;abc&quot;, &quot;abd&quot;, &quot;aba&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  List&lt;String&gt; strings2 = Arrays.asList(&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵柳&quot;, &quot;张哥&quot;,&quot;李哥&quot;, &quot;王哥&quot;);<br>  List&lt;Integer&gt; strings3 = Arrays.asList(10, 2, 30, 22, 1,0, -9);<br>  List&lt;String&gt; sorted1 = strings1.stream().sorted().collect(Collectors.toList());<br>  List&lt;String&gt; sorted2 = strings2.stream().sorted(Collections.reverseOrder(Collator.getInstance(Locale.CHINA))).collect(Collectors.toList());<br>  List&lt;Integer&gt; sorted3 = strings3.stream().sorted().collect(Collectors.toList());<br>  out.println(sorted1);<br>  out.println(sorted2);<br>  out.println(sorted3);<br>  &#125;<br></code></pre></td></tr></table></figure><p>Map、flatMap区别</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">map</span>：对流中每一个元素进行处理<br>flatMap：流扁平化，让你把一个流中的“每个值”都换成另一个流，然后把所有的流连接起来成为一个流 <br>总结：<span class="hljs-built_in">map</span>是对一级元素进行操作，flatmap是对二级元素操作。<br><br></code></pre></td></tr></table></figure><p>本质区别：map返回一个值；flatmap返回一个流，多个值。</p><p>应用场景：map对集合中每个元素加工,返回加工后结果；flatmap对集合中每个元素加工后，做扁平化处理后（拆分层级，放到同一层）然后返回</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 方法一</span><br><span class="hljs-comment"> * 功能描述:  通过使用map、flatMap把字符串转换为字符输出对比区别</span><br><span class="hljs-comment"> * @return : void</span><br><span class="hljs-comment"> */</span><br>@Test<br>public void flat<span class="hljs-constructor">Map2Map()</span>&#123;<br>    List&lt;String&gt; strings = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;bc&quot;</span>, <span class="hljs-string">&quot;efg&quot;</span>, <span class="hljs-string">&quot;abcd&quot;</span>,<span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>)</span>;<br>    final Stream&lt;Character&gt; flatMap = strings.stream<span class="hljs-literal">()</span>.flat<span class="hljs-constructor">Map(Java8StreamTest::<span class="hljs-params">getCharacterByString</span>)</span>;<br>    flatMap.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;<br>    <span class="hljs-comment">//----------------------------------------------</span><br>    final Stream&lt;Stream&lt;Character&gt;&gt; mapStream = strings.stream<span class="hljs-literal">()</span>.map(Java8StreamTest::getCharacterByString);<br>    <span class="hljs-comment">//mapStream.forEach(System.out::println);</span><br>    out.println(<span class="hljs-string">&quot;------------------------------------------------&quot;</span>);<br>    mapStream.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(<span class="hljs-params">stream</span>-&gt; &#123;<span class="hljs-params">stream</span>.<span class="hljs-params">forEach</span>(<span class="hljs-params">character</span>-&gt;&#123;System.<span class="hljs-params">out</span>.<span class="hljs-params">println</span>(<span class="hljs-params">character</span>)</span>;&#125;);&#125;);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote></blockquote><p>公共方法（字符串转换为字符流）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 功能描述:字符串转换为字符流</span><br><span class="hljs-comment">* @param str</span><br><span class="hljs-comment">* @return : java.util.stream.Stream&lt;java.lang.Character&gt;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">public</span> static Stream&lt;<span class="hljs-type">Character</span>&gt; getCharacterByString(String str) &#123;<br>    List&lt;<span class="hljs-type">Character</span>&gt; characterList = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Character</span> <span class="hljs-type">character</span> : str.toCharArray()) &#123;<br>    characterList.<span class="hljs-keyword">add</span>(<span class="hljs-type">character</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> characterList.stream();<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="终止操作符"><a href="#终止操作符" class="headerlink" title="终止操作符"></a>终止操作符</h3><table><thead><tr><th>流方法</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>anyMatch</td><td>检查是否至少匹配一个元素，返回boolean。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“abc”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);boolean b &#x3D; strings.stream().anyMatch(s -&gt; s &#x3D;&#x3D; “abc”);</td></tr><tr><td>allMatch</td><td>检查是否匹配所有元素，返回boolean。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“abc”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);boolean b &#x3D; strings.stream().allMatch(s -&gt; s &#x3D;&#x3D; “abc”);</td></tr><tr><td>noneMatch</td><td>检查是否没有匹配所有元素，返回boolean。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“abc”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);boolean b &#x3D; strings.stream().noneMatch(s -&gt; s &#x3D;&#x3D; “abc”);</td></tr><tr><td>findAny</td><td>将返回当前流中的任意元素。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“cv”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);Optional&lt;String&gt; any &#x3D; strings.stream().findAny();</td></tr><tr><td>findFirst</td><td>返回第一个元素</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“cv”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);Optional&lt;String&gt; first &#x3D; strings.stream().findFirst();</td></tr><tr><td>forEach</td><td>遍历流</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“cv”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);strings.stream().forEach(s -&gt; out.println(s));</td></tr><tr><td>collect</td><td>收集器，将流转换为其他形式。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“cv”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);Set&lt;String&gt; set &#x3D; strings.stream().collect(Collectors.toSet());List&lt;String&gt; list &#x3D; strings.stream().collect(Collectors.toList());Map&lt;String, String&gt; map &#x3D; strings.stream().collect(Collectors.toMap(v -&gt;v.concat(“_name”), v1 -&gt; v1, (v1, v2) -&gt; v1));</td></tr><tr><td>reduce</td><td>可以将流中元素反复结合起来，得到一个值。使用 reduce((T, T) -&gt; T) 和 reduce(T, (T, T) -&gt; T) 用于组合流中的元素，如求和，求积，求最大值等。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“cv”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);Optional&lt;String&gt; reduce &#x3D; strings.stream().reduce((acc,item) -&gt; {return acc+item;});if(reduce.isPresent())out.println(reduce.get());</td></tr><tr><td>count</td><td>返回流中元素总数。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“cv”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);long count &#x3D; strings.stream().count();</td></tr></tbody></table><blockquote></blockquote><p>示例代码<br>1）anyMatch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述 : 判断集合中是否至少存在一个元素满足条件<br>* @return : void<br>*/<br>  @Test<br>  public void anyMatch()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;abd&quot;, &quot;aba&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  boolean b = strings.stream().anyMatch(s -&gt; s == &quot;abc&quot;);<br>  out.println(b);<br>  &#125;<br></code></pre></td></tr></table></figure><p>2）allMatch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述 : 判断集合中是否所有元素都满足条件<br>* @return : void<br>*/<br>  @Test<br>  public void allMatch()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;abd&quot;, &quot;aba&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  boolean b = strings.stream().allMatch(s -&gt; s == &quot;abc&quot;);<br>  out.println(b);<br>  &#125;<br></code></pre></td></tr></table></figure><p>3）noneMatch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述 : 判断集合中是否所有元素都不满足条件<br>* @return : void<br>*/<br>  @Test<br>  public void noneMatch()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;abd&quot;, &quot;aba&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  boolean b = strings.stream().noneMatch(s -&gt; s == &quot;abc&quot;);<br>  out.println(b);<br>  &#125;<br></code></pre></td></tr></table></figure><p>4）findAny</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述 : 返回当前流中任意元素<br>* @return : void<br>*/<br>  @Test<br>  public void findAny()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;cv&quot;, &quot;abd&quot;, &quot;aba&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  Optional&lt;String&gt; any = strings.stream().findAny();<br>  if(any.isPresent()) out.println(any.get());<br>  &#125;<br></code></pre></td></tr></table></figure><p>5）findFirst</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述 : 返回当前流中第一个元素<br>* @return : void<br>*/<br>  @Test<br>  public void findFirst()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;cv&quot;, &quot;abd&quot;, &quot;aba&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  Optional&lt;String&gt; first = strings.stream().findFirst();<br>  if(first.isPresent()) out.println(first.get());<br>  &#125;<br></code></pre></td></tr></table></figure><p>6）forEach java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述 : 遍历流<br>* @return : void<br>*/<br>  @Test<br>  public void foreach()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;cv&quot;, &quot;abd&quot;, &quot;aba&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  strings.stream().forEach(s -&gt; out.println(s));<br>  &#125;<br></code></pre></td></tr></table></figure><p>7）collect</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述 : 流转换为其他形式<br>* @return : void<br>*/<br>  @Test<br>  public void collect()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;cv&quot;, &quot;abd&quot;, &quot;aba&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  Set&lt;String&gt; set = strings.stream().collect(Collectors.toSet());<br>  List&lt;String&gt; list = strings.stream().collect(Collectors.toList());<br>  Map&lt;String, String&gt; map = strings.stream().collect(Collectors.toMap(v -&gt;v.concat(&quot;_name&quot;), v1 -&gt; v1, (v1, v2) -&gt; v1));<br>  out.println(set);<br>  out.println(list);<br>  out.println(map);<br>  &#125;<br></code></pre></td></tr></table></figure><p>8）reduce</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述 : 将流中元素反复结合起来，得到一个值<br>* @return : void<br>*/<br>  @Test<br>  public void reduce()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;cv&quot;, &quot;abd&quot;, &quot;aba&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  //reduce方法一<br>  Optional&lt;String&gt; reduce1 = strings.stream().reduce((acc,item) -&gt; &#123;return acc+item;&#125;);<br>  //reduce方法二<br>  String reduce2 = strings.stream().reduce(&quot;itcast&quot;, (acc, item) -&gt; &#123;<br>  return acc + item;<br>  &#125;);<br>  //reduce方法三<br>  ArrayList&lt;String&gt; reduce3 = strings.stream().reduce(<br>  new ArrayList&lt;String&gt;(),<br>  new BiFunction&lt;ArrayList&lt;String&gt;, String, ArrayList&lt;String&gt;&gt;() &#123;<br>  @Override<br>  public ArrayList&lt;String&gt; apply(ArrayList&lt;String&gt; acc, String item) &#123;<br>  acc.add(item);<br>  return acc;<br>  &#125;<br>  &#125;,<br>  new BinaryOperator&lt;ArrayList&lt;String&gt;&gt;() &#123;<br>  @Override<br>  public ArrayList&lt;String&gt; apply(ArrayList&lt;String&gt; acc, ArrayList&lt;String&gt; item) &#123;<br>  return acc;<br>  &#125;<br>  &#125;<br>  );<br>  if(reduce1.isPresent())out.println(reduce1.get());<br>  out.println(reduce2);<br>  out.println(reduce3);<br>  &#125;<br></code></pre></td></tr></table></figure><p>9）count</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 功能描述 : 返回流中元素总数</span><br><span class="hljs-comment">* @return : void</span><br><span class="hljs-comment">*/</span><br>  @Test<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">count</span>()&#123;<br>  List&lt;String&gt; strings = Arrays.<span class="hljs-keyword">asList</span>(<span class="hljs-string">&quot;cv&quot;</span>, <span class="hljs-string">&quot;abd&quot;</span>, <span class="hljs-string">&quot;aba&quot;</span>, <span class="hljs-string">&quot;efg&quot;</span>, <span class="hljs-string">&quot;abcd&quot;</span>,<span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>);<br>  <span class="hljs-keyword">long</span> <span class="hljs-keyword">count</span> = strings.stream().<span class="hljs-keyword">count</span>();<br>  out.<span class="hljs-keyword">println</span>(<span class="hljs-keyword">count</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><p>注意：文章中因排序部分用到外部比较器，需要导入外部jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--apache集合操作工具包--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections4<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h1 id="https-www-cnblogs-com-shoshana-kong-p-14406683-html"><a href="#https-www-cnblogs-com-shoshana-kong-p-14406683-html" class="headerlink" title="https://www.cnblogs.com/shoshana-kong/p/14406683.html"></a><a href="https://www.cnblogs.com/shoshana-kong/p/14406683.html">https://www.cnblogs.com/shoshana-kong/p/14406683.html</a></h1>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>①Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8新特性</tag>
      
      <tag>Stream流代替for循环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO流、序列化、反序列化</title>
    <link href="/2022/10/21/IO%E6%B5%81%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2022/10/21/IO%E6%B5%81%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="IOStream"><a href="#IOStream" class="headerlink" title="IOStream"></a>IOStream</h1><p>1.字节流（操作字节）</p><p>字节流的抽象父类</p><p>InputStream</p><p>OutputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteCopy<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;jietu.png&quot;</span>);<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;copy.png&quot;</span>);<br><br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<span class="hljs-comment">//“容器”</span><br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len=fis.read(bytes))!=-<span class="hljs-number">1</span>)&#123;<br>            fos.write(bytes,<span class="hljs-number">0</span>,len);<br>        &#125;<br>        fos.close();<br>        fis.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>BufferedInputStream类</p><p>BufferedOutputStream类</p><p>BufferedInputStream内置了一个缓冲区（数组）</p><p>从BufferedInputStream中读取一个字节时BufferedInputStream会一次性从文件中读取8192个，存在缓冲区中，每次返回给程序一个</p><p>程序再次读取时，就不用找文件了，直接从缓冲区中获取，知道缓冲区中所有的都被使用过，才重新从文件中读取8192个。</p><p>BufferedOutputStream也内置了一个缓冲区（数组）</p><p>程序向流中写出字节时，不会直接写到文件，先写到缓冲区中，知道缓冲区写满，BufferedOutputStream才会吧缓冲区中的数据一次</p><p>性写到文件里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">BufferCopy<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test5</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;jietu.png&quot;</span>);<br>    <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;copy.png&quot;</span>);<br>    <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fos);<br>    <br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-keyword">while</span> ((b = bis.read()) != -<span class="hljs-number">1</span>) &#123;<br>        bos.write(b);<br>    &#125;<br><br>    bis.close();<span class="hljs-comment">//close方法具备刷新的功能，在关闭之前们就会先刷新一次缓冲区，将缓冲区的字节全部都刷新到文件上，再关闭</span><br>    bos.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>字节流读取中文时是可能有问题的，因为有时可能会读到半个中文造成乱码。</p><p>输入输出的标准代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span>()</span>&#123;<br>    FileInputStream fis;<br>    FileOutputStream fos;<br>    <span class="hljs-keyword">try</span> &#123;<br>        fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;jietu.png&quot;</span>);<br>        fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;copy.png&quot;</span>);<br>        <span class="hljs-built_in">int</span> b;<br>        <span class="hljs-keyword">while</span> ((b = fis.read()) != <span class="hljs-number">-1</span>) &#123;<br>            fos.write(b);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(bis != <span class="hljs-literal">null</span>)<br>            fis.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                fos.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>2.字符流（操作字符）</p><p>字符流的抽象父类</p><p>Reader类</p><p>Writer类</p><p>DateInputStream类</p><p>DateOutputStream类</p><p>4.IO程序书写</p><p>使用前，导入IO包中的类</p><p>使用时，进行IO异常处理</p><p>使用后，释放资源</p><h1 id="Serializable（json、ProtoBuf）"><a href="#Serializable（json、ProtoBuf）" class="headerlink" title="Serializable（json、ProtoBuf）"></a>Serializable（json、ProtoBuf）</h1><p>(Java序列化就是指把Java对象转换为字节序列的过程</p><p>Java反序列化就是指把字节序列恢复为Java对象的过程。</p><p>序列化最重要的作用：在传递和保存对象时.保证对象的完整性和可传递性。对象转换为有序字节流,以便在网络上传输或者保存在本地文件中。</p><p>反序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。</p><p>总结：核心作用就是对象状态的保存和重建。（整个过程核心点就是字节流中所保存的对象状态及描述信息）</p><p>实体类序列化</p><p>对象序列化：ObjectOutputStream类</p><p>对象反序列化：ObjectInputStream类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>:</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: Kblayt</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@time</span>: 2022/2/28 11:29</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final long serialVersionUID = -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> <span class="hljs-title class_">Name</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> <span class="hljs-title class_">Age</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Name</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>) &#123;<br>        <span class="hljs-title class_">Name</span> = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getAge</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Age</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setAge</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> age</span>) &#123;<br>        <span class="hljs-title class_">Age</span> = age;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_">String</span> name, <span class="hljs-title class_">String</span> age) &#123;<br>        <span class="hljs-title class_">Name</span> = name;<br>        <span class="hljs-title class_">Age</span> = age;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>:序列化和反序列化</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: Kblayt</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@time</span>: 2022/2/28 11:32</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-comment">//序列化</span><br>        FileOutputStream fos;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;object.out&quot;</span>);<br>            oos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(fos);<br>            s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;lhg&quot;</span>,<span class="hljs-string">&quot;18&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                oos.writeObject(s1);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                oos.flush();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                oos.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//反序列化</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;object.out&quot;</span>);<br>            ois = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(fis);<br>            <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> (Student) ois.readObject();<br>            System.out.println(s2.getName()+<span class="hljs-string">&quot;&quot;</span>+s2.getAge());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            ois.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>①Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO流</tag>
      
      <tag>序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2022/10/20/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2022/10/20/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一遍博客文章</title>
    <link href="/2022/10/18/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E9%81%8D%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <url>/2022/10/18/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E9%81%8D%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章节"><a href="#第一章节" class="headerlink" title="第一章节"></a>第一章节</h2><p>内容</p><hr><h2 id="第二章节"><a href="#第二章节" class="headerlink" title="第二章节"></a>第二章节</h2><p>内容</p><hr><p>##参考文献</p><p><a href="http://www.bing.com/">www.bing.com</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>①Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/10/18/hello-world/"/>
    <url>/2022/10/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
