<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2022/10/21/Git/"/>
    <url>/2022/10/21/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="1、版本控制"><a href="#1、版本控制" class="headerlink" title="1、版本控制"></a>1、版本控制</h1><h2 id="1-1、什么是版本控制"><a href="#1-1、什么是版本控制" class="headerlink" title="1.1、什么是版本控制"></a>1.1、什么是版本控制</h2><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><ul><li><p>实现跨区域多人协同开发</p></li><li><p>追踪和记载一个或者多个文件的历史记录</p></li><li><p>组织和保护你的源代码和文档</p></li><li><p>统计工作量</p></li><li><p>并行开发、提高开发效率</p></li><li><p>跟踪记录整个软件的开发过程</p></li><li><p>减轻开发人员的负担，节省时间，同时降低人为错误</p></li></ul><p>简单说就是用于管理多人协同开发项目的技术。</p><p>没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。</p><p>无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段！我们就迫切需要一个版本控制工具！</p><p><img src="/2022/10/21/Git/WEBRESOURCE5781b88d50a965f6baa98c08f3bdc81d.jpeg"></p><p>多人开发就必须要使用版本控制！</p><h2 id="1-2、常见的版本控制工具"><a href="#1-2、常见的版本控制工具" class="headerlink" title="1.2、常见的版本控制工具"></a>1.2、常见的版本控制工具</h2><p>我们学习的东西，一定是当下最流行的！</p><p>主流的版本控制器有如下这些：</p><ul><li><p>Git</p></li><li><p>SVN（Subversion）</p></li><li><p>CVS（Concurrent Versions System）</p></li><li><p>VSS（Micorosoft Visual SourceSafe）</p></li><li><p>TFS（Team Foundation Server）</p></li><li><p>Visual Studio Online</p></li></ul><p>版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN</p><h2 id="1-3版本控制分类"><a href="#1-3版本控制分类" class="headerlink" title="1.3版本控制分类"></a>1.3版本控制分类</h2><h3 id="1-3-1、本地版本控制"><a href="#1-3-1、本地版本控制" class="headerlink" title="1.3.1、本地版本控制"></a>1.3.1、本地版本控制</h3><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p><p><img src="/2022/10/21/Git/WEBRESOURCE34d172540721e9729fe384f7eed4653a.png"></p><h3 id="1-3-2、集中版本控制-SVN"><a href="#1-3-2、集中版本控制-SVN" class="headerlink" title="1.3.2、集中版本控制  SVN"></a>1.3.2、集中版本控制  SVN</h3><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p><p><img src="/2022/10/21/Git/WEBRESOURCE6a78ce9141d1732ca8bd879058b34116.png"></p><p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p><h3 id="1-3-3、分布式版本控制-Git"><a href="#1-3-3、分布式版本控制-Git" class="headerlink" title="1.3.3、分布式版本控制 Git"></a>1.3.3、分布式版本控制 Git</h3><p>每个人都拥有全部的代码！安全隐患！</p><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p><p><img src="/2022/10/21/Git/WEBRESOURCEacdf78d4e5d49ec15b4e1d76fb8cc1c3.jpeg"></p><h2 id="1-4、Git与SVN的主要区别"><a href="#1-4、Git与SVN的主要区别" class="headerlink" title="1.4、Git与SVN的主要区别"></a>1.4、Git与SVN的主要区别</h2><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p><p><img src="/2022/10/21/Git/WEBRESOURCEd57ed7f0e43c5642ac5c107ea02ab7e4.jpeg"></p><p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p><p>Git是目前世界上最先进的分布式版本控制系统。</p><h1 id="2、聊聊Git的历史"><a href="#2、聊聊Git的历史" class="headerlink" title="2、聊聊Git的历史"></a>2、聊聊Git的历史</h1><p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p><p>Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p><p>Linux社区中存在很多的大佬！破解研究 BitKeeper ！</p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！</p><p>Git是目前世界上最先进的分布式版本控制系统。</p><p>Git是免费、开源的，最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper！</p><p><img src="/2022/10/21/Git/WEBRESOURCEe91ebf7ea6f112387a01257360b325ac.jpeg"></p><p>Linux和Git之父李纳斯·托沃兹（Linus Benedic Torvalds）1969、芬兰</p><h1 id="3、Git环境配置"><a href="#3、Git环境配置" class="headerlink" title="3、Git环境配置"></a>3、Git环境配置</h1><h2 id="3-1、软件下载"><a href="#3-1、软件下载" class="headerlink" title="3.1、软件下载"></a>3.1、软件下载</h2><p>打开 [git官网] <a href="https://git-scm.com/%EF%BC%8C%E4%B8%8B%E8%BD%BDgit%E5%AF%B9%E5%BA%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%88%E6%9C%AC%E3%80%82">https://git-scm.com/，下载git对应操作系统的版本。</a></p><p>所有东西下载慢的话就可以去找镜像！</p><p>官网下载太慢，我们可以使用淘宝镜像下载：<a href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a></p><p><img src="/2022/10/21/Git/WEBRESOURCE4e5f2652c7e918b34855c3feb6add319.jpeg"></p><p>下载对应的版本即可安装！</p><p>安装：无脑下一步即可！安装完毕就可以使用了！</p><h2 id="3-2、启动Git"><a href="#3-2、启动Git" class="headerlink" title="3.2、启动Git"></a>3.2、启动Git</h2><p>安装成功后在开始菜单中会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序！</p><p><img src="/2022/10/21/Git/WEBRESOURCEfee0d982805082ebdf7bc9e9af75f98e.png"></p><p>Git Bash：Unix与Linux风格的命令行，使用最多，推荐最多</p><p>Git CMD：Windows风格的命令行</p><p>Git GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</p><h2 id="3-3、常用的Linux命令"><a href="#3-3、常用的Linux命令" class="headerlink" title="3.3、常用的Linux命令"></a>3.3、常用的Linux命令</h2><p>平时一定要多使用这些基础的命令！</p><p>1）、cd : 改变目录。</p><p>2）、cd . . 回退到上一个目录，直接cd进入默认目录</p><p>3）、pwd : 显示当前所在的目录路径。</p><p>4）、ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。</p><p>5）、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</p><p>6）、rm:  删除一个文件, rm index.js 就会把index.js文件删除。</p><p>7）、mkdir:  新建一个目录,就是新建一个文件夹。</p><p>8）、rm -r :  删除一个文件夹, rm -r src 删除src目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf / 切勿在Linux中尝试！删除电脑中全部文件！<br></code></pre></td></tr></table></figure><p>9）、mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。</p><p>10）、reset 重新初始化终端&#x2F;清屏。</p><p>11）、clear 清屏。</p><p>12）、history 查看命令历史。</p><p>13）、help 帮助。</p><p>14）、exit 退出。</p><p>15）、#表示注释</p><h2 id="3-4、Git配置"><a href="#3-4、Git配置" class="headerlink" title="3.4、Git配置"></a>3.4、Git配置</h2><p>所有的配置文件，其实都保存在本地！</p><p>查看配置 git config -l</p><p><img src="/2022/10/21/Git/WEBRESOURCE4374aa416f84a58c58615b990a71854d.jpeg"></p><p>查看不同级别的配置文件：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">#查看系统configgit config</span> <span class="hljs-literal">--</span><span class="hljs-comment">system</span> <span class="hljs-literal">--</span><span class="hljs-comment">list　　#查看当前用户（global）配置git config</span> <span class="hljs-literal">--</span><span class="hljs-comment">global</span>  <span class="hljs-literal">--</span><span class="hljs-comment">list</span><br></code></pre></td></tr></table></figure><p>Git相关的配置文件：</p><p>1）、Git\etc\gitconfig  ：Git 安装目录下的 gitconfig     –system 系统级</p><p>2）、C:\Users\Administrator\ .gitconfig    只适用于当前登录用户的配置  –global 全局</p><p><img src="/2022/10/21/Git/WEBRESOURCEd020d58a5afd538f9c1cee8175e564e9.png"></p><p>这里可以直接编辑配置文件，通过命令设置后会响应到这里。</p><h2 id="设置用户名与邮箱（用户标识，必要）"><a href="#设置用户名与邮箱（用户标识，必要）" class="headerlink" title="设置用户名与邮箱（用户标识，必要）"></a>设置用户名与邮箱（用户标识，必要）</h2><p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;kuangshen&quot;</span>  #名称git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-number">24736743</span>@qq<span class="hljs-selector-class">.com</span>   #邮箱<br></code></pre></td></tr></table></figure><p>只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="></p><h1 id="4、Git基本理论（重要）"><a href="#4、Git基本理论（重要）" class="headerlink" title="4、Git基本理论（重要）"></a>4、Git基本理论（重要）</h1><h2 id="4-1、三个区域"><a href="#4-1、三个区域" class="headerlink" title="4.1、三个区域"></a>4.1、三个区域</h2><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage&#x2F;Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p><p><img src="/2022/10/21/Git/WEBRESOURCE0d40cd8de9988128d9d781f435577e6f.png"></p><ul><li><p>Workspace：工作区，就是你平时存放项目代码的地方</p></li><li><p>Index &#x2F; Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</p></li><li><p>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</p></li><li><p>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</p></li></ul><p>本地的三个区域确切的说应该是git仓库中HEAD指向的版本：</p><p><img src="/2022/10/21/Git/WEBRESOURCE02d33c7ff37bb246e0606c21dd83d0ce.png"></p><ul><li><p>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</p></li><li><p>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</p></li><li><p>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</p></li><li><p>Index&#x2F;Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</p></li><li><p>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</p></li><li><p>Stash：隐藏，是一个工作状态保存栈，用于保存&#x2F;恢复WorkSpace中的临时状态。</p></li></ul><h2 id="4-2、工作流程"><a href="#4-2、工作流程" class="headerlink" title="4.2、工作流程"></a>4.2、工作流程</h2><p>git的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；</p><p>２、将需要进行版本管理的文件放入暂存区域；</p><p>３、将暂存区域的文件提交到git仓库。</p><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="></p><h1 id="5、Git项目搭建"><a href="#5、Git项目搭建" class="headerlink" title="5、Git项目搭建"></a>5、Git项目搭建</h1><h2 id="5-1、创建工作目录与常用指令"><a href="#5-1、创建工作目录与常用指令" class="headerlink" title="5.1、创建工作目录与常用指令"></a>5.1、创建工作目录与常用指令</h2><p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p><p>日常使用只要记住下图6个命令：</p><p><img src="/2022/10/21/Git/WEBRESOURCE2cab9f228518b50c6c129094774c1d19.png"></p><h2 id="5-2、本地仓库搭建"><a href="#5-2、本地仓库搭建" class="headerlink" title="5.2、本地仓库搭建"></a>5.2、本地仓库搭建</h2><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><p>1、创建全新的仓库，需要用GIT管理的项目的根目录执行：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 在当前目录新建一个Git代码库$ git init</span><br></code></pre></td></tr></table></figure><p>2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p><h2 id="5-3、克隆远程仓库"><a href="#5-3、克隆远程仓库" class="headerlink" title="5.3、克隆远程仓库"></a>5.3、克隆远程仓库</h2><p>1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 克隆一个项目和它的整个代码历史(版本信息)$ git clone [url]  # https:<span class="hljs-comment">//gitee.com/kuangstudy/openclass.git</span><br></code></pre></td></tr></table></figure><p>2、去 gitee 或者 github 上克隆一个测试！</p><h1 id="6、Git文件操作"><a href="#6、Git文件操作" class="headerlink" title="6、Git文件操作"></a>6、Git文件操作</h1><h2 id="6-1、文件的四种状态"><a href="#6-1、文件的四种状态" class="headerlink" title="6.1、文件的四种状态"></a>6.1、文件的四种状态</h2><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><ul><li><p>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</p></li><li><p>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</p></li><li><p>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</p></li><li><p>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</p></li></ul><h2 id="6-2、查看文件状态"><a href="#6-2、查看文件状态" class="headerlink" title="6.2、查看文件状态"></a>6.2、查看文件状态</h2><p>上面说文件有4种状态，通过如下命令可以查看到文件的状态：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">#查看指定文件状态git status [filename]#查看所有文件状态git status# git add .                  添加所有文件到暂存区# git commit -m <span class="hljs-string">&quot;消息内容&quot;</span>    提交暂存区中的内容到本地仓库 -m 提交信息<br></code></pre></td></tr></table></figure><h2 id="6-3、忽略文件"><a href="#6-3、忽略文件" class="headerlink" title="6.3、忽略文件"></a>6.3、忽略文件</h2><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立”.gitignore”文件，此文件有如下规则：</p><ol><li><p>忽略文件中的空行或以井号（#）开始的行将会被忽略。</p></li><li><p>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</p></li><li><p>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</p></li><li><p>如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</p></li><li><p>如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</p></li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#为注释*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！!lib.txt     #但lib.txt除外<span class="hljs-regexp">/temp        #仅忽略项目根目录下的TODO文件,不包括其它目录tempbuild/</span>       #忽略build<span class="hljs-regexp">/目录下的所有文件doc/</span>*.txt    #会忽略 doc<span class="hljs-regexp">/notes.txt 但不包括 doc/</span>server/arch.txt<br></code></pre></td></tr></table></figure><h1 id="7、使用码云"><a href="#7、使用码云" class="headerlink" title="7、使用码云"></a>7、使用码云</h1><p>github 是有墙的，比较慢，在国内的话，我们一般使用 gitee ，公司中有时候会搭建自己的gitlab服务器</p><p>这个其实可以作为大家未来找工作的一个重要信息！</p><p>1、注册登录码云，完善个人信息</p><p>2、设置本机绑定SSH公钥，实现免密码登录！（免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！)</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 进入 C:\Users\Administrator\.ssh 目录# 生成公钥ssh-keygen<br></code></pre></td></tr></table></figure><p><img src="/2022/10/21/Git/WEBRESOURCE940564f6e1e011817aa5dbc800e7e8ac.jpeg"></p><p>3、将公钥信息public key 添加到码云账户中即可！</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="></p><p>4、使用码云创建一个自己的仓库！</p><p>许可证：开源是否可以随意转载，开源但是不能商业使用，不能转载，…  限制！</p><p>克隆到本地！</p><p><img src="/2022/10/21/Git/WEBRESOURCEfd19c479ccf30232601db572fb8f3c81.jpeg"></p><h1 id="8、IDEA中集成Git"><a href="#8、IDEA中集成Git" class="headerlink" title="8、IDEA中集成Git"></a>8、IDEA中集成Git</h1><h2 id="8-1、新建项目，绑定git。"><a href="#8-1、新建项目，绑定git。" class="headerlink" title="8.1、新建项目，绑定git。"></a>8.1、新建项目，绑定git。</h2><p><img src="/2022/10/21/Git/WEBRESOURCE04f24196c61b219edbb3e678cbac4781.jpeg"></p><p>注意观察idea中的变化</p><p><img src="/2022/10/21/Git/WEBRESOURCE87f45e62915ef55532164726f54fbbbb.png"></p><h2 id="8-2、修改文件，使用IDEA操作git。"><a href="#8-2、修改文件，使用IDEA操作git。" class="headerlink" title="8.2、修改文件，使用IDEA操作git。"></a>8.2、修改文件，使用IDEA操作git。</h2><ul><li><p>添加到暂存区</p></li><li><p>commit 提交</p></li><li><p>push到远程仓库</p></li></ul><h2 id="8-3、提交测试"><a href="#8-3、提交测试" class="headerlink" title="8.3、提交测试"></a>8.3、提交测试</h2><p>这些都是单个人的操作！</p><p>学习的方式最重要！学会学习！我上课的更多时候都是在教大家去学习一种理念和思想（学习方式）</p><p>有道无术、术尚可求。有术无道、止于术！</p><p>真正的教学，授人以渔！</p><h2 id="8-4、说明：GIT分支"><a href="#8-4、说明：GIT分支" class="headerlink" title="8.4、说明：GIT分支"></a>8.4、说明：GIT分支</h2><p>分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！</p><p><img src="/2022/10/21/Git/WEBRESOURCE938a99855af5fdf607f209749411aba8.png"></p><p><img src="/2022/10/21/Git/WEBRESOURCEe5506ec1efb324ac64ce8c7b74ec21e4.png"></p><p>git分支中常用指令：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 列出所有本地分支git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]<br></code></pre></td></tr></table></figure><h1 id="9、IDEA中操作"><a href="#9、IDEA中操作" class="headerlink" title="9、IDEA中操作"></a>9、IDEA中操作</h1><p><img src="/2022/10/21/Git/WEBRESOURCE24a92beaa781c9bef1cc5d9227a4adc1.png"></p><p>如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！</p><p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>]]></content>
    
    
    <categories>
      
      <category>项目管理工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>红黑树(RBT)</title>
    <link href="/2022/10/21/%E7%BA%A2%E9%BB%91%E6%A0%91-RBT/"/>
    <url>/2022/10/21/%E7%BA%A2%E9%BB%91%E6%A0%91-RBT/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java反射与XML&amp;JSON</title>
    <link href="/2022/10/21/Java%E5%8F%8D%E5%B0%84%E4%B8%8EXML-Json/"/>
    <url>/2022/10/21/Java%E5%8F%8D%E5%B0%84%E4%B8%8EXML-Json/</url>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="类的加载概述和分类"><a href="#类的加载概述和分类" class="headerlink" title="类的加载概述和分类"></a>类的加载概述和分类</h2><h4 id="1-类加载的概述"><a href="#1-类加载的概述" class="headerlink" title="1.类加载的概述"></a>1.类加载的概述</h4><p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，链接，初始化三步来实现对这个类进行初始化。</p><p>加载</p><p>就是指class文件读入内存，并且为之创建一个Class对象。任何类被使用时系统都会建立一个class对象。</p><p>链接</p><p>验证 是否有正确的内部结构，并和其它类协调一致。</p><p>准备 负责为类的静态成员分配内村，并设置默认初始化值。</p><p>解析 酱类的二进制数据中的符号引用替换为直接引用</p><p>初始化</p><p>默认初始化、显式初始化、构造方法初始化等等。</p><h4 id="2-加载时机"><a href="#2-加载时机" class="headerlink" title="2.加载时机"></a>2.加载时机</h4><p>创建类的实例（Person p &#x3D; new Person()）</p><p>访问类的静态变量，或者为静态变量赋值（p.静态变量 或者 p.静态变量 &#x3D; 0；）</p><p>调用类的静态方法</p><p>使用反射方式来强制创建某个类或接口对应的java.long.Class对象</p><p>初始化某个类的子类</p><p>直接使用java.exe命令来运行某个主类</p><h4 id="3-类加载器的概述"><a href="#3-类加载器的概述" class="headerlink" title="3.类加载器的概述"></a>3.类加载器的概述</h4><p>负责将.class文件加载到内存中，并为之生成对应的Class对象，虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好地理解程序的运行。</p><h4 id="4-类加载器的分类"><a href="#4-类加载器的分类" class="headerlink" title="4.类加载器的分类"></a>4.类加载器的分类</h4><p>Bootstrap ClassLoader 根类加载器</p><p>Extension ClassLoader 扩展类加载器</p><p>System ClassLoader 系统类加载器</p><h4 id="5-类加载器的作用"><a href="#5-类加载器的作用" class="headerlink" title="5.类加载器的作用"></a>5.类加载器的作用</h4><p>Bootstrap ClassLoader 根类加载器</p><p>也被称为引导类加载器，负责Java核心类的加载</p><p>比如System，String等。在JDK中JRE的lib目录下rt.jar文件中</p><p>Extension ClassLoader扩展类加载器</p><p>负责JRE的扩展目录中jar的加载</p><p>在JDK中JRE的lib目录下ext目录</p><p>System ClassLoader 系统类加载器</p><p>负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径</p><h2 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a>反射概述</h2><p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；</p><p>对于任意一个对象，都能够调用它的任意一个方法和属性；</p><p>这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><p>要想解剖一个类，就必须要获取到该类的字节码文件对象</p><p>而解剖使用的就是Class类中的方法，所以要先获取到每一个字节码文件对应的Class类型对象。</p><h4 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h4><p>1.Object类的getClass()方法，判断两个对象是否时同一个字节码文件</p><p>2.静态属性class，锁对象</p><p>3.Class类中静态方法forName(),读取配置文件</p><p><img src="/2022/10/21/Java%E5%8F%8D%E5%B0%84%E4%B8%8EXML-Json/WEBRESOURCE59d8c4c388d4fa76527dcf6a69038ba1.png"></p><p><img src="/2022/10/21/Java%E5%8F%8D%E5%B0%84%E4%B8%8EXML-Json/WEBRESOURCE7903b6f0673f48b511e7f09f5aa7aab0.png"></p><h4 id="通过反射获取带参构造方法并使用"><a href="#通过反射获取带参构造方法并使用" class="headerlink" title="通过反射获取带参构造方法并使用"></a>通过反射获取带参构造方法并使用</h4><p>Constructor</p><p>Class类的newInstance()方法是使用该无参的构造函数创建对象，如果一个类没有无参的构造函数，就不能这样创建了，可以调用Class类的getConstructor（String.class,int.class）方法获取一个指定的构造函数然后再调用Constructor类的newInstance(“张三”，20)方法创建对象</p><h4 id="通过反射获取成员变量并使用"><a href="#通过反射获取成员变量并使用" class="headerlink" title="通过反射获取成员变量并使用"></a>通过反射获取成员变量并使用</h4><p>Field</p><p>Class.getField(String)方法可以获取类中的指定字段(可见的)，如果时私有的可以用getDeclaedField(“name”)方法获取，通过set(obj，”李四”)方法可以设置指定对象上该字段的值，如果是私有的需要先调用setAccessible(true)设置访问权限，用获取的指定的字段调用get(obj)可以获取指定对象中该字段的值</p><h4 id="通过反射获取方法并使用"><a href="#通过反射获取方法并使用" class="headerlink" title="通过反射获取方法并使用"></a>通过反射获取方法并使用</h4><p>Method</p><p>Class.getMethod(String，Class…)和Class.getDeclareMethod(String,Class…)方法可以获取类中的指定方法，调用invoke(object，object…)可以调用该法ing发，Class.getMethod(”eat“)invoke(obj)Class.getMethod(“eat”，int.class)invoke(obj,10)</p><h1 id="XML-amp-JSON"><a href="#XML-amp-JSON" class="headerlink" title="XML&amp;JSON"></a>XML&amp;JSON</h1><h2 id="XML（EXtensible-Markup-Language）"><a href="#XML（EXtensible-Markup-Language）" class="headerlink" title="XML（EXtensible Markup Language）"></a>XML（EXtensible Markup Language）</h2><p>可扩展标记语言</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>与操作系统、编程语言的开发平台无关</p><p>实现不同系统之间的数据交换</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>数据交互</p><p>配置应用程序和网站</p><p>Ajax基石</p><h4 id="XML文档内容由一系列标签元素组成"><a href="#XML文档内容由一系列标签元素组成" class="headerlink" title="XML文档内容由一系列标签元素组成"></a>XML文档内容由一系列标签元素组成</h4><p>&lt;元素名 属性名&#x3D;”属性值“&gt;元素内容&lt;&#x2F;元素名&gt;</p><![CDATA[内容......]]><p>xml命名空间的作用</p><h4 id="解析XML技术"><a href="#解析XML技术" class="headerlink" title="解析XML技术"></a>解析XML技术</h4><p>DOM</p><p>基于XML文档树结构的解析</p><p>适用于多次访问的XML文档</p><p>特点：速度快，比较消耗资源</p><p>SAX</p><p>基于事件的解析</p><p>适用于大数据量的XML文档</p><p>特点：占用资源少，内存消耗小</p><p>DOM4J（主流）</p><p>非常优秀的Java XML API</p><p>性能优异、功能强大</p><p>开放源代码</p><p>DOM解析XML文件步骤</p><h2 id="JSON-JavaScript-Object-Notation"><a href="#JSON-JavaScript-Object-Notation" class="headerlink" title="JSON(JavaScript Object Notation)"></a>JSON(JavaScript Object Notation)</h2><p>轻量级的文本数据交换格式</p><p>具有自我描述性</p><p>比XML传输速度快</p><p>阿里开源JSON解析框架</p><p>FastJSON</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>反射</tag>
      
      <tag>XML</tag>
      
      <tag>JSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程和网络编程</title>
    <link href="/2022/10/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/10/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程（Thread）"><a href="#多线程（Thread）" class="headerlink" title="多线程（Thread）"></a>多线程（Thread）</h1><h2 id="1-什么是线程、主线程和其他子线程"><a href="#1-什么是线程、主线程和其他子线程" class="headerlink" title="1.什么是线程、主线程和其他子线程"></a>1.什么是线程、主线程和其他子线程</h2><p>线程是程序执行的一条路径，一个进程中可以包含多条线程</p><p>多线程并发执行可以提高程序的效率，可以同时完成多项工作</p><p>main()方法即为主线程入口</p><h2 id="2-多线程并行和并发的区别"><a href="#2-多线程并行和并发的区别" class="headerlink" title="2.多线程并行和并发的区别"></a>2.多线程并行和并发的区别</h2><p>并行是指两个任务同时进行，就是甲任务进行的同时，乙任务也在进行。（需多核CPU）</p><p>并发是指两个任务都请求运行，而处理器只能接受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。</p><h2 id="3-Java程序运行原理和JVM的启动是多线程的吗？"><a href="#3-Java程序运行原理和JVM的启动是多线程的吗？" class="headerlink" title="3.Java程序运行原理和JVM的启动是多线程的吗？"></a>3.Java程序运行原理和JVM的启动是多线程的吗？</h2><p>A：Jva程序运行原理</p><p>Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。该进程会自动启动一个”主线程“，然后主线程去调用某个类的main方法。</p><p>B：JVM的启动是多线程的吗</p><p>JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。</p><h2 id="4-多线程程序实现的方式"><a href="#4-多线程程序实现的方式" class="headerlink" title="4.多线程程序实现的方式"></a>4.多线程程序实现的方式</h2><p>①继承Thread(无返回值)</p><p>定义类继承Thread</p><p>重写run()方法</p><p>把新线程要做的事写在run()方法中</p><p>创建线程对象</p><p>开启新线程，内部会自动执行run()方法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        MyThread mt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyThread</span>();                   <span class="hljs-comment">//4.创建Thread类的子类对象</span><br>        mt.<span class="hljs-built_in">start</span>();                                     <span class="hljs-comment">//5.开启线程</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">1000</span>; i++)&#123;<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;bbbbbbb&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;               <span class="hljs-comment">//1.继承Thread</span><br>    public void run()&#123;                              <span class="hljs-comment">//2.重写run方法</span><br>        <span class="hljs-keyword">for</span> (int i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">1000</span>; i++)&#123;                 <span class="hljs-comment">//3.将要执行的代码写在run方法中</span><br>            <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;aaaaaaaa&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>②实现Runnable接口(无返回值)</p><p>定义实现Runnable接口</p><p>实现run()方法</p><p>把新线程要做的事写在run()方法中</p><p>创建自定义的Runnable的子类对象</p><p>创建Thread对象，传入Runnable</p><p>调用start()开启新线程，内部会自动调用Runnable的run()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">mr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();            <span class="hljs-comment">//4.创建Runnable的子类对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mr);                  <span class="hljs-comment">//5.将子类对象当作参数传递给Thread的构造函数</span><br>        t.start();                                   <span class="hljs-comment">//6.开启线程</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">1000</span>; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;bbbbbbb&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">MyRunnable</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Runnable</span>&#123;        <span class="hljs-comment">//1.定义一个类实现Runnable</span><br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> run() &#123;                             <span class="hljs-comment">//2.重写run方法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">1000</span>; i++)&#123;                 <span class="hljs-comment">//3.将要执行的代码写在run方法中</span><br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;aaaaaaaa&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>③Callable方式(有返回值)</p><h2 id="5-两种方式的区别"><a href="#5-两种方式的区别" class="headerlink" title="5.两种方式的区别"></a>5.两种方式的区别</h2><p>查看源码的区别：</p><p>①继承Thread：由于子类重写了Thread类的run()，当调用start()时，直接找子类的run()方法</p><p>②实现Runnable：构造函数中传入了Runnable的引用，成员变量记住了它，start()调用run()方法时内部判断成员变量Runnable的引用是否为空，不为空编译时看的时Runnable的run()，运行时执行的是子类的run()方法。</p><p>继承Thread</p><p>好处是：可以直接使用Thread类中的方法，代码简单</p><p>弊端是：如果已经有了父类，就不能用这种方法</p><p>实现Runnable接口</p><p>好处是：即使自己定义的线程类有了父类也没关系，因为有了父类也可以实现接口，而且接口是可以多实现的</p><p>弊端是：不能直接使用Thread中的方法需要先获取到线程对象后，才能得到Thread的方法，代码复杂</p><h2 id="6-匿名内部类实现线程的两种方式"><a href="#6-匿名内部类实现线程的两种方式" class="headerlink" title="6.匿名内部类实现线程的两种方式"></a>6.匿名内部类实现线程的两种方式</h2><p>①继承(extends)Thread类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        <span class="hljs-keyword">new</span> Thread()&#123;                                       <span class="hljs-comment">//1.继承Thread类</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;                             <span class="hljs-comment">//2.重写run方法</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            <span class="hljs-comment">//3.将执行的代码写入run方法中</span><br>                    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;aaaaaaaaaaaaa&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;.start();                                          <span class="hljs-comment">//4.开启线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>②实现(implement)Runnable接口（可实现数据共享）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable()&#123;                          <span class="hljs-comment">//1.将Runnable的子类对象传递给Thread的构造方法</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span>&#123;                              <span class="hljs-comment">//2.重写run方法</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            <span class="hljs-comment">//3.将执行的代码写入run方法中</span><br>                    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;bbbbbbbbbb&quot;</span>);       <br>                &#125;<br>            &#125;<br>        &#125;).start();                                         <span class="hljs-comment">//4.开启线程</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>③(有返回值)</p><h2 id="7-线程的getName-、setName-、currentThread-方法"><a href="#7-线程的getName-、setName-、currentThread-方法" class="headerlink" title="7.线程的getName()、setName()、currentThread()方法"></a>7.线程的getName()、setName()、currentThread()方法</h2><p>currentThread()方法用于Runnable中，使之可以顺利的执行getName()、setName()方法。</p><h2 id="8-休眠线程"><a href="#8-休眠线程" class="headerlink" title="8.休眠线程"></a>8.休眠线程</h2><p>Thread.sleep(毫秒,纳秒)，控制当前线程休眠若干毫秒1s&#x3D;1000毫秒&#x3D;1000<em>1000</em>1000纳秒</p><h2 id="9-守护线程"><a href="#9-守护线程" class="headerlink" title="9.守护线程"></a>9.守护线程</h2><h2 id="10-线程的状态转换-五个状态"><a href="#10-线程的状态转换-五个状态" class="headerlink" title="10.线程的状态转换(五个状态)"></a>10.线程的状态转换(五个状态)</h2><h2 id="11-线程调度"><a href="#11-线程调度" class="headerlink" title="11.线程调度"></a>11.线程调度</h2><p>void setPriority(int newPriority)</p><p>static void sleep(long millis)</p><p>void join()强制</p><p>static void yield()”礼让“</p><p>void interrupt()</p><h2 id="12-锁synchronized"><a href="#12-锁synchronized" class="headerlink" title="12.锁synchronized"></a>12.锁synchronized</h2><p>①public synchronized void 方法名(){</p><p>}</p><p>②同步代码块</p><p>synchronized（this）{</p><p>&#x2F;&#x2F;所控制的变量或代码块</p><p>}</p><h1 id="网络编程（socket）-传输层）（TCP-x2F-IP）"><a href="#网络编程（socket）-传输层）（TCP-x2F-IP）" class="headerlink" title="网络编程（socket）(传输层）（TCP&#x2F;IP）"></a>网络编程（socket）(传输层）（TCP&#x2F;IP）</h1><h2 id="1-基础原理（7层模型）"><a href="#1-基础原理（7层模型）" class="headerlink" title="1.基础原理（7层模型）"></a>1.基础原理（7层模型）</h2><h2 id="2-什么是Socket"><a href="#2-什么是Socket" class="headerlink" title="2.什么是Socket"></a>2.什么是Socket</h2><p>流式套接字（SOCK_STREAM）</p><p>面向链接、可靠的数据传输服务，基于TCP协议</p><p>数据报式套接字（SOCK_DGRAM）</p><p>无连接服务(UDP)</p><p>原始套接字（SOCK_RAW）</p><p>操作下层</p><p>传输层的API</p><h2 id="3-java-net包"><a href="#3-java-net包" class="headerlink" title="3.java.net包"></a>3.java.net包</h2><p>Socket</p><p>ServerSocket</p><p>DatagramPacket</p><p>DatagramSocket</p><p>InetAddress</p><p>…</p><h2 id="4-基于TCP协议的socket网络编程一般可以分为以下几个步骤"><a href="#4-基于TCP协议的socket网络编程一般可以分为以下几个步骤" class="headerlink" title="4.基于TCP协议的socket网络编程一般可以分为以下几个步骤"></a>4.基于TCP协议的socket网络编程一般可以分为以下几个步骤</h2><p>&lt;C&#x2F;S&gt;模式</p><p>①创建Client端和Server端两个Socket对象，对于Client端时Socket对象、对于Server端是ServerSocket对象</p><p>②在Client端和Server端之间建立连接</p><p>③在输入和输出之间借助数据流来传递信息</p><p>④关闭所有数据流和Socket</p><h2 id="5-socket中实现对象的传输"><a href="#5-socket中实现对象的传输" class="headerlink" title="5.socket中实现对象的传输"></a>5.socket中实现对象的传输</h2><p>借助于序列化和反序列化就能实现</p><p><img src="/2022/10/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/WEBRESOURCE97f71c4a1f3001729950f4a437554737.png"></p><h2 id="6-多线程处理多请求"><a href="#6-多线程处理多请求" class="headerlink" title="6.多线程处理多请求"></a>6.多线程处理多请求</h2><p>借助多线程，实现多客户端与服务器网络通信</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java实现10种排序</title>
    <link href="/2022/10/21/Java%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/10/21/Java%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>#Java实现10种排序算法<br>参考：<a href="https://blog.csdn.net/weixin_44531966/article/details/116464294">https://blog.csdn.net/weixin_44531966/article/details/116464294</a></p><p>#Java排序实现<br>参考：<a href="https://blog.csdn.net/whp1473/article/details/79678974">https://blog.csdn.net/whp1473/article/details/79678974</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java重写(Override)与重载(Overload)</title>
    <link href="/2022/10/21/Java%E9%87%8D%E5%86%99-Override-%E4%B8%8E%E9%87%8D%E8%BD%BD-Overload/"/>
    <url>/2022/10/21/Java%E9%87%8D%E5%86%99-Override-%E4%B8%8E%E9%87%8D%E8%BD%BD-Overload/</url>
    
    <content type="html"><![CDATA[<h1 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a>重写(Override)</h1><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！</p><p>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p><p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，抛出 IOException 异常或者 IOException 的子类异常。</p><p>在面向对象原则里，重写意味着可以重写任何现有方法。实例如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span>()</span>&#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;动物可以移动&quot;</span>);<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-title">extends</span> <span class="hljs-title">Animal</span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span>()</span>&#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;狗可以跑和走&quot;</span>);<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestDog</span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String args[]</span>)</span>&#123;<br>      Animal a = <span class="hljs-keyword">new</span> Animal(); <span class="hljs-comment">// Animal 对象</span><br>      Animal b = <span class="hljs-keyword">new</span> Dog(); <span class="hljs-comment">// Dog 对象</span><br> <br>      a.move();<span class="hljs-comment">// 执行 Animal 类的方法</span><br> <br>      b.move();<span class="hljs-comment">//执行 Dog 类的方法</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上实例编译运行结果如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">动物可以移动<br>狗可以跑和走<br></code></pre></td></tr></table></figure><p>在上面的例子中可以看到，尽管 b 属于 Animal 类型，但是它运行的是 Dog 类的 move方法。</p><p>这是由于在编译阶段，只是检查参数的引用类型。</p><p>然而在运行时，Java 虚拟机(JVM)指定对象的类型并且运行该对象的方法。</p><p>因此在上面的例子中，之所以能编译成功，是因为 Animal 类中存在 move 方法，然而运行时，运行的是特定对象的方法。</p><p>思考以下例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span>()</span>&#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;动物可以移动&quot;</span>);<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-title">extends</span> <span class="hljs-title">Animal</span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span>()</span>&#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;狗可以跑和走&quot;</span>);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bark</span>()</span>&#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;狗可以吠叫&quot;</span>);<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestDog</span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String args[]</span>)</span>&#123;<br>      Animal a = <span class="hljs-keyword">new</span> Animal(); <span class="hljs-comment">// Animal 对象</span><br>      Animal b = <span class="hljs-keyword">new</span> Dog(); <span class="hljs-comment">// Dog 对象</span><br> <br>      a.move();<span class="hljs-comment">// 执行 Animal 类的方法</span><br>      b.move();<span class="hljs-comment">//执行 Dog 类的方法</span><br>      b.bark();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上实例编译运行结果如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">TestDog.java:<span class="hljs-number">30</span>: cannot find symbol<br>symbol  : <span class="hljs-keyword">method</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span><br><span class="hljs-title function_">location</span>: <span class="hljs-keyword">class</span> Animal<br>                b.bark()<span class="hljs-punctuation">;</span><br>                 ^<br></code></pre></td></tr></table></figure><p>该程序将抛出一个编译错误，因为b的引用类型Animal没有bark方法。</p><hr><h2 id="方法的重写规则"><a href="#方法的重写规则" class="headerlink" title="方法的重写规则"></a>方法的重写规则</h2><ul><li><p>参数列表与被重写方法的参数列表必须完全相同。</p></li><li><p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p></li><li><p>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</p></li><li><p>父类的成员方法只能被它的子类重写。</p></li><li><p>声明为 final 的方法不能被重写。</p></li><li><p>声明为 static 的方法不能被重写，但是能够被再次声明。</p></li><li><p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</p></li><li><p>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</p></li><li><p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</p></li><li><p>构造方法不能被重写。</p></li><li><p>如果不能继承一个类，则不能重写该类的方法。</p></li></ul><hr><h2 id="Super-关键字的使用"><a href="#Super-关键字的使用" class="headerlink" title="Super 关键字的使用"></a>Super 关键字的使用</h2><p>当需要在子类中调用父类的被重写方法时，要使用 super 关键字。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">move</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;动物可以移动&quot;</span>);<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">move</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">move</span>(); <span class="hljs-comment">// 应用super类的方法</span><br>      <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;狗可以跑和走&quot;</span>);<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDog</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> args[]</span>)&#123;<br> <br>      <span class="hljs-title class_">Animal</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <span class="hljs-comment">// Dog 对象</span><br>      b.<span class="hljs-title function_">move</span>(); <span class="hljs-comment">//执行 Dog类的方法</span><br> <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上实例编译运行结果如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">动物可以移动<br>狗可以跑和走<br></code></pre></td></tr></table></figure><h2 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h2><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p><p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><p>最常用的地方就是构造器的重载。</p><p>重载规则:</p><ul><li><p>被重载的方法必须改变参数列表(参数个数或类型不一样)；</p></li><li><p>被重载的方法可以改变返回类型；</p></li><li><p>被重载的方法可以改变访问修饰符；</p></li><li><p>被重载的方法可以声明新的或更广的检查异常；</p></li><li><p>方法能够在同一个类中或者在一个子类中被重载。</p></li><li><p>无法以返回值类型作为重载函数的区分标准。</p></li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Overloading</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">test</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;test1&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;test2&quot;</span>);<br>    &#125;   <br> <br>    <span class="hljs-comment">//以下两个参数类型顺序不同</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a,String s</span>)</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;test3&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;returntest3&quot;</span>;<br>    &#125;   <br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test</span>(<span class="hljs-params">String s,<span class="hljs-built_in">int</span> a</span>)</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;test4&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;returntest4&quot;</span>;<br>    &#125;   <br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span>&#123;<br>        Overloading o = <span class="hljs-keyword">new</span> Overloading();<br>        System.<span class="hljs-keyword">out</span>.println(o.test());<br>        o.test(<span class="hljs-number">1</span>);<br>        System.<span class="hljs-keyword">out</span>.println(o.test(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;test3&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.println(o.test(<span class="hljs-string">&quot;test4&quot;</span>,<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重写与重载之间的区别"><a href="#重写与重载之间的区别" class="headerlink" title="重写与重载之间的区别"></a>重写与重载之间的区别</h2><table><thead><tr><th>区别点</th><th>重载方法</th><th>重写方法</th></tr></thead><tbody><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可以修改</td><td>一定不能修改</td></tr><tr><td>异常</td><td>可以修改</td><td>可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td>访问</td><td>可以修改</td><td>一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p><ul><li><p>(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</p></li><li><p>(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</p></li><li><p>(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</p></li></ul><p><img src="/2022/10/21/Java%E9%87%8D%E5%86%99-Override-%E4%B8%8E%E9%87%8D%E8%BD%BD-Overload/WEBRESOURCE45b7836d5382c120eea20fcb0db55d5b.png"></p><p><img src="/2022/10/21/Java%E9%87%8D%E5%86%99-Override-%E4%B8%8E%E9%87%8D%E8%BD%BD-Overload/WEBRESOURCE9f2ee55d8ea4cd593246c0c4fa8be779.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java重写(Override)与重载(Overload)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java高级</title>
    <link href="/2022/10/21/Java%E9%AB%98%E7%BA%A7/"/>
    <url>/2022/10/21/Java%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p>#接口</p><p>##接口的描述：</p><p>接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用，Java中的接口更多的体现在对行为的抽象</p><p>##接口的特点：</p><p>接口用关键字interface修饰</p><p>public interface 接口名{}</p><p>类实现接口用implements表示</p><p>public class 类名 implement 接口名{}</p><p>接口不能实例化</p><p>接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态。</p><p>多态的形式：具体类多态，抽象类多态，接口多态。</p><p>多态的前提：有继承或者实现关系；有方法重写；有父（类&#x2F;接口）英勇只想（子&#x2F;实现）类对象</p><p>接口的实现类</p><p>要么重写接口中的所有抽象方法</p><p>要么是抽象类</p><p>##接口的成员特点：</p><p>###成员变量</p><p>###只能是常量</p><p>默认修饰符：public static final</p><p>###构造方法</p><p>接口没有构造方法，应为接口主要是对行为进行抽象的，是没有具体存在</p><p>一个类如果没有父类，默认继承自Object类</p><p>###成员方法</p><p>只能是抽象方法</p><p>默认修饰符：public abstract</p><p>#类和接口的关系：</p><p>类和类的关系</p><p>继承关系，只能单继承，但是可以多层继承</p><p>类和接口的关系</p><p>实现关系，可以单实线，也可以多实现，还可以在继承一个类的同时实现多个接口</p><p>接口和接口的关系</p><p>继承关系，可以单继承，也可以多继承</p><p>    </p><p>#抽象类和接口的区别</p><p>成员区别</p><p>|抽象类|变量，常量；有构造方法；有抽象方法，也有非抽象方法。|</p><p>|接口|常量；抽象方法。|</p><blockquote></blockquote><p>关系区别</p><p>|类与类|继承，单继承，多层继承|</p><p>|类与接口|实现，可以单实现，也可以多实现|</p><p>|接口与接口|继承，单继承，多继承|</p><blockquote></blockquote><p>设计理念区别</p><p>|抽象类|对类抽象，包括属性、行为|</p><p>|接口|对行为抽象，主要是行为|</p><blockquote></blockquote><p>形参和返回值</p><p>抽象类名作为形参和返回值</p><p>方法的形参是抽象类名，其实需要的时该抽象类的子类对象</p><p>方法的返回值是抽象类名，其实返回的是该抽象类的子类对象</p><p>接口名作为形参和和返回值</p><p>方法的形参是接口名，其实需要的是该接口的实现类对象</p><p>方法的返回值是接口名，其实返回的是该接口的实现类对象</p><p>内部类</p><p>内部类：就是在一个类中定义一个类。举例：在一个类A的内部定义一个类B，类B就被称为内部类</p><p>pblic class A{</p><p>public class B{</p><p>}</p><p>}</p><p>内部类的访问特点：</p><p>内部类可以直接访问外部类的成员，包括私有。</p><p>外部类要访问内部类的成员，必须创建对象。</p><p>成员内部类</p><p>按照内部类在类中定义的位置不同，可以分为如下两种形式</p><p>在类的成员位置：成员内部类</p><p>在类的局部位置：局部内部类</p><p>成员内部类，外界如何创建对象使用呢？</p><p>格式：外部类名.内部类名 对象名 &#x3D; 外部类对象.内部类对象；</p><p>范例：Outer.Inner oi &#x3D; new Outer().new Inner();</p><p>当成员内部类为私有时，在外部类中创建方法间接调用内部类：</p><p><img src="/2022/10/21/Java%E9%AB%98%E7%BA%A7/A671AF24A1314FA4B56D98FB43007486.png"></p><p>局部内部类</p><p>是在方法中定义的类，所以外界是无法直接使用的，需要在方法内部创建对象并使用</p><p>该类可以直接访问外部类的成员，也可以访问方法内的局部变量。</p><p>匿名内部类</p><p>格式：</p><p>new 类名或接口名（）{</p><p>重写方法；</p><p>}；</p><p>范例：</p><p>new Inter（）{</p><p>public void show（）{</p><p>}</p><p>}；</p><p>本质：是一个继承了该类或者实现了该接口的子类匿名对象</p><p><img src="/2022/10/21/Java%E9%AB%98%E7%BA%A7/32E1A5D1032C411B98EC1B46B2BBAE38.png"></p><p>调用：</p><p><img src="/2022/10/21/Java%E9%AB%98%E7%BA%A7/AB98A7AD90824370990DD54D9EE8E7D1.png"></p><p>Math,System,Object类的toString(),Object类的equals()</p><p>intellIj如何看方法的源码：选中方法，按下Ctrl+B</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8新特性之Stream流的集合操作</title>
    <link href="/2022/10/21/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream%E6%B5%81%E7%9A%84%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/10/21/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream%E6%B5%81%E7%9A%84%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="概JDK8-Stream详解"><a href="#概JDK8-Stream详解" class="headerlink" title="概JDK8 Stream详解"></a>概JDK8 Stream详解</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote></blockquote><p>Stream是Java8 API的新成员，它允许以声明性方式处理数据集合 。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><blockquote></blockquote><p>（1）代码简洁：函数式编程写出的代码简洁且意图明确，使用stream接口让你从此告别for循环。<br>（2）多核友好：Java函数式编程使得编写并行程序从未如此简单，你需要的全部就是调用一下方法。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-number">1</span>）第一步：把集合转换为流<span class="hljs-keyword">stream</span><br><span class="hljs-number">2</span>）第二步：操作<span class="hljs-keyword">stream</span>流<br><span class="hljs-keyword">stream</span>流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果<br><br></code></pre></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><blockquote></blockquote><p>两种：中间操作符、终止操作符</p><h3 id="中间操作符"><a href="#中间操作符" class="headerlink" title="中间操作符"></a>中间操作符</h3><table><thead><tr><th>流方法</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>filter</td><td>用于通过设置的条件过滤出元素</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“abc”, “”, “bc”, “efg”, “abcd”,””, “jkl”);List&lt;String&gt; filtered &#x3D; strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</td></tr><tr><td>distinct</td><td>返回一个元素各异（根据流所生成元素的hashCode和equals方法实现）的流。</td><td>List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 1, 3, 3, 2, 4);numbers.stream().filter(i -&gt; i % 2 &#x3D;&#x3D; 0).distinct().forEach(System.out::println);</td></tr><tr><td>limit</td><td>会返回一个不超过给定长度的流。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“abc”, “abc”, “bc”, “efg”, “abcd”,”jkl”, “jkl”);List&lt;String&gt; limited &#x3D; strings.stream().limit(3).collect(Collectors.toList());</td></tr><tr><td>skip</td><td>返回一个扔掉了前n个元素的流。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“abc”, “abc”, “bc”, “efg”, “abcd”,”jkl”, “jkl”);List&lt;String&gt; skiped &#x3D; strings.stream().skip(3).collect(Collectors.toList());</td></tr><tr><td>map</td><td>接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是&quot;创建一个新版本”而不是去&quot;修改”）。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“abc”, “abc”, “bc”, “efg”, “abcd”,”jkl”, “jkl”);List&lt;String&gt; mapped &#x3D; strings.stream().map(str-&gt;str+”-itcast”).collect(Collectors.toList());</td></tr><tr><td>flatMap</td><td>使用flatMap方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。所有使用map(Arrays::stream)时生成的单个流都被合并起来，即扁平化为一个流。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“abc”, “abc”, “bc”, “efg”, “abcd”,”jkl”, “jkl”);Stream&lt;Character&gt; flatMap &#x3D; strings.stream().flatMap(Java8StreamTest::getCharacterByString);</td></tr><tr><td>sorted</td><td>返回排序后的流</td><td>List&lt;String&gt; strings1 &#x3D; Arrays.asList(“abc”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);List&lt;String&gt; sorted1 &#x3D; strings1.stream().sorted().collect(Collectors.toList());</td></tr></tbody></table><blockquote></blockquote><p>示例代码：<br>1）filter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述:根据条件过滤集合数据<br>* @return : void<br>*/<br>  @Test<br>  public void filter()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);<br>  List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());<br>  out.println(filtered);<br>  &#125;<br></code></pre></td></tr></table></figure><p>2）distinct</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述:去除集合中重复数据<br>* @return : void<br>*/<br>  @Test<br>  public void distinct()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;abc&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  List&lt;String&gt; distincted = strings.stream().distinct().collect(Collectors.toList());<br>  out.println(distincted);<br>  &#125;<br></code></pre></td></tr></table></figure><p>3）limit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述:指定获取集合前x条数据，重新构造一个新的集合<br>* @return : void<br>*/<br>  @Test<br>  public void limit()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;abc&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  List&lt;String&gt; limited = strings.stream().limit(3).collect(Collectors.toList());<br>  out.println(limited);<br>  &#125;<br></code></pre></td></tr></table></figure><p>4）skip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述:排除集合前x条数据，把后面的数据重新构造一个新的集合<br>* @return : void<br>*/<br>  @Test<br>  public void skip()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;abc&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  List&lt;String&gt; skiped = strings.stream().skip(3).collect(Collectors.toList());<br>  out.println(skiped);<br>  &#125;<br></code></pre></td></tr></table></figure><p>5）map</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">    /**<br>    * 功能描述:对集合中所有元素统一处理<br>* @return : void<br>  */<br>  @Test<br>  public void map()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;abc&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  List&lt;String&gt; mapped = strings.stream().map(str-&gt;str+&quot;-itcast&quot;).collect(Collectors.toList());<br>  out.println(mapped);<br>  &#125;<br></code></pre></td></tr></table></figure><p>6）flatMap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述:对集合中所有元素统一处理<br>* @return : void<br>*/<br>  @Test<br>  public void flatMap()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;abc&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  Stream&lt;String&gt; stringStream = strings.stream().map(x -&gt; x);<br>  Stream&lt;String&gt; stringStream1 = strings.stream().flatMap(x -&gt; Arrays.asList(x.split(&quot; &quot;)).stream());<br>  &#125;<br></code></pre></td></tr></table></figure><p>7）sorted</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述 : 对集合进行排序<br>* @return : void<br>*/<br>  @Test<br>  public void sorted()&#123;<br>  List&lt;String&gt; strings1 = Arrays.asList(&quot;abc&quot;, &quot;abd&quot;, &quot;aba&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  List&lt;String&gt; strings2 = Arrays.asList(&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵柳&quot;, &quot;张哥&quot;,&quot;李哥&quot;, &quot;王哥&quot;);<br>  List&lt;Integer&gt; strings3 = Arrays.asList(10, 2, 30, 22, 1,0, -9);<br>  List&lt;String&gt; sorted1 = strings1.stream().sorted().collect(Collectors.toList());<br>  List&lt;String&gt; sorted2 = strings2.stream().sorted(Collections.reverseOrder(Collator.getInstance(Locale.CHINA))).collect(Collectors.toList());<br>  List&lt;Integer&gt; sorted3 = strings3.stream().sorted().collect(Collectors.toList());<br>  out.println(sorted1);<br>  out.println(sorted2);<br>  out.println(sorted3);<br>  &#125;<br></code></pre></td></tr></table></figure><p>Map、flatMap区别</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">map</span>：对流中每一个元素进行处理<br>flatMap：流扁平化，让你把一个流中的“每个值”都换成另一个流，然后把所有的流连接起来成为一个流 <br>总结：<span class="hljs-built_in">map</span>是对一级元素进行操作，flatmap是对二级元素操作。<br><br></code></pre></td></tr></table></figure><p>本质区别：map返回一个值；flatmap返回一个流，多个值。</p><p>应用场景：map对集合中每个元素加工,返回加工后结果；flatmap对集合中每个元素加工后，做扁平化处理后（拆分层级，放到同一层）然后返回</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 方法一</span><br><span class="hljs-comment"> * 功能描述:  通过使用map、flatMap把字符串转换为字符输出对比区别</span><br><span class="hljs-comment"> * @return : void</span><br><span class="hljs-comment"> */</span><br>@Test<br>public void flat<span class="hljs-constructor">Map2Map()</span>&#123;<br>    List&lt;String&gt; strings = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;bc&quot;</span>, <span class="hljs-string">&quot;efg&quot;</span>, <span class="hljs-string">&quot;abcd&quot;</span>,<span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>)</span>;<br>    final Stream&lt;Character&gt; flatMap = strings.stream<span class="hljs-literal">()</span>.flat<span class="hljs-constructor">Map(Java8StreamTest::<span class="hljs-params">getCharacterByString</span>)</span>;<br>    flatMap.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;<br>    <span class="hljs-comment">//----------------------------------------------</span><br>    final Stream&lt;Stream&lt;Character&gt;&gt; mapStream = strings.stream<span class="hljs-literal">()</span>.map(Java8StreamTest::getCharacterByString);<br>    <span class="hljs-comment">//mapStream.forEach(System.out::println);</span><br>    out.println(<span class="hljs-string">&quot;------------------------------------------------&quot;</span>);<br>    mapStream.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(<span class="hljs-params">stream</span>-&gt; &#123;<span class="hljs-params">stream</span>.<span class="hljs-params">forEach</span>(<span class="hljs-params">character</span>-&gt;&#123;System.<span class="hljs-params">out</span>.<span class="hljs-params">println</span>(<span class="hljs-params">character</span>)</span>;&#125;);&#125;);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote></blockquote><p>公共方法（字符串转换为字符流）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 功能描述:字符串转换为字符流</span><br><span class="hljs-comment">* @param str</span><br><span class="hljs-comment">* @return : java.util.stream.Stream&lt;java.lang.Character&gt;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">public</span> static Stream&lt;<span class="hljs-type">Character</span>&gt; getCharacterByString(String str) &#123;<br>    List&lt;<span class="hljs-type">Character</span>&gt; characterList = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Character</span> <span class="hljs-type">character</span> : str.toCharArray()) &#123;<br>    characterList.<span class="hljs-keyword">add</span>(<span class="hljs-type">character</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> characterList.stream();<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="终止操作符"><a href="#终止操作符" class="headerlink" title="终止操作符"></a>终止操作符</h3><table><thead><tr><th>流方法</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>anyMatch</td><td>检查是否至少匹配一个元素，返回boolean。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“abc”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);boolean b &#x3D; strings.stream().anyMatch(s -&gt; s &#x3D;&#x3D; “abc”);</td></tr><tr><td>allMatch</td><td>检查是否匹配所有元素，返回boolean。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“abc”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);boolean b &#x3D; strings.stream().allMatch(s -&gt; s &#x3D;&#x3D; “abc”);</td></tr><tr><td>noneMatch</td><td>检查是否没有匹配所有元素，返回boolean。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“abc”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);boolean b &#x3D; strings.stream().noneMatch(s -&gt; s &#x3D;&#x3D; “abc”);</td></tr><tr><td>findAny</td><td>将返回当前流中的任意元素。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“cv”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);Optional&lt;String&gt; any &#x3D; strings.stream().findAny();</td></tr><tr><td>findFirst</td><td>返回第一个元素</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“cv”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);Optional&lt;String&gt; first &#x3D; strings.stream().findFirst();</td></tr><tr><td>forEach</td><td>遍历流</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“cv”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);strings.stream().forEach(s -&gt; out.println(s));</td></tr><tr><td>collect</td><td>收集器，将流转换为其他形式。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“cv”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);Set&lt;String&gt; set &#x3D; strings.stream().collect(Collectors.toSet());List&lt;String&gt; list &#x3D; strings.stream().collect(Collectors.toList());Map&lt;String, String&gt; map &#x3D; strings.stream().collect(Collectors.toMap(v -&gt;v.concat(“_name”), v1 -&gt; v1, (v1, v2) -&gt; v1));</td></tr><tr><td>reduce</td><td>可以将流中元素反复结合起来，得到一个值。使用 reduce((T, T) -&gt; T) 和 reduce(T, (T, T) -&gt; T) 用于组合流中的元素，如求和，求积，求最大值等。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“cv”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);Optional&lt;String&gt; reduce &#x3D; strings.stream().reduce((acc,item) -&gt; {return acc+item;});if(reduce.isPresent())out.println(reduce.get());</td></tr><tr><td>count</td><td>返回流中元素总数。</td><td>List&lt;String&gt; strings &#x3D; Arrays.asList(“cv”, “abd”, “aba”, “efg”, “abcd”,”jkl”, “jkl”);long count &#x3D; strings.stream().count();</td></tr></tbody></table><blockquote></blockquote><p>示例代码<br>1）anyMatch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述 : 判断集合中是否至少存在一个元素满足条件<br>* @return : void<br>*/<br>  @Test<br>  public void anyMatch()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;abd&quot;, &quot;aba&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  boolean b = strings.stream().anyMatch(s -&gt; s == &quot;abc&quot;);<br>  out.println(b);<br>  &#125;<br></code></pre></td></tr></table></figure><p>2）allMatch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述 : 判断集合中是否所有元素都满足条件<br>* @return : void<br>*/<br>  @Test<br>  public void allMatch()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;abd&quot;, &quot;aba&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  boolean b = strings.stream().allMatch(s -&gt; s == &quot;abc&quot;);<br>  out.println(b);<br>  &#125;<br></code></pre></td></tr></table></figure><p>3）noneMatch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述 : 判断集合中是否所有元素都不满足条件<br>* @return : void<br>*/<br>  @Test<br>  public void noneMatch()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;abd&quot;, &quot;aba&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  boolean b = strings.stream().noneMatch(s -&gt; s == &quot;abc&quot;);<br>  out.println(b);<br>  &#125;<br></code></pre></td></tr></table></figure><p>4）findAny</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述 : 返回当前流中任意元素<br>* @return : void<br>*/<br>  @Test<br>  public void findAny()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;cv&quot;, &quot;abd&quot;, &quot;aba&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  Optional&lt;String&gt; any = strings.stream().findAny();<br>  if(any.isPresent()) out.println(any.get());<br>  &#125;<br></code></pre></td></tr></table></figure><p>5）findFirst</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述 : 返回当前流中第一个元素<br>* @return : void<br>*/<br>  @Test<br>  public void findFirst()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;cv&quot;, &quot;abd&quot;, &quot;aba&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  Optional&lt;String&gt; first = strings.stream().findFirst();<br>  if(first.isPresent()) out.println(first.get());<br>  &#125;<br></code></pre></td></tr></table></figure><p>6）forEach java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述 : 遍历流<br>* @return : void<br>*/<br>  @Test<br>  public void foreach()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;cv&quot;, &quot;abd&quot;, &quot;aba&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  strings.stream().forEach(s -&gt; out.println(s));<br>  &#125;<br></code></pre></td></tr></table></figure><p>7）collect</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述 : 流转换为其他形式<br>* @return : void<br>*/<br>  @Test<br>  public void collect()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;cv&quot;, &quot;abd&quot;, &quot;aba&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  Set&lt;String&gt; set = strings.stream().collect(Collectors.toSet());<br>  List&lt;String&gt; list = strings.stream().collect(Collectors.toList());<br>  Map&lt;String, String&gt; map = strings.stream().collect(Collectors.toMap(v -&gt;v.concat(&quot;_name&quot;), v1 -&gt; v1, (v1, v2) -&gt; v1));<br>  out.println(set);<br>  out.println(list);<br>  out.println(map);<br>  &#125;<br></code></pre></td></tr></table></figure><p>8）reduce</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">/**<br>* 功能描述 : 将流中元素反复结合起来，得到一个值<br>* @return : void<br>*/<br>  @Test<br>  public void reduce()&#123;<br>  List&lt;String&gt; strings = Arrays.asList(&quot;cv&quot;, &quot;abd&quot;, &quot;aba&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;jkl&quot;, &quot;jkl&quot;);<br>  //reduce方法一<br>  Optional&lt;String&gt; reduce1 = strings.stream().reduce((acc,item) -&gt; &#123;return acc+item;&#125;);<br>  //reduce方法二<br>  String reduce2 = strings.stream().reduce(&quot;itcast&quot;, (acc, item) -&gt; &#123;<br>  return acc + item;<br>  &#125;);<br>  //reduce方法三<br>  ArrayList&lt;String&gt; reduce3 = strings.stream().reduce(<br>  new ArrayList&lt;String&gt;(),<br>  new BiFunction&lt;ArrayList&lt;String&gt;, String, ArrayList&lt;String&gt;&gt;() &#123;<br>  @Override<br>  public ArrayList&lt;String&gt; apply(ArrayList&lt;String&gt; acc, String item) &#123;<br>  acc.add(item);<br>  return acc;<br>  &#125;<br>  &#125;,<br>  new BinaryOperator&lt;ArrayList&lt;String&gt;&gt;() &#123;<br>  @Override<br>  public ArrayList&lt;String&gt; apply(ArrayList&lt;String&gt; acc, ArrayList&lt;String&gt; item) &#123;<br>  return acc;<br>  &#125;<br>  &#125;<br>  );<br>  if(reduce1.isPresent())out.println(reduce1.get());<br>  out.println(reduce2);<br>  out.println(reduce3);<br>  &#125;<br></code></pre></td></tr></table></figure><p>9）count</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 功能描述 : 返回流中元素总数</span><br><span class="hljs-comment">* @return : void</span><br><span class="hljs-comment">*/</span><br>  @Test<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">count</span>()&#123;<br>  List&lt;String&gt; strings = Arrays.<span class="hljs-keyword">asList</span>(<span class="hljs-string">&quot;cv&quot;</span>, <span class="hljs-string">&quot;abd&quot;</span>, <span class="hljs-string">&quot;aba&quot;</span>, <span class="hljs-string">&quot;efg&quot;</span>, <span class="hljs-string">&quot;abcd&quot;</span>,<span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>);<br>  <span class="hljs-keyword">long</span> <span class="hljs-keyword">count</span> = strings.stream().<span class="hljs-keyword">count</span>();<br>  out.<span class="hljs-keyword">println</span>(<span class="hljs-keyword">count</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><p>注意：文章中因排序部分用到外部比较器，需要导入外部jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--apache集合操作工具包--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections4<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h1 id="https-www-cnblogs-com-shoshana-kong-p-14406683-html"><a href="#https-www-cnblogs-com-shoshana-kong-p-14406683-html" class="headerlink" title="https://www.cnblogs.com/shoshana-kong/p/14406683.html"></a><a href="https://www.cnblogs.com/shoshana-kong/p/14406683.html">https://www.cnblogs.com/shoshana-kong/p/14406683.html</a></h1>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8新特性</tag>
      
      <tag>Stream流代替for循环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO流、序列化、反序列化</title>
    <link href="/2022/10/21/IO%E6%B5%81%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2022/10/21/IO%E6%B5%81%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="IOStream"><a href="#IOStream" class="headerlink" title="IOStream"></a>IOStream</h1><p>1.字节流（操作字节）</p><p>字节流的抽象父类</p><p>InputStream</p><p>OutputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteCopy<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;jietu.png&quot;</span>);<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;copy.png&quot;</span>);<br><br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<span class="hljs-comment">//“容器”</span><br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len=fis.read(bytes))!=-<span class="hljs-number">1</span>)&#123;<br>            fos.write(bytes,<span class="hljs-number">0</span>,len);<br>        &#125;<br>        fos.close();<br>        fis.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>BufferedInputStream类</p><p>BufferedOutputStream类</p><p>BufferedInputStream内置了一个缓冲区（数组）</p><p>从BufferedInputStream中读取一个字节时BufferedInputStream会一次性从文件中读取8192个，存在缓冲区中，每次返回给程序一个</p><p>程序再次读取时，就不用找文件了，直接从缓冲区中获取，知道缓冲区中所有的都被使用过，才重新从文件中读取8192个。</p><p>BufferedOutputStream也内置了一个缓冲区（数组）</p><p>程序向流中写出字节时，不会直接写到文件，先写到缓冲区中，知道缓冲区写满，BufferedOutputStream才会吧缓冲区中的数据一次</p><p>性写到文件里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">BufferCopy<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test5</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;jietu.png&quot;</span>);<br>    <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;copy.png&quot;</span>);<br>    <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fos);<br>    <br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-keyword">while</span> ((b = bis.read()) != -<span class="hljs-number">1</span>) &#123;<br>        bos.write(b);<br>    &#125;<br><br>    bis.close();<span class="hljs-comment">//close方法具备刷新的功能，在关闭之前们就会先刷新一次缓冲区，将缓冲区的字节全部都刷新到文件上，再关闭</span><br>    bos.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>字节流读取中文时是可能有问题的，因为有时可能会读到半个中文造成乱码。</p><p>输入输出的标准代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span>()</span>&#123;<br>    FileInputStream fis;<br>    FileOutputStream fos;<br>    <span class="hljs-keyword">try</span> &#123;<br>        fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;jietu.png&quot;</span>);<br>        fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;copy.png&quot;</span>);<br>        <span class="hljs-built_in">int</span> b;<br>        <span class="hljs-keyword">while</span> ((b = fis.read()) != <span class="hljs-number">-1</span>) &#123;<br>            fos.write(b);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(bis != <span class="hljs-literal">null</span>)<br>            fis.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                fos.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>2.字符流（操作字符）</p><p>字符流的抽象父类</p><p>Reader类</p><p>Writer类</p><p>DateInputStream类</p><p>DateOutputStream类</p><p>4.IO程序书写</p><p>使用前，导入IO包中的类</p><p>使用时，进行IO异常处理</p><p>使用后，释放资源</p><h1 id="Serializable（json、ProtoBuf）"><a href="#Serializable（json、ProtoBuf）" class="headerlink" title="Serializable（json、ProtoBuf）"></a>Serializable（json、ProtoBuf）</h1><p>(Java序列化就是指把Java对象转换为字节序列的过程</p><p>Java反序列化就是指把字节序列恢复为Java对象的过程。</p><p>序列化最重要的作用：在传递和保存对象时.保证对象的完整性和可传递性。对象转换为有序字节流,以便在网络上传输或者保存在本地文件中。</p><p>反序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。</p><p>总结：核心作用就是对象状态的保存和重建。（整个过程核心点就是字节流中所保存的对象状态及描述信息）</p><p>实体类序列化</p><p>对象序列化：ObjectOutputStream类</p><p>对象反序列化：ObjectInputStream类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>:</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: Kblayt</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@time</span>: 2022/2/28 11:29</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final long serialVersionUID = -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> <span class="hljs-title class_">Name</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> <span class="hljs-title class_">Age</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Name</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>) &#123;<br>        <span class="hljs-title class_">Name</span> = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getAge</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Age</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setAge</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> age</span>) &#123;<br>        <span class="hljs-title class_">Age</span> = age;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_">String</span> name, <span class="hljs-title class_">String</span> age) &#123;<br>        <span class="hljs-title class_">Name</span> = name;<br>        <span class="hljs-title class_">Age</span> = age;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>:序列化和反序列化</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: Kblayt</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@time</span>: 2022/2/28 11:32</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-comment">//序列化</span><br>        FileOutputStream fos;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;object.out&quot;</span>);<br>            oos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(fos);<br>            s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;lhg&quot;</span>,<span class="hljs-string">&quot;18&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                oos.writeObject(s1);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                oos.flush();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                oos.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//反序列化</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;object.out&quot;</span>);<br>            ois = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(fis);<br>            <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> (Student) ois.readObject();<br>            System.out.println(s2.getName()+<span class="hljs-string">&quot;&quot;</span>+s2.getAge());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            ois.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO流</tag>
      
      <tag>序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/10/18/hello-world/"/>
    <url>/2022/10/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
